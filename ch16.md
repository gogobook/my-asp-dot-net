

Reflection, Metadata, and Dynamic
Programming
WHAT’S IN THIS CHAPTER?
Using custom attributes
Inspecting the metadata at runtime using reflection
Building access points from classes that enable reflection
Working with the dynamic type
Creating dynamic objects with DynamicObject and
ExpandoObject
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory ReflectionAndDynamic .
The code for this chapter is divided into the following major
examples:
LookupWhatsNew
TypeView


VectorClass
WhatsNewAttributes
Dynamic
DynamicFileReader
INSPECTING CODE AT RUNTIME AND DYNAMIC
PROGRAMMING
This chapter focuses on custom attributes, reflection, and dynamic
programming. Custom attributes are mechanisms that enable you to
associate custom metadata with program elements. This metadata is
created at compile time and embedded in an assembly. Reflection is a
generic term that describes the capability to inspect and manipulate
program elements at runtime. For example, reflection allows you to do
the following:
Enumerate the members of a type.
Instantiate a new object.
Execute the members of an object.
Find out information about a type.
Find out information about an assembly.
Inspect the custom attributes applied to a type.
Create and compile a new assembly.
This list represents a great deal of functionality and encompasses
some of the most powerful and complex capabilities provided by the
.NET class library. Because one chapter does not have the space to
cover all the capabilities of reflection, I focus on those elements that
you are likely to use most frequently.
To demonstrate custom attributes and reflection, in this chapter you
first develop an example based on a company that regularly ships
upgrades of its software and wants to have details about these
upgrades documented automatically. In the example, you define


custom attributes that indicate the date when program elements were
last modified, and what changes were made. You then use reflection to
develop an application that looks for these attributes in an assembly
and can automatically display all the details about what upgrades have
been made to the software since a given date.
Another example in this chapter considers an application that reads
from or writes to a database and uses custom attributes as a way to
mark which classes and properties correspond to which database
tables and columns. By reading these attributes from the assembly at
runtime, the program can automatically retrieve or write data to the
appropriate location in the database, without requiring specific logic
for each table or column.
The second big aspect of this chapter is dynamic programming, which
has been a part of the C# language since version 4 when the dynamic
type was added. The growth of languages such as Ruby and Python,
and the increased use of JavaScript, have intensified interest in
dynamic programming. Although C# is still a statically typed language,
the additions for dynamic programming give the C# language
capabilities that some developers are looking for. Using dynamic
language features allows for calling script functions from within C#.
In this chapter, you look at the dynamic type and the rules for using it.
You also see what an implementation of DynamicObject looks like and
how you can use it. ExpandoObject , which is the frameworks
implementation of DynamicObject , is also covered.
CUSTOM ATTRIBUTES
You have already seen in this book how you can define attributes on
various items within your program. These attributes have been defined
by Microsoft as part of .NET, and many of them receive special
support from the C# compiler. This means that for those particular
attributes, the compiler can customize the compilation process in
specific ways—for example, laying out a struct in memory according to
the details in the StructLayout attributes.
.NET also enables you to define your own attributes. Obviously, these


attributes don’t have any effect on the compilation process because the
compiler has no intrinsic awareness of them. However, these
attributes are emitted as metadata in the compiled assembly when
they are applied to program elements.
By itself, this metadata might be useful for documentation purposes,
but what makes attributes really powerful is that by using reflection,
your code can read this metadata and use it to make decisions at
runtime. This means that the custom attributes that you define can
directly affect how your code runs. For example, custom attributes can
be used to enable declarative code access security checks for custom
permission classes, to associate information with program elements
that can then be used by testing tools, or when developing extensible
frameworks that allow the loading of plug-ins or modules.
Writing Custom Attributes
To understand how to write your own custom attributes, it is useful to
know what the compiler does when it encounters an element in your
code that has a custom attribute applied to it. To take the database
example, suppose that you have a C# property declaration that looks
like this:
[FieldName("SocialSecurityNumber")]
public string SocialSecurityNumber
{
get {
//...
When the C# compiler recognizes that this property has an attribute
applied to it ( FieldName ), it first appends the string Attribute to this
name, forming the combined name FieldNameAttribute . The compiler
then searches all the namespaces in its search path (those namespaces
that have been mentioned in a using statement) for a class with the
specified name. Note that if you mark an item with an attribute whose
name already ends in the string Attribute , the compiler does not add
the string to the name a second time; it leaves the attribute name
unchanged. Therefore, the preceding code is equivalent to this:
[FieldNameAttribute("SocialSecurityNumber")]


public string SocialSecurityNumber
{
get {
//...
The compiler expects to find a class with this name, and it expects this
class to be derived directly or indirectly from System.Attribute . The
compiler also expects that this class contains information governing
the use of the attribute. In particular, the attribute class needs to
specify the following:
The types of program elements to which the attribute can be
applied (classes, structs, properties, methods, and so on)
Whether it is legal for the attribute to be applied more than once to
the same program element
Whether the attribute, when applied to a class or interface, is
inherited by derived classes and interfaces
The mandatory and optional parameters the attribute takes
If the compiler cannot find a corresponding attribute class, or if it
finds one but the way that you have used that attribute does not match
the information in the attribute class, the compiler raises a
compilation error. For example, if the attribute class indicates that the
attribute can be applied only to classes, but you have applied it to a
struct definition, a compilation error occurs.
Continuing with the example, assume that you have defined the
FieldName attribute like this:
[AttributeUsage(AttributeTargets.Property,
AllowMultiple=false, Inherited=false)]
public class FieldNameAttribute: Attribute
{
private string _name;
public FieldNameAttribute(string name)
{
_name = name;
}
}
The following sections discuss each element of this definition.


Specifying the AttributeUsage Attribute
The first thing to note is that the attribute class itself is marked with
an attribute—the System.AttributeUsage attribute. This is an attribute
defined by Microsoft for which the C# compiler provides special
support. (You could argue that AttributeUsage isn’t an attribute at all;
it is more like a meta-attribute, because it applies only to other
attributes, not simply to any class.) The primary purpose of
AttributeUsage is to identify the types of program elements to which
your custom attribute can be applied. This information is provided by
the first parameter of the AttributeUsage attribute. This parameter is
mandatory, and it is of an enumerated type, AttributeTargets . In the
previous example, you have indicated that the FieldName attribute can
be applied only to properties, which is fine, because that is exactly
what you have applied it to in the earlier code fragment. The members
of the AttributeTargets enumeration are as follows:
All
Assembly
Class
Constructor
Delegate
Enum
Event
Field
GenericParameter
Interface
Method
Module
Parameter
Property
ReturnValue


Struct
This list identifies all the program elements to which you can apply
attributes. Note that when applying the attribute to a program
element, you place the attribute in square brackets immediately before
the element. However, two values in the preceding list do not
correspond to any program element: Assembly and Module . An attribute
can be applied to an assembly or a module as a whole, rather than to
an element in your code; in this case the attribute can be placed
anywhere in your source code, but it must be prefixed with the
Assembly or Module keyword:
[assembly:SomeAssemblyAttribute(Parameters)]
[module:SomeAssemblyAttribute(Parameters)]
When indicating the valid target elements of a custom attribute, you
can combine these values using the bitwise OR operator. For example,
if you want to indicate that your FieldName attribute can be applied to
both properties and fields, you use the following:
[AttributeUsage(AttributeTargets.Property |
AttributeTargets.Field,
AllowMultiple=false, Inherited=false)]
public class FieldNameAttribute: Attribute
You can also use AttributeTargets.All to indicate that your attribute
can be applied to all types of program elements. The AttributeUsage
attribute also contains two other parameters: AllowMultiple and
Inherited . These are specified using the syntax of <ParameterName>=
<ParameterValue> , instead of simply specifying the values for these
parameters. These parameters are optional—you can omit them.
The AllowMultiple parameter indicates whether an attribute can be
applied more than once to the same item. The fact that it is set to false
indicates that the compiler should raise an error if it sees something
like this:
[FieldName("SocialSecurityNumber")]
[FieldName("NationalInsuranceNumber")]
public string SocialSecurityNumber
{
//...


If the Inherited parameter is set to true , an attribute applied to a class
or interface is also automatically applied to all derived classes or
interfaces. If the attribute is applied to a method or property, it
automatically applies to any overrides of that method or property, and
so on.
Specifying Attribute Parameters
This section demonstrates how you can specify the parameters that
your custom attribute takes. When the compiler encounters a
statement such as the following, it examines the parameters passed
into the attribute—which is a string—and looks for a constructor for
the attribute that takes exactly those parameters:
[FieldName("SocialSecurityNumber")]
public string SocialSecurityNumber
{
//...
If the compiler finds an appropriate constructor, it emits the specified
metadata to the assembly. If the compiler does not find an appropriate
constructor, a compilation error occurs. As discussed later in this
chapter, reflection involves reading metadata (attributes) from
assemblies and instantiating the attribute classes they represent.
Because of this, the compiler must ensure that an appropriate
constructor exists that allows the runtime instantiation of the specified
attribute.
In the example, you have supplied just one constructor for
FieldNameAttribute , and this constructor takes one string parameter.
Therefore, when applying the FieldName attribute to a property, you
must supply one string as a parameter, as shown in the preceding
code.
To allow a choice of what types of parameters should be supplied with
an attribute, you can provide different constructor overloads, although
normal practice is to supply just one constructor and use properties to
define any other optional parameters, as explained next.
Specifying Optional Attribute Parameters


As demonstrated with the AttributeUsage attribute, an alternative
syntax enables optional parameters to be added to an attribute. This
syntax involves specifying the names and values of the optional
parameters. It works through public properties or fields in the
attribute class. For example, suppose that you modify the definition of
the SocialSecurityNumber property as follows:
[FieldName("SocialSecurityNumber", Comment="This is the
primary key field")]
public string SocialSecurityNumber { get; set; }
{
//...
In this case, the compiler recognizes the <ParameterName>=
<ParameterValue> syntax of the second parameter and does not
attempt to match this parameter to a FieldNameAttribute constructor.
Instead, it looks for a public property or field (although public fields
are not considered good programming practice, so normally you will
work with properties) of that name that it can use to set the value of
this parameter. If you want the previous code to work, you have to add
some code to FieldNameAttribute :
[AttributeUsage(AttributeTargets.Property,
AllowMultiple=false, Inherited=false)]
public class FieldNameAttribute : Attribute
{
public string Comment { get; set; }
private string _fieldName;
public FieldNameAttribute(string fieldName)
{
_fieldName = fieldname;
}
//...
}
Custom Attribute Example: WhatsNewAttributes
In this section you start developing the example mentioned at the
beginning of the chapter. WhatsNewAttributes provides for an attribute
that indicates when a program element was last modified. This is a
more ambitious code example than many of the others in that it
consists of three separate assemblies:


WhatsNewAttributes —Contains
VectorClass —Contains
the definitions of the attributes
the code to which the attributes have been
applied
LookUpWhatsNew —Contains
the project that displays details about
items that have changed
Of these, only the LookUpWhatsNew assembly is a console application of
the type that you have used up until now. The remaining two
assemblies are libraries—they each contain class definitions but no
program entry point.
The WhatsNewAttributes Library
This section starts with the core WhatsNewAttributes .NET Standard
library. The source code is contained in the file WhatsNewAttributes.cs ,
which is located in the WhatsNewAttributes project of the
WhatsNewAttributes solution in the example code for this chapter.
The WhatsNewAttributes.cs file defines two attribute classes,
LastModifiedAttribute and SupportsWhatsNewAttribute . You use the
attribute LastModifiedAttribute to mark when an item was last
modified. It takes two mandatory parameters (parameters that are
passed to the constructor): the date of the modification and a string
containing a description of the changes. One optional parameter
named issues (for which a public property exists) can be used to
describe any outstanding issues for the item.
In practice, you would probably want this attribute to apply to
anything. To keep the code simple, its usage is limited here to classes,
methods, and constructors. You allow it to be applied more than once
to the same item ( AllowMultiple=true ) because an item might be
modified more than once, and each modification has to be marked
with a separate attribute instance.
is a smaller class representing an attribute that
doesn’t take any parameters. The purpose of this assembly attribute is
to mark an assembly for which you are maintaining documentation via
the LastModifiedAttribute . This way, the program that examines this
assembly later knows that the assembly it is reading is one on which
SupportsWhatsNew


you are actually using your automated documentation process. Here is
the complete source code for this part of the example (code file
WhatsNewAttributes/WhatsNewAttributes.cs ):
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Method |
AttributeTargets.Constructor, AllowMultiple=true,
Inherited=false)]
public class LastModifiedAttribute: Attribute
{
private readonly DateTime _dateModified;
private readonly string _changes;
public LastModifiedAttribute(string dateModified, string
changes)
{
_dateModified = DateTime.Parse(dateModified);
_changes = changes;
}
public DateTime DateModified => _dateModified;
public string Changes => _changes;
public string Issues { get; set; }
}
[AttributeUsage(AttributeTargets.Assembly)]
public class SupportsWhatsNewAttribute: Attribute
{
}
Based on what has been discussed, this code should be fairly clear.
Notice, however, that the properties DateModified and Changes are
read-only. Using the expression syntax, the compiler creates get
accessors. There is no need for set accessors because you are requiring
these parameters to be set in the constructor as mandatory
parameters. You need the get accessors so that you can read the values
of these attributes.
The VectorClass Library
The VectorClass .NET Standard library references the
WhatsNewAttributes library. After adding the using declarations, the
global assembly attribute marks the assembly to support the WhatsNew


attributes (code file VectorClass/Vector.cs ):
[assembly: SupportsWhatsNew]
The sample code for VectorClass makes use of the following
namespaces:
System
System.Collections
System.Collections.Generic
WhatsNewAttributes
Now for the code for the Vector class. Some LastModified attributes
are added to the class to mark changes:
[LastModified("19 Jul 2017", "updated for C# 7 and .NET Core
2")]
[LastModified("6 Jun 2015", "updated for C# 6 and .NET
Core")]
[LastModified("14 Deb 2010", "IEnumerable interface
implemented: " +
"Vector can be treated as a collection")]
[LastModified("10 Feb 2010", "IFormattable interface
implemented " +
"Vector accepts N and VE format specifiers")]
public class Vector : IFormattable, IEnumerable<double>
{
public Vector(double x, double y, double z)
{
X = x;
Y = y;
Z = z;
}
[LastModified("19 Jul 2017", "Reduced the number of code
lines")]
public Vector(Vector vector)
: this (vector.X, vector.Y, vector.Z { }
public double X { get; }
public double Y { get; }
public double Z { get; }
public string ToString(string format, IFormatProvider


formatProvider)
{
//...
You also mark the contained VectorEnumerator class:
[LastModified("6 Jun 2015",
"Changed to implement the generic interface
IEnumerator<T>")]
[LastModified("14 Feb 2010",
"Class created as part of collection support for Vector")]
private class VectorEnumerator : IEnumerator<double>
{
The version number for the library is defined in the csproj project file
(project file VectorClass/VectorClass.csproj ):
<PropertyGroup>
<TargetFramework>netstandard2.0</TargetFramework>
<Version>2.1.0</Version>
</PropertyGroup>
That’s as far as you can get with this example for now. You are unable
to run anything yet because all you have are two libraries. After taking
a look at reflection in the next section, you will develop the final part of
the example, in which you look up and display these attributes.
USING REFLECTION
In this section, you take a closer look at the System.Type class, which
enables you to access information concerning the definition of any
data type. You also look at the System.Reflection.Assembly class,
which you can use to access information about an assembly or to load
that assembly into your program. Finally, you combine the code in this
section with the code in the previous section to complete the
WhatsNewAttributes example.
The System.Type Class
So far you have used the Type class only to hold the reference to a type
as follows:


Type t = typeof(double);
Although previously referred to as a class, Type is an abstract base
class. Whenever you instantiate a Type object, you are actually
instantiating a class derived from Type . Type has one derived class
corresponding to each actual data type, though in general the derived
classes simply provide different overloads of the various Type methods
and properties that return the correct data for the corresponding data
type. They do not typically add new methods or properties. In general,
there are three common ways to obtain a Type reference that refers to
any given type.
You can use the C# typeof operator as shown in the preceding
code. This operator takes the name of the type (not in quotation
marks, however) as a parameter.
You can use the GetType method, which all classes inherit from
System.Object :
double d = 10;
Type t = d.GetType();
is called against a variable, rather than taking the name of
a type. Note, however, that the Type object returned is still
associated with only that data type. It does not contain any
information that relates to that instance of the type. The GetType
method can be useful if you have a reference to an object but you
are not sure what class that object is actually an instance of.
GetType
You can call the static method of the Type class, GetType :
Type t = Type.GetType("System.Double");
is really the gateway to much of the reflection functionality. It
implements a huge number of methods and properties—far too
many to provide a comprehensive list here. However, the following
subsections should give you a good idea of the kinds of things you
can do with the Type class. Note that the available properties are all
read-only; you use Type to find out about the data type—you cannot
use it to make any modifications to the type!
Type
Type Properties


You can divide the properties implemented by Type into three
categories. First, a number of properties retrieve the strings containing
various names associated with the class, as shown in the following
table:
PROPERTY RETURNS
Name
The name of the data type
FullName
The fully qualified name of the data type (including the
namespace name)
Namespace
The name of the namespace in which the data type is
defined
Second, it is possible to retrieve references to further type objects that
represent related classes, as shown in the following table.
PROPERTY
RETURNS TYPE REFERENCE
CORRESPONDING TO
BaseType
The immediate base type of this type
UnderlyingSystemType The type to which this type maps in the .NET
runtime (recall that certain .NET base types
actually map to specific predefined types
recognized by IL). This member is only
available in the full Framework.
A number of Boolean properties indicate whether this type is, for
example, a class , an enum , and so on. These properties include
IsAbstract , IsArray , IsClass , IsEnum , IsInterface , IsPointer ,
IsPrimitive (one of the predefined primitive data types), IsPublic ,
IsSealed , and IsValueType . The following example uses a primitive
data type:
Type intType = typeof(int);
Console.WriteLine(intType.IsAbstract); // writes false
Console.WriteLine(intType.IsClass); // writes false
Console.WriteLine(intType.IsEnum); // writes false
Console.WriteLine(intType.IsPrimitive); // writes true
Console.WriteLine(intType.IsValueType); // writes true
This example uses the Vector class:


Type vecType = typeof(Vector);
Console.WriteLine(vecType.IsAbstract); // writes false
Console.WriteLine(vecType.IsClass); // writes true
Console.WriteLine(vecType.IsEnum); // writes false
Console.WriteLine(vecType.IsPrimitive); // writes false
Console.WriteLine(vecType.IsValueType); // writes false
Finally, you can also retrieve a reference to the assembly in which the
type is defined. This is returned as a reference to an instance of the
System.Reflection.Assembly class, which is examined shortly:
Type t = typeof (Vector);
Assembly containingAssembly = new Assembly(t);
Methods
Most of the methods of System.Type are used to obtain details about
the members of the corresponding data type—the constructors,
properties, methods, events, and so on. Quite a large number of
methods exist, but they all follow the same pattern. For example, two
methods retrieve details about the methods of the data type: GetMethod
and GetMethods . GetMethod returns a reference to a
System.Reflection.MethodInfo object, which contains details about a
method. GetMethods returns an array of such references. As the names
suggest, the difference is that GetMethods returns details about all the
methods, whereas GetMethod returns details about just one method
with a specified parameter list. Both methods have overloads that take
an extra parameter, a BindingFlags enumerated value that indicates
which members should be returned—for example, whether to return
public members, instance members, static members, and so on.
For example, the simplest overload of GetMethods takes no parameters
and returns details about all the public methods of the data type:
Type t = typeof(double);
foreach (MethodInfo nextMethod in t.GetMethods())
{
//...
}
The member methods of Type that follow the same pattern are shown
in the following table. Note that plural names return an array.


TYPE OF OBJECT
RETURNED METHOD(S)
ConstructorInfo GetConstructor , GetConstructors
EventInfo GetEvent , GetEvents
FieldInfo GetField , GetFields
MemberInfo GetMember , GetMembers ,
GetDefaultMembers
MethodInfo GetMethod , GetMethods
PropertyInfo GetProperty , GetProperties
The GetMember and GetMembers methods return details about any or all
members of the data type, regardless of whether these members are
constructors, properties, methods, and so on.
The TypeView Example
This section demonstrates some of the features of the Type class with a
short example, TypeView , which you can use to list the members of a
data type. The example demonstrates how to use TypeView for a double ;
however, you can swap this type with any other data type just by
changing one line of the code in the example.
The result of running the application is this output to the console:
Analysis of type Double
Type Name: Double
Full Name: System.Double
Namespace: System
Base Type: ValueType
public members:
System.Double Method IsInfinity
System.Double Method IsPositiveInfinity
System.Double Method IsNegativeInfinity
System.Double Method IsNaN
System.Double Method CompareTo
System.Double Method CompareTo
System.Double Method Equals
System.Double Method op_Equality
System.Double Method op_Inequality
System.Double Method op_LessThan
System.Double Method op_GreaterThan


System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
System.Object
System.Double
System.Double
System.Double
System.Double
System.Double
System.Double
Method op_LessThanOrEqual
Method op_GreaterThanOrEqual
Method Equals
Method GetHashCode
Method ToString
Method ToString
Method ToString
Method ToString
Method Parse
Method Parse
Method Parse
Method Parse
Method TryParse
Method TryParse
Method GetTypeCode
Method GetType
Field MinValue
Field MaxValue
Field Epsilon
Field NegativeInfinity
Field PositiveInfinity
Field NaN
The console displays the name, full name, and namespace of the data
type as well as the name of the base type. Next, it simply iterates
through all the public instance members of the data type, displaying
for each member the declaring type, the type of member (method,
field, and so on), and the name of the member. The declaring type is
the name of the class that actually declares the type member (for
example, System.Double if it is defined or overridden in System.Double ,
or the name of the relevant base type if the member is simply inherited
from a base class).
does not display signatures of methods because you are
retrieving details about all public instance members through
MemberInfo objects, and information about parameters is not available
through a MemberInfo object. To retrieve that information, you would
need references to MethodInfo and other more specific objects, which
means that you would need to obtain details about each type of
member separately.
TypeView
The sample code for TypeView makes use of the following namespaces:
System


System.Reflection
System.Text
does display details about all public instance members for
doubles, the only details defined are fields and methods. The entire
code is in one class, Program , which has a couple of static methods
and one static field, a StringBuilder instance called OutputText ,
which is used to build the text to be displayed in the message box. The
Main method and class declaration look like this (code file
TypeView/Program.cs ):
TypeView
class Program
{
private static StringBuilder OutputText = new
StringBuilder();
static void Main()
{
// modify this line to retrieve details of any other data
type
Type t = typeof(double);
AnalyzeType(t);
Console.WriteLine($"Analysis of type {t.Name}");
Console.WriteLine(OutputText.ToString());
Console.ReadLine();
}
//...
}
The Main method implementation starts by declaring a Type object to
represent your chosen data type. You then call a method, AnalyzeType ,
which extracts the information from the Type object and uses it to
build the output text. Finally, you write the output to the console.
AnalyzeType is where the bulk of the work is done:
static void AnalyzeType(Type t)
{
TypeInfo typeInfo = t.GetTypeInfo();
AddToOutput($"Type Name: {t.Name}");
AddToOutput($"Full Name: {t.FullName}");
AddToOutput($"Namespace: {t.Namespace}");
Type tBase = t.BaseType;


if (tBase != null)
{
AddToOutput($"Base Type: {tBase.Name}");
}
AddToOutput("\npublic members:");
foreach (MemberInfo NextMember in t.GetMembers())
{
AddToOutput($"{member.DeclaringType} {member.MemberType}
{member.Name}");
}
}
You implement the AnalyzeType method by calling various properties
of the Type object to get the information you need concerning the type
names and then calling the GetMembers method to get an array of
MemberInfo objects that you can use to display the details for each
member. Note that you use a helper method, AddToOutput , to build the
text to be displayed:
static void AddToOutput(string Text) =>
OutputText.Append("\n" + Text);
The Assembly Class
The Assembly class is defined in the System.Reflection namespace and
provides access to the metadata for a given assembly. It also contains
methods that enable you to load and even execute an assembly—
assuming that the assembly is an executable. As with the Type class,
Assembly contains too many methods and properties to cover here, so
this section is confined to covering those methods and properties that
you need to get started and that you use to complete the
WhatsNewAttributes example.
Before you can do anything with an Assembly instance, you need to
load the corresponding assembly into the running process. You can do
this with either the static members Assembly.Load or
Assembly.LoadFrom . The difference between these methods is that Load
takes the name of the assembly, and the runtime searches in a variety
of locations in an attempt to locate the assembly. These locations
include the local directory and the global assembly cache. LoadFrom
takes the full path name of an assembly and does not attempt to find


the assembly in any other location:
Assembly assembly1 = Assembly.Load("SomeAssembly");
Assembly assembly2 = Assembly.LoadFrom
(@"C:\My Projects\Software\SomeOtherAssembly");
A number of other overloads of both methods exist, which supply
additional security information. After you have loaded an assembly,
you can use various properties on it to find out, for example, its full
name:
string name = assembly1.FullName;
Getting Details About Types Defined in an Assembly
One nice feature of the Assembly class is that it enables you to obtain
details about all the types that are defined in the corresponding
assembly. You simply call the Assembly.GetTypes method, which
returns an array of System.Type references containing details about all
the types. You can then manipulate these Type references as explained
in the previous section:
Type[] types = theAssembly.GetTypes();
foreach(Type definedType in types)
{
DoSomethingWith(definedType);
}
Getting Details About Custom Attributes
The methods you use to find out which custom attributes are defined
on an assembly or type depend on the type of object to which the
attribute is attached. If you want to find out what custom attributes
are attached to an assembly as a whole, you need to call a static
method of the Attribute class, GetCustomAttributes , passing in a
reference to the assembly:
NOTE
This is actually quite significant. You might have wondered why,


when you defined custom attributes, you had to go to all the
trouble of actually writing classes for them, and why Microsoft
didn’t come up with some simpler syntax. Well, the answer is
here. The custom attributes genuinely exist as objects, and when
an assembly is loaded you can read in these attribute objects,
examine their properties, and call their methods.
Attribute[] definedAttributes =
Attribute.GetCustomAttributes(assembly1);
// assembly1 is an Assembly object
GetCustomAttributes ,
which is used to get assembly attributes, has a
few overloads. If you call it without specifying any parameters other
than an assembly reference, it simply returns all the custom attributes
defined for that assembly. You can also call GetCustomAttributes by
specifying a second parameter, which is a Type object that indicates the
attribute class in which you are interested. In this case,
GetCustomAttributes returns an array consisting of all the attributes
present that are of the specified type.
Note that all attributes are retrieved as plain Attribute references. If
you want to call any of the methods or properties you defined for your
custom attributes, you need to cast these references explicitly to the
relevant custom attribute classes. You can obtain details about custom
attributes that are attached to a given data type by calling another
overload of Assembly.GetCustomAttributes , this time passing a Type
reference that describes the type for which you want to retrieve any
attached attributes. To obtain attributes that are attached to methods,
constructors, fields, and so on, however, you need to call a
GetCustomAttributes method that is a member of one of the classes
MethodInfo , ConstructorInfo , FieldInfo , and so on.
If you expect only a single attribute of a given type, you can call the
GetCustomAttribute method instead, which returns a single Attribute
object. You will use GetCustomAttribute in the WhatsNewAttributes
example to find out whether the SupportsWhatsNew attribute is present
in the assembly. To do this, you call GetCustomAttribute , passing in a
reference to the WhatsNewAttributes assembly, and the type of the
Supports-WhatsNewAttribute attribute. If this attribute is present, you


get an Attribute instance. If no instances of it are defined in the
assembly, you get null . If two or more instances are found,
GetCustomAttribute throws a
System.Reflection.AmbiguousMatchException . This is what that call
would look like:
Attribute supportsAttribute =
Attribute.GetCustomAttributes(assembly1,
typeof(SupportsWhatsNewAttribute));
Completing the WhatsNewAttributes Example
You now have enough information to complete the WhatsNewAttributes
example by writing the source code for the final assembly in the
sample, the LookUpWhatsNew assembly. This part of the application is a
console application. However, it needs to reference the other
assemblies of WhatsNewAttributes and VectorClass .
The sample code for the LookupWhatsNew project references the libraries
WhatsNewAttributes and VectorClass and makes uses the following
namespaces:
System
System.Collections.Generic
System.Linq
System.Reflection
System.Text
WhatsNewAttributes
The Program class contains the main program entry point as well as the
other methods. All the methods you define are in this class, which also
has two static fields— outputText , which contains the text as you build
it in preparation for writing it to the message box, and backDateTo ,
which stores the date you have selected. All modifications made since
this date will be displayed. Normally, you would display a dialog
inviting the user to pick this date, but we don’t want to get sidetracked
into that kind of code. For this reason, backDateTo is hard-coded to a


value of 1 Feb 2017. You can easily change this date when you
download the code (code file LookupWhatsNew/Program.cs ):
class Program
{
private static readonly StringBuilder outputText = new
StringBuilder(1000);
private static DateTime backDateTo = new DateTime(2017, 2,
1);
static void Main()
{
Assembly theAssembly = Assembly.Load(new
AssemblyName("VectorClass"));
Attribute supportsAttribute =
theAssembly.GetCustomAttribute(
typeof(SupportsWhatsNewAttribute));
AddToOutput($"Assembly: {theAssembly.FullName}");
if (supportsAttribute == null)
{
AddToOutput("This assembly does not support WhatsNew
attributes");
return;
}
else
{
AddToOutput("Defined Types:");
}
IEnumerable<Type> types = theAssembly.ExportedTypes;
foreach(Type definedType in types)
{
DisplayTypeInfo(definedType);
}
Console.WriteLine($"What\`s New since {backDateTo:D}");
Console.WriteLine(outputText.ToString());
Console.ReadLine();
}
//...
}
The Main method first loads the VectorClass assembly, and then
verifies that it is marked with the SupportsWhatsNew attribute. You
know VectorClass has the SupportsWhatsNew attribute applied to it


because you have only recently compiled it, but this is a check that
would be worth making if users were given a choice of which assembly
they want to check.
Assuming that all is well, you use the Assembly.ExportedTypes property
to get a collection of all the types defined in this assembly, and then
loop through them. For each one, you call a method, DisplayTypeInfo ,
which adds the relevant text, including details regarding any instances
of LastModifiedAttribute , to the outputText field. Finally, you show
the complete text to the console. The DisplayTypeInfo method looks
like this (code file LookupWhatsNew/Program.cs ):
private static void DisplayTypeInfo(Type type)
{
// make sure we only pick out classes
if (!type.GetTypeInfo().IsClass))
{
return;
}
AddToOutput($"{Environment.NewLine}class {type.Name}");
IEnumerable<LastModifiedAttribute> lastModifiedAttributes =
type.GetTypeInfo().GetCustomAttributes()
.OfType<LastModifiedAttribute>()
.Where(a => a.DateModified >= backDateTo).ToArray();
if (attributes.Count() == 0)
{
AddToOutput($"\tNo changes to the class {type.Name}" +
$"{Environment.NewLine}");
}
else
{
foreach (LastFieldModifiedAttribute attribute in
lastModifiedattributes)
{
WriteAttributeInfo(attribute);
}
}
AddToOutput("changes to methods of this class:");
foreach (MethodInfo method in
type.GetTypeInfo().DeclaredMembers.OfType<MethodInfo>())


{
IEnumerable<LastModifiedAttribute> attributesToMethods =
method.GetCustomAttributes().OfType<LastModifiedAttribute>()
.Where(a => a.DateModified >= backDateTo).ToArray();
if (attributesToMethods.Count() > 0)
{
AddToOutput($"{method.ReturnType} {method.Name}()");
foreach (Attribute attribute in attributesToMethods)
{
WriteAttributeInfo(attribute);
}
}
}
}
Notice that the first thing you do in this method is check whether the
Type reference you have been passed actually represents a class.
Because, to keep things simple, you have specified that the
LastModified attribute can be applied only to classes or member
methods, you would be wasting time by doing any processing if the
item is not a class (it could be a class, delegate, or enum).
Next, you use the type.GetTypeInfo().GetCustomAttributes() method
to determine whether this class has any LastModifiedAttribute
instances attached to it. If so, you add their details to the output text,
using a helper method, WriteAttributeInfo .
Finally, you use the DeclaredMembers property of the TypeInfo type to
iterate through all the member methods of this data type, and then do
the same with each method as you did for the class—check whether it
has any LastModifiedAttribute instances attached to it; if so, you
display them using WriteAttributeInfo .
The next bit of code shows the WriteAttributeInfo method, which is
responsible for determining what text to display for a given
LastModifiedAttribute instance. Note that this method is passed an
Attribute reference, so it needs to cast this to a LastModifiedAttribute
reference first. After it has done that, it uses the properties that you
originally defined for this attribute to retrieve its parameters. It
confirms that the date of the attribute is sufficiently recent before
actually adding it to the text for display (code file


LookupWhatsNew/Program.cs ):
private static void WriteAttributeInfo(Attribute attribute)
{
if (attribute is LastModifiedAttribute
lastModifiedAttribute)
{
AddToOutput($"\tmodified:
{lastModifiedAttribute.DateModified:D}: " +
$"{lastModifiedAttribute.Changes}");
if (lastModifiedAttribute.Issues != null)
{
AddToOutput($"\tOutstanding issues:
{lastModifiedAttribute.Issues}");
}
}
}
Finally, here is the helper AddToOutput method:
static void AddToOutput(string text) =>
outputText.Append($"{Environment.NewLine}{text}");
Running this code produces the results shown here:
What`s New since Wednesday, February 1, 2017
Assembly: VectorClass, Version=2.1.0.0, Culture=neutral,
PublicKeyToken=null
Defined Types:
class Vector
modified: Wednesday, July 19, 2017: updated for C# 7
and .NET Core 2
changes to methods of this class:
System.String ToString()
modified: Wednesday, July 19, 2017: changed ijk format
from StringBuilder to format string
Note that when you list the types defined in the VectorClass assembly,
you actually pick up two classes: Vector and the embedded
VectorEnumerator class. In addition, note that because the backDateTo
date of 1 Feb is hard-coded in this example, you actually pick up the
attributes that are dated July 19 but not those dated earlier.


USING DYNAMIC LANGUAGE EXTENSIONS FOR
REFLECTION
Until now you’ve used reflection for reading metadata. You can also
use reflection to create instances dynamically from types that aren’t
known at compile time. The next sample shows creating an instance of
the Calculator class without the compiler knowing of this type at
compile time. The assembly CalculatorLib is loaded dynamically
without adding a reference. During runtime, the Calculator object is
instantiated, and a method is called. After you know how to use the
Reflection API, you’ll do the same using the C# dynamic keyword. This
keyword has been part of the C# language since version 4.
Creating the Calculator Library
The library that is loaded is a simple Class Library (.NET Standard)
containing the type Calculator with implementations of the Add and
Subtract methods. As the methods are really simple, they are
implemented using the expression syntax (code file
CalculatorLib/Calculator.cs ):
public class Calculator
{
public double Add(double x, double y) => x + y;
public double Subtract(double x, double y) => x - y;
}
After you compile the library, copy the generated DLL to the folder
c:/addins .
Instantiating a Type Dynamically
For using reflection to create the Calculator instance dynamically, you
create a Console App (.NET Core) with the name ClientApp .
The constant CalculatorTypeName defines the name of the Calculator
type, including the namespace. The Main method requires a command-
line argument with the path to the library and then invokes the
methods UsingReflection and UsingReflectionWithDynamic , two
variants doing reflection (code file


DynamicSamples/ClientApp/Program.cs ):
class Program
{
private const string CalculatorTypeName =
"CalculatorLib.Calculator";
static void Main(string[] args)
{
if (args.Length != 1)
{
ShowUsage();
return;
}
UsingReflection(args[0]);
UsingReflectionWithDynamic(args[0]);
}
private static void ShowUsage()
{
Console.WriteLine($"Usage: {nameof(ClientApp)} path");
Console.WriteLine();
Console.WriteLine("Copy CalculatorLib.dll to an addin
directory");
Console.WriteLine("and pass the absolute path of this
directory " +
"when starting the application to load the library");
}
Before using reflection to invoke a method, you need to instantiate the
Calculator type. The method GetCalculator loads the assembly
dynamically using the method LoadFile of the Assembly class and
creates an instance of the Calculator type with the CreateInstance
method:
private static object GetCalculator()
{
Assembly assembly = Assembly.LoadFile(CalculatorLibPath);
return assembly.CreateInstance(CalculatorTypeName);
}
The sample code for the ClientApp makes use of the following
dependency and .NET namespaces:
Dependency


System.Runtime.Loader
.NET Namespaces
Microsoft.CSharp.RuntimeBinder
System
System.Reflection
Invoking a Member with the Reflection API
Next, the Reflection API is used to invoke the method Add of the
Calculator instance. First, the calculator instance is retrieved with the
helper method GetCalculator . If you would like to add a reference to
the CalculatorLib , you could use new Calculator to create an instance.
But here it’s not that easy.
Invoking the method using reflection has the advantage that the type
does not need to be available at compile time. You could add it at a
later time just by copying the library in the specified directory. To
invoke the member using reflection, the Type object of the instance is
retrieved using GetType —a method of the base class Object . With the
help of the extension method GetMethod , a MethodInfo object for the
method Add is accessed. The MethodInfo defines the Invoke method to
call the method using any number of parameters. The first parameter
of the Invoke method needs the instance of the type where the member
is invoked. The second parameter is of type object[] to pass all the
parameters needed by the invocation. You’re passing the values of the
x and y variables here (code file
DynamicSamples/ClientApp/Program.cs ):
private static void UsingReflection()
{
double x = 3;
double y = 4;
object calc = GetCalculator();
object result = calc.GetType().GetMethod("Add")
.Invoke(calc, new object[] { x, y });
Console.WriteLine($"the result of {x} and {y} is
{result}");
}


When you run the program, the calculator is invoked, and this result is
written to the console:
The result of 3 and 4 is 7
This is quite some work to do for calling a member dynamically. The
next section looks at how easy it is to use the dynamic keyword.
Invoking a Member with the Dynamic Type
Using reflection with the dynamic keyword, the object that is returned
from the GetCalculator method is assigned to a variable of a dynamic
type. The GetCalculator method itself is not changed; it still returns an
object. The result is returned to a variable that is of type dynamic . With
this, the Add method is invoked, and two double values are passed to it
(code file DynamicSamples/ClientApp/Program.cs ):
private static void ReflectionNew()
{
double x = 3;
double y = 4;
dynamic calc = GetCalculator();
double result = calc.Add(x, y);
Console.WriteLine($"the result of {x} and {y} is
{result}");
}
The syntax is really simple; it looks like calling a method with strongly
typed access. However, there’s no IntelliSense within Visual Studio
because you can immediately see coding this from the Visual Studio
editor, so it’s easy to make typos.
There’s also no compile-time check. The compiler runs fine when you
invoke the Multiply method. Just remember you only defined Add and
Subtract methods with the calculator.
try
{
result = calc.Multiply(x, y);
}
catch (RuntimeBinderException ex)
{
Console.WriteLine(ex);


}
When you run the application and invoke the Multiply method, you
get a RuntimeBinderException :
Microsoft.CSharp.RuntimeBinder.RuntimeBinderException:
'CalculatorLib.Calculator'
does not contain a definition for 'Multiply'
at CallSite.Target(Closure , CallSite , Object , Double ,
Double )
at
System.Dynamic.UpdateDelegates.UpdateAndExecute3[T0,T1,T2,TRet]
(CallSite
site, T0 arg0, T1 arg1, T2 arg2)
at ClientApp.Program.UsingReflectionWithDynamic(String
addinPath) in...
Using the dynamic type also has more overhead compared to accessing
objects in a strongly typed manner. Therefore, the keyword is useful
only in some specific scenarios such as reflection. You don’t have a
compiler check invoking the InvokeMember method of the Type ; instead,
a string is passed for the name of the member. Using the dynamic type,
which has a simpler syntax, has a big advantage compared to using the
Reflection API in such scenarios.
The dynamic type can also be used with COM integration and scripting
environments as shown after discussing the dynamic keyword more in
detail.
THE DYNAMIC TYPE
The dynamic type enables you to write code that bypasses compile-time
type checking. The compiler assumes that the operation defined for an
object of type dynamic is valid. If that operation isn’t valid, the error
isn’t detected until runtime. This is shown in the following example:
class Program
{
static void Main()
{
var staticPerson = new Person();
dynamic dynamicPerson = new Person();
staticPerson.GetFullName("John", "Smith");


dynamicPerson.GetFullName("John", "Smith");
}
}
class Person
{
public string FirstName { get; set; }
public string LastName { get; set; }
public string GetFullName() => $"{FirstName} {LastName}";
}
This example does not compile because of the call to
staticPerson . GetFullName() . There isn't a method on the Person object
that takes two parameters, so the compiler raises the error. If that line
of code were commented out, the example would compile. If executed,
a runtime error would occur. The exception that is raised is
RuntimeBinderException . The RuntimeBinder is the object in the
runtime that evaluates the call to determine whether Person really
does support the method that was called. Binding is discussed later in
the chapter.
Unlike the var keyword, an object that is defined as dynamic can
change type during runtime. Remember that when the var keyword is
used, the determination of the object’s type is delayed. After the type is
defined, it can’t be changed. Not only can you change the type of a
dynamic object, you can change it many times. This differs from
casting an object from one type to another. When you cast an object,
you are creating a new object with a different but compatible type. For
example, you cannot cast an int to a Person object. In the following
example, you can see that if the object is a dynamic object, you can
change it from int to Person :
dynamic dyn;
dyn = 100;
Console.WriteLine(dyn.GetType());
Console.WriteLine(dyn);
dyn = "This is a string";
Console.WriteLine(dyn.GetType());
Console.WriteLine(dyn);
dyn = new Person() { FirstName = "Bugs", LastName = "Bunny"
};
Console.WriteLine(dyn.GetType());
Console.WriteLine($"{dyn.FirstName} {dyn.LastName}");


The result of executing this code would be that the dyn object actually
changes type from System.Int32 to System.String to Person . If dyn had
been declared as an int or string , the code would not have compiled.
NOTE
There are a couple of limitations to the dynamic type. A dynamic
object does not support extension methods. Nor can anonymous
functions (lambda expressions) be used as parameters to a
dynamic method call, so LINQ does not work well with dynamic
objects. Most LINQ calls are extension methods, and lambda
expressions are used as arguments to those extension methods.
Dynamic Behind the Scenes
So what’s going on behind the scenes to make the dynamic
functionality available with C#? C# is a statically typed language. That
hasn’t changed. Take a look at the IL (Intermediate Language) that’s
generated when the dynamic type is used.
First, this is the example C# code that you’re looking at (code file
DynamicSamples/DecompileSample/Program.cs ):
class Program
{
static void Main()
{
StaticClass staticObject = new StaticClass();
DynamicClass dynamicObject = new DynamicClass();
Console.WriteLine(staticObject.IntValue);
Console.WriteLine(dynamicObject.DynValue);
Console.ReadLine();
}
}
class StaticClass
{
public int IntValue = 100;
}


class DynamicClass
{
public dynamic DynValue = 100;
}
Besides the Program class, you have two classes: StaticClass and
DynamicClass . StaticClass has a single field that returns an int .
DynamicClass has a single field that returns a dynamic object. The Main
method creates these objects and prints out the value that the methods
return. Simple enough.
Now comment out the references to the DynamicClass in Main like this:
static void Main()
{
StaticClass staticObject = new StaticClass();
//DynamicClass dynamicObject = new DynamicClass();
Console.WriteLine(staticObject.IntValue);
//Console.WriteLine(dynamicObject.DynValue);
Console.ReadLine();
}
Using the ildasm tool, you can look at the IL that is generated for the
Main method:
.method private hidebysig static void Main() cil managed
{
.entrypoint
// Code size
22 (0x16)
.maxstack 8
IL_0000: newobj
instance void
DecompileSample.StaticClass::.ctor()
IL_0005: ldfld
int32
DecompileSample.StaticClass::IntValue
IL_000a: call
void
[System.Console]System.Console::WriteLine(int32)
IL_000f: call
string
[System.Console]System.Console::ReadLine()
IL_0014: pop
IL_0015: ret
} // end of method Program::Main
Without getting into the details of IL, you can still pretty much tell
what’s going on just by looking at this section of code. Line 0000, the
StaticClass constructor, is called. Line 0005 calls the IntValue field of


StaticClass . The
next line writes out the value.
Now comment out the StaticClass references and uncomment the
DynamicClass references:
static void Main()
{
//StaticClass staticObject = new StaticClass();
DynamicClass dynamicObject = new DynamicClass();
//Console.WriteLine(staticObject.IntValue);
Console.WriteLine(dynamicObject.DynValue);
Console.ReadLine();
}
Compile the application again, and the following is generated:
.method private hidebysig static void Main() cil managed
{
.entrypoint
// Code size
119 (0x77)
.maxstack 9
.locals init (class DecompileSample.DynamicClass V_0)
IL_0000: newobj
instance void
DecompileSample.DynamicClass::.ctor()
IL_0005: stloc.0
IL_0006: ldsfld
class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite`1<clas
[System.Runtime]System.Action`3<class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite,class
[System.Runtime]System.Type,object>>
DecompileSample.Program/'<>o__0'::'<>p__0'
IL_000b: brtrue.s
IL_004c
IL_000d: ldc.i4
0x100
IL_0012: ldstr
„WriteLine"
IL_0017: ldnull
IL_0018: ldtoken
DecompileSample.Program
IL_001d: call
class [System.Runtime]System.Type
[System.Runtime]System.Type::GetTypeFromHandle(valuetype
[System.Runtime]System.RuntimeTypeHandle)
IL_0022: ldc.i4.2
IL_0023: newarr
[Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo
IL_0028:
IL_0029:
IL_002a:
IL_002c:
dup
ldc.i4.0
ldc.i4.s
ldnull




IL_002d: call
class
[Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo
[Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Cre
[
Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags,
string)
IL_0032: stelem.ref
IL_0033: dup
IL_0034: ldc.i4.1
IL_0035: ldc.i4.0
IL_0036: ldnull
IL_0037: call
class
[Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo
[Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Cre
[
Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags,
string)
IL_003c: stelem.ref
IL_003d: call
class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSiteBinder
[Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.Binder::InvokeMember(va
[
Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags,
string,
class
[System.Runtime]System.Collections.Generic.IEnumerable`1<class
[System.Runtime]System.Type>,
class [System.Runtime]System.Type,
class
[System.Runtime]System.Collections.Generic.IEnumerable`1<class
[
Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo>)
IL_0042: call
class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite`1<!0>
class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite`1<clas
[System.Runtime]System.Action`3<class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite,class
[System.Runtime]System.Type,object>>::Create(class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSiteBinder)


IL_0047: stsfld
class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite`1<clas
[System.Runtime]System.Action`3<class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite,class
[System.Runtime]System.Type,object>>
DecompileSample.Program/'<>o__0'::'<>p__0'
IL_004c: ldsfld
class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite`1<clas
[System.Runtime]System.Action`3<class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite,class
[System.Runtime]System.Type,object>>
DecompileSample.Program/'<>o__0'::'<>p__0'
IL_0051: ldfld
!0 class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite`1<clas
[System.Runtime]System.Action`3<class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite,class
[System.Runtime]System.Type,object>>::Target
IL_0056: ldsfld
class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite`1<clas
[System.Runtime]System.Action`3<class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite,class
[System.Runtime]System.Type,object>>
DecompileSample.Program/'<>o__0'::'<>p__0'
IL_005b: ldtoken
[System.Console]System.Console
IL_0060: call
class [System.Runtime]System.Type
[System.Runtime]System.Type::GetTypeFromHandle(valuetype
[System.Runtime]System.RuntimeTypeHandle)
IL_0065: ldloc.0
IL_0066: ldfld
object
DecompileSample.DynamicClass::DynValue
IL_006b: callvirt
instance void class
[System.Runtime]System.Action`3<class
[System.Linq.Expressions]System.Runtime.CompilerServices.CallSite,class
[System.Runtime]System.Type,object>::Invoke(!0,
!1,
!2)
IL_0070: call
string
[System.Console]System.Console::ReadLine()
IL_0075: pop
IL_0076: ret
} // end of method Program::Main
It’s safe to say that the C# compiler is doing a little extra work to
support the dynamic type. Looking at the generated code, you can see
references to System.Runtime.CompilerServices.CallSite and
System.Runtime.CompilerServices.CallSiteBinder .


The CallSite is a type that handles the lookup at runtime. When a call
is made on a dynamic object at runtime, something has to check that
object to determine whether the member really exists. The call site
caches this information, so the lookup doesn’t have to be performed
repeatedly. Without this process, performance in looping structures
would be questionable.
After the CallSite does the member lookup, the CallSiteBinder is
invoked. It takes the information from the call site and generates an
expression tree representing the operation to which the binder is
bound.
There is obviously a lot going on here. Great care has been taken to
optimize what would appear to be a very complex operation. Clearly,
using the dynamic type can be useful, but it does come with a price.
DYNAMICOBJECT AND EXPANDOOBJECT
What if you want to create your own dynamic object? You have a
couple of options for doing that: by deriving from DynamicObject or by
using ExpandoObject . Using DynamicObject is a little more work than
using ExpandoObject because with DynamicObject you have to override
a couple of methods. ExpandoObject is a sealed class that is ready to
use.
DynamicObject
Consider an object that represents a person. Normally, you would
define properties for the first name, middle name, and last name. Now
imagine the capability to build that object during runtime, with the
system having no prior knowledge of what properties the object might
have or what methods the object might support. That’s what having a
DynamicObject -based object can provide. There might be very few
times when you need this sort of functionality, but until now the C#
language had no way of accommodating such a requirement (code file
DynamicSamples/DynamicSample/WroxDynamicObject.cs ):
public class WroxDynamicObject : DynamicObject
{


private Dictionary<string, object> _dynamicData =
new Dictionary<string, object>();
public override bool TryGetMember(GetMemberBinder binder,
out object result)
{
bool success = false;
result = null;
if (_dynamicData.ContainsKey(binder.Name))
{
result = _dynamicData[binder.Name];
success = true;
}
else
{
result = "Property Not Found!";
}
return success;
}
public override bool TrySetMember(SetMemberBinder binder,
object value)
{
_dynamicData[binder.Name] = value;
return true;
}
public override bool TryInvokeMember(InvokeMemberBinder
binder,
object[] args, out object result)
{
dynamic method = _dynamicData[binder.Name];
result = method((DateTime)args[0]);
return result != null;
}
}
First look at what the DynamicObject looks like (code file
DynamicSamples/DynamicSample/WroxDyamicObject.cs ):
In this example, you’re overriding three methods: TrySetMember ,
TryGetMember , and TryInvokeMember .
adds the new method, property, or field to the object. In
this case, you store the member information in a Dictionary object.
The SetMemberBinder object that is passed into the TrySetMember
TrySetMember


method contains the Name property, which is used to identify the
element in the Dictionary .
The TryGetMember retrieves the object stored in the Dictionary based
on the GetMemberBinder Name property.
Here is the code that makes use of the new dynamic object just created
(code file DynamicSamples/DynamicSample/Program.cs ):
dynamic wroxDyn = new WroxDynamicObject();
wroxDyn.FirstName = "Bugs";
wroxDyn.LastName = "Bunny";
Console.WriteLine(wroxDyn.GetType());
Console.WriteLine($"{wroxDyn.FirstName} {wroxDyn.LastName}");
It looks simple enough, but where is the call to the methods you
overrode? That’s where .NET helps. DynamicObject handles the binding
for you; all you have to do is reference the properties FirstName and
LastName as if they were there all the time.
You can also easily add a method. You can use the same
WroxDynamicObject and add a GetTomorrowDate method to it. It takes a
DateTime object and returns a date string representing the next day.
Here’s the code:
dynamic wroxDyn = new WroxDynamicObject();
Func<DateTime, string> GetTomorrow = today =>
today.AddDays(1).ToShortDateString();
wroxDyn.GetTomorrowDate = GetTomorrow;
Console.WriteLine($"Tomorrow is
{wroxDyn.GetTomorrowDate(DateTime.Now)}");
You create the delegate GetTomorrow using Func<T, TResult> . The
method the delegate represents is the call to AddDays . One day is added
to the Date that is passed in, and a string of that date is returned. The
delegate is then set to GetTomorrowDate on the wroxDyn object. The last
line calls the new method, passing in the current day’s date. Hence the
dynamic magic and you have an object with a valid method.
ExpandoObject
works similarly to the WroxDynamicObject created in the
previous section. The difference is that you don’t have to override any
ExpandoObject


methods, as shown in the following code example (code file
DynamicSamples/DynamicSample/WroxDynamicObject.cs ):
static void DoExpando()
{
dynamic expObj = new ExpandoObject();
expObj.FirstName = "Daffy";
expObj.LastName = "Duck";
Console.WriteLine($"{expObj.FirstName} {expObj.LastName}");
Func<DateTime, string> GetTomorrow = today =>
today.AddDays(1).ToShortDateString();
expObj.GetTomorrowDate = GetTomorrow;
Console.WriteLine($"Tomorrow is
{expObj.GetTomorrowDate(DateTime.Now)}");
expObj.Friends = new List<Person>();
expObj.Friends.Add(new Person() { FirstName = "Bob",
LastName = "Jones" });
expObj.Friends.Add(new Person() { FirstName = "Robert",
LastName = "Jones" });
expObj.Friends.Add(new Person() { FirstName = "Bobby",
LastName = "Jones" });
foreach (Person friend in expObj.Friends)
{
Console.WriteLine($"{friend.FirstName}
{friend.LastName}");
}
}
Notice that this code is almost identical to what you did earlier. You
add a FirstName and LastName property, add a GetTomorrow function,
and then do one additional thing: add a collection of Person objects as
a property of the object.
At first glance it might seem that this is no different from using the
dynamic type, but there are a couple of subtle differences that are
important. First, you can’t just create an empty dynamic typed object.
The dynamic type must have something assigned to it. For example, the
following code won’t work:
dynamic dynObj;
dynObj.FirstName = "Joe";
As shown in the previous example, this is possible with ExpandoObject .


Second, because the dynamic type has to have something assigned to it,
it reports back the type assigned to it if you do a GetType call. For
example, if you assign an int , it reports back that it is an int . This
doesn’t happen with ExpandoObject or an object derived from
DynamicObject .
If you have to control the addition and access of properties in your
dynamic object, then deriving from DynamicObject is your best option.
With DynamicObject , you can use several methods to override and
control exactly how the object interacts with the runtime. For other
cases, using the dynamic type or the ExpandoObject might be
appropriate.
Following is another example of using dynamic and ExpandoObject .
Assume that the requirement is to develop a general-purpose comma-
separated values (CSV) file parsing tool. You won’t know from one
execution to another what data will be in the file, only that the values
will be comma-separated and that the first line will contain the field
names.
First, open the file and read in the stream. You can use a simple helper
method to do this (code file
DynamicSamples/DynamicFileReader/DynamicFileHelper.cs ):
public class DynamicFileHelper
{
//...
private StreamReader OpenFile(string fileName)
{
if(File.Exists(fileName))
{
return new StreamReader(fileName);
}
return null;
}
//...
}
This just opens the file and creates a new StreamReader to read the file
contents.
Now you want to get the field names, which you can do easily by
reading in the first line from the file and using the Split function to


create a string array of field names:
string[] headerLine =
fileStream.ReadLine().Split(',').Trim().ToArray();
Next is the interesting part. You read in the next line from the file,
create a string array just like you did with the field names, and start
creating your dynamic objects. Here’s what the code looks like (code
file DynamicSamples/DynamicFileReader/DynamicFileHelper.cs ):
public class DynamicFileHelper
{
//...
public IEnumerable<dynamic> ParseFile(string fileName)
{
var retList = new List<dynamic>();
while (fileStream.Peek() > 0)
{
string[] dataLine =
fileStream.ReadLine().Split(',').Trim().ToArray();
dynamic dynamicEntity = new ExpandoObject();
for(int i=0;i<headerLine.Length;i++)
{
((IDictionary<string,object>)dynamicEntity).Add(headerLine[i],
dataLine[i]);
}
retList.Add(dynamicEntity);
}
return retList;
}
//...
}
After you have the string array of field names and data elements, you
create a new ExpandoObject and add the data to it. Notice that you cast
the ExpandoObject to a Dictionary object. You use the field name as the
key and the data as the value. Then you can add the new object to the
retList object you created and return it to the code that called the
method.
What makes this nice is you have a section of code that can handle any
data you give it. The only requirements in this case are ensuring that
the field names are the first line and that everything is comma-


separated. This concept could be expanded to other file types or even
to a DataReader .
Using this CSV file content that is available with the sample code
download
FirstName, LastName, City, State
Niki, Lauda, Vienna, Austria
Carlos, Reutemann, Santa Fe, Argentine
Sebastian, Vettel, Thurgovia, Switzerland
and this Main method to read the sample file EmployeeList.txt (code
file DynamicSamples/DynamicFileReader/Program.cs ):
static void Main()
{
var helper = new DynamicFileHelper();
var employeeList = helper.ParseFile("EmployeeList.txt");
foreach (var employee in employeeList)
{
Console.WriteLine($"{employee.FirstName}
{employee.LastName} lives in " +
$"{employee.City}, {employee.State}.");
}
Console.ReadLine();
}
results in this output to the console:
Niki Lauda lives in Vienna, Austria.
Carlos Reutemann lives in Santa Fe, Argentine.
Sebastian Vettel lives in Thurgovia, Switzerland.
SUMMARY
This chapter illustrated using the Type and Assembly classes, which are
the primary entry points through which you can access the extensive
capabilities provided by reflection.
In addition, this chapter demonstrated a specific aspect of reflection
that you are likely to use more often than any other—the inspection of
custom attributes. You learned how to define and apply your own
custom attributes, and how to retrieve information about custom
attributes at runtime.


The second focus of this chapter was working with the dynamic type.
Using ExpandoObject in place of multiple objects can reduce the
number of lines of code significantly. Also using the DLR and adding
scripting languages like Python or Ruby can help you build a more
polymorphic application that can be changed easily without
recompiling.
The next chapter gives details on freeing resources with the
IDisposable interface, releasing native resources, and working with
unsafe C# code.