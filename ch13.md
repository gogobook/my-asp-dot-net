

Functional Programming with C#
WHAT’S IN THIS CHAPTER?
Functional programming overview
Expression-bodied members
Extension methods
The using static declaration
Local functions
Tuples
Pattern matching
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
You can find the Wrox.com code downloads for this chapter at
www.wrox.com . The source code is also available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7
the directory FunctionalProgramming .
The code for this chapter is divided into the following major
examples:
ExpressionBodiedMembers
LocalFunctions
Tuples


in
PatternMatching
WHAT IS FUNCTIONAL PROGRAMMING?
C# never has been a pure object-oriented programming language.
From the beginning, C# has been a component-oriented programming
language. What does component-oriented mean? C# offers inheritance
and polymorphism that’s also used by object-oriented programming
languages; in addition, it offers native support for properties, events,
and annotations via attributes. Later versions with LINQ and
expressions have also included declarative programming. Using
declarative LINQ expressions, the compiler saves an expression tree
that is used later by a provider to dynamically generate SQL
statements.
NOTE
Object-oriented features of C# are discussed in Chapter 4, “Object-
Oriented Programming with C#,” events are covered in Chapter
8, “Delegates, Lambdas, and Events,” and LINQ is covered in
Chapter 12, “Language Integrated Query.”
C# is not purely bound to a single programming language paradigm.
Instead, features that are practical with today’s applications created
with C# are added to the syntax of C#. In the last years more and more
features associated with functional programming have been added as
well.
What are the foundations of functional programming? The most
important concepts of functional programming are based on two
approaches: avoiding state mutation and having functions as a first-
class concept. The next two sections get more into details on these two
things.


NOTE
This chapter does not claim to give you all the information to
write applications with the pure functional programming
paradigm. Complete books are needed for this. (If you want to
write programs with this paradigm, you should consider
switching to the F# programming language instead of using C#.)
This chapter goes a pragmatic way—like C# does. Some features
used with functional programming are useful with all application
types; that’s why these features are offered in C#. Over time,
more and more functional programming features will be added to
C# in a way that fits the C# programming style.
Avoiding State Mutation
With the programming language F#, which is a functional-first
language, creating a custom type, an object of this type is by default
immutable. An object can be initialized in a constructor, but it can’t be
changed later. If mutability is needed, the type needs to be explicitly
declared to be mutable. This is different with C#.
With C#, some of the predefined types are immutable such as the
string type. Methods that are used to change the string always return
a new string. What about collections? The methods used by LINQ
don’t change a collection. Instead, methods such as Where and OrderBy
return a new collection that is filtered and a new collection that is
ordered.
On the other hand, the List<T> collection offers methods for sorting
that are implemented in a mutable way; the original collection is
sorted. For more immutability, .NET offers complete immutable
collections in the namespace System.Collections.Immutable . These
collections don’t offer methods that change the collection. Instead,
new collections are always returned.
What’s the advantage of using immutable types? Because it’s


guaranteed no one can change an instance, multiple threads can be
used to access it concurrently without the need for synchronization.
With immutable types, it’s also easier to create unit tests.
For creating custom types, some features were added with C# 6 to
create immutable types. Since C# 6, you have been able to create an
auto implemented read-only property with just a get accessor:
public string FirstName { get; }
Out of this, the compiler creates a read-only field that can be
initialized only in the constructor and a property with a get accessor
returning this field.
NOTE
Strings are covered in Chapter 9, “Strings and Regular
Expressions.” Immutable collections are covered in Chapter 11,
“Special Collections.”
Because of some library requirements, where you can use immutable
types is somewhat limited. Over the last years, the limitations have
been removed in more and more places. For example, the NuGet
package Newtonsoft.Json allows using immutable types for JSON
serialization and deserialization. This library makes use of a
constructor that matches arguments needed to create an instance.
Entity Framework was such a limitation in the last years. However,
since Entity Framework Core 1.1, table columns can be mapped to
fields instead of to read/write properties.
NOTE
JSON serialization is covered in Bonus Chapter 2, “XML and
JSON,” which you can find online. Entity Framework Core is
covered in Chapter 26, “Entity Framework Core.” Threads and


synchronization are covered in Chapter 21, “Tasks and Parallel
Programming.”
NOTE
This chapter does not cover the C# features to create immutable
types because this is already covered in Chapter 3, “Objects and
Types.” C# allows creating auto-implemented properties just with
a get accessor where the compiler creates a readonly field and a
get accessor returning the value of this field. Future versions of
C# are planned to have more features to create immutable types,
such as records.
Functions as First Class
With functional programming, functions are first class. This means
that functions can be used as arguments of functions, functions can be
returned from functions, and functions can be assigned to variables.
This always has been possible with C#: Delegates can hold addresses
of functions, delegates can be used as arguments of methods, and
delegates can be returned from methods. However, you need to be
aware that comparing the invocation of a normal function to the
invocation of a delegate, the delegate has some overhead associated.
With a delegate, an instance of a delegate class is created, and this
instance holds a collection of method references. When you invoke a
delegate, the collection is iterated to invoke every method assigned to
the delegate.
NOTE
Delegates are covered in Chapter 8.


Higher-Order Functions
Functional programming defines the term higher-order function as a
function that takes another function as parameter or that returns a
function. Some do both. With a C# implementation, delegates are used
as parameters and return types of a method.
Examples of higher-order functions are methods defined for LINQ as
you’ve seen in the previous chapter. For example, the Where method
receives a Func<TSource, bool> predicate:
public static IEnumerable<TSource> Where(this
IEnumerable<TSource> source,
Func<TSource, bool> predicate);
How a higher-order function can both receive a function as a
parameter as well as return a function is shown later in this chapter.
Pure Functions
Functional programming defines the term pure function. Pure
functions should be preferred if possible. Pure functions fulfill two
requirements:
Pure functions always return the same result for the same
arguments that are passed.
Pure functions don’t result in a side effect, such as changing state,
or depend on external sources.
Of course, not all methods can be implemented as a pure function.
Pure functions just have the advantage that testing becomes easy;
there’s no external dependency.
When creating a method to access external sources, you might think
about splitting the method into two parts: a part that is pure with
probably complex logic and a part that cannot be pure.
Now that you’ve had an overview of the important concepts of
functional programming, it’s time to get into C# syntax details on how
C# helps these concepts.
EXPRESSION-BODIED MEMBERS


C# 6 allowed expression-bodied members with methods and
properties that only defined a get accessor. Now, with C# 7,
expression-bodied members can be used everywhere as long as only
one statement is used with the implementation. With functional
programming, many methods are only one-liners, and thus this
feature can be used often; the number of code lines is reduced because
as curly brackets are not needed.
NOTE
This feature is already introduced in other chapters of this book,
such as expression-bodied properties and expression-bodied
methods in Chapter 3 and expression-bodied event accessors in
Chapter 8, so not every aspect of them is covered in this chapter.
Let’s look at the following code snippet in which expression-bodied
members are used with property accessors—the get and set accessors
—with the implementation of the ToString method, and the
implementation of the constructor. The constructor is defined to
accept the name as a string parameter and requires this to split the
string into first name and last name. This is done with one statement
where first the string is split up into a string array, and next this string
array is used to extract two strings, named _firstName and _lastName ,
using out parameters (code file ExpressionBodiedMembers/Person.cs ):
public class Person
{
public Person(string name) =>
name.Split(' ').ToStrings(out _firstName, out _lastName);
private string _firstName;
public string FirstName
{
get => _firstName;
set => _firstName = value;
}
private string _lastName;
public string LastName


{
get => _lastName;
set => _lastName = value;
}
public override string ToString() => $"{FirstName}
{LastName}";
}
The custom out parameters are filled with the extension method
ToStrings from the following code snippet. This is an extension
method for the string array, and it moves the elements of the array to
the output parameters (code file
ExpressionBodiedMembers/StringArrayExtensions.cs ):
public static class StringArrayExtensions
{
public static void ToStrings(this string[] values, out
string value1,
out string value2)
{
if (values == null) throw new
ArgumentNullException(nameof(values));
if (values.Length != 2) throw new
IndexOutOfRangeException(
"only arrays with 2 values allowed");
value1 = values[0];
value2 = values[1];
}
}
With all this in place, a Person can be created with the name consisting
of one string, and the FirstName and LastName properties accessed to
read the name (code file ExpressionBodiedMembers/Program.cs ):
Person p = new Person("Katharina Nagel");
Console.WriteLine($"{p.FirstName} {p.LastName}");
EXTENSION METHODS
Extension methods already have been covered in Chapter 12, and the
previous section of this chapter implements a custom extension
method. However, as extension methods help a lot with functional


programming concepts, so I’m showing another example here.
With functional programming, many methods are very short and
consist of a single statement, whereas expression-bodied members like
those shown earlier help reduce the number of code lines. For
example, the using statement can be changed to a method instead. The
following extension method named Use is an extension method for all
classes implementing the IDiposable interface. The using statement is
used within the implementation to release the item after its use. For
the user of the item, an Action<T> delegate can be passed to the Use
method (code file UsingStatic/FunctionalExtensions.cs :
public static class FunctionalExtensions
{
public static void Use<T>(this T item, Action<T> action)
where T : IDisposable
{
using (item)
{
action(item);
}
}
}
A sample class that implements the interface IDisposable is defined
with the Resource class. This class offers the Foo method in addition to
the IDiposable functionality (code file UsingStatic/Resource.cs ):
class Resource : IDisposable
{
public void Foo() => Console.WriteLine("Foo");
private bool disposedValue = false;
protected virtual void Dispose(bool disposing)
{
if (!disposedValue)
{
if (disposing)
{
Console.WriteLine("release resource");
}
disposedValue = true;
}
}


public void Dispose() => Dispose(true);
}
Now think about how a typical using statement block for accessing this
Resource object would look:
using (var r = new Resource())
{
r.Foo();
}
With the Use method, accessing and disposing of the resource can be
done in a single statement (code file UsingStatic/Program.cs ):
new Resource().Use(r => r.Foo());
USING STATIC
Many practical extensions can be implemented with extension
methods, such as you’ve seen with the Use extension method or the
many extension methods for LINQ that are covered in Chapter 12.
You’ll also see many extension methods offered by .NET in many of
the following chapters of the book.
Not all practical extensions have a type that can be extended. For some
scenarios simple static methods can be advantageous. For easier
invocation of these methods, the using static declaration can be used
to get rid of the class name.
For example, instead of writing
Console.WriteLine("Hello World!");
you can write
WriteLine("Hello World!");
if System.Console is opened:
using static System.Console;
After using this declaration, you can use all static members of the class
Console —such as WriteLine , Write , ReadLine , Read , Beep , and others—


without writing the Console class. You just need to make sure to not
get into conflicts when opening static members of other classes, or
using methods of a base class when static methods were meant.
Let’s get into a practical example. High-order functions take functions
as parameters, return a function, or do both. When working with
functions, it can be useful to combine two functions to one. You do this
with the Compose method, as shown in the following code snippet (code
file UsingStatic/FunctionalExtensions.cs ):
public static class FunctionalExtensions
{
//...
public static Func<T1, TResult> Compose<T1, T2, TResult>(
Func<T1, T2> f1, Func<T2, TResult> f2) =>
a => f2(f1(a));
}
This generic method defines three type parameters and two
parameters of the delegate type Func . Just remember, the delegate
Func<T, TResult> references a method with one argument and a return
type that can be of a different type. The Compose method accepts two
Func parameters to pass two methods that are combined to one. The
first method ( f1 ) passed to Compose can have two different types—one
for input ( T1 ) and one for output ( T2 )—whereas the second method
( f2 ) passed needs the same input type ( T2 ) as the output type ( T2 ) of
the first method and can have a different output type ( TResult ). The
Compose method itself returns a Func delegate with the same input type
( T1 ) as the first method, and the same output type as the second
method ( TResult ). The implementation might look a little scary
because two lambda operators follow one after the other. This
construct will become clear as you understand what the method
returns: a method. The method that is returned is of type Func<T1,
TResult> . After the first lambda operator, a => f2(f1(a)); defines this
method. The variable a is of type T1 , and the return of the method is of
type TResult , which is the same result type as returned from f2 . f2
receives f1 with the input as parameter.
To use the Compose method, first two delegates f1 and f2 are created
that add 1 or 2 to the input. These delegates are combined with the


method. The Compose method can be invoked without a class
name because the using static declaration opens the static members
of the class FunctionalExtensions . After creating f3 with the Compose
method, the f3 method is invoked (code file UsingStatic/Program.cs ):
Compose
using System;
using static System.Console;
using static UsingStatic.FunctionalExtensions;
namespace UsingStatic
{
class Program
{
static void Main()
{
//...
Func<int, int> f1 = x => x + 1;
Func<int, int> f2 = x => x + 2;
Func<int, int> f3 = Compose(f1, f2);
var x1 = f3(39);
WriteLine(x1);
//...
}
}
}
The result written to the console is, of course, 42.
As the Compose method is declared, the parameter types can be
different between the input and the output. In the following code
snippet, the first method passed to the Compose method receives a
string and returns a Person object; the second method receives a
Person and returns a string . If the compiler can’t identify the
parameter type from the variable and the return type, the concrete
delegate type must be specified as shown with the method that
receives a string and returns a Person . The variable name alone
doesn’t help the compiler to know its type. With the second method
passed to the Compose method it’s already clear that the input is of the
same type as the return from the first method, so a type specification is
not necessary. After the invocation of the Compose method, the variable
greetPerson is a combination of the two input methods:


var greetPerson = Compose(
new Func<string, Person>(name => new Person(name)),
person => $"Hello, {person.FirstName}");
WriteLine(greetPerson("Mario Andretti"));
Invoking the greetPerson method with the string Mario Andretti in the
WriteLine method, writes the string Hello, Mario to the console.
LOCAL FUNCTIONS
A new feature of C# 7 is local functions: Methods can be declared
within methods. A local function is declared within the scope of a
method, a property accessor, a constructor, or lambda expressions. A
local function can only be invoked within the scope of the containing
member. Instead of using a private method that is needed in just one
place, you can use a local function.
Let’s get into an example and start without a local function—a lambda
expression that will be replaced by a local function in the next turn.
The following code snippet declares a lambda expression that’s
assigned to the delegate variable add . The variable add is in the scope of
the method IntroWithLambdaExpression , and thus it can be invoked
only within this method (code file LocalFunctions/Program.cs ):
private static void IntroWithLambdaExpression()
{
Func<int, int, int> add = (x, y) =>
{
return x + y;
};
int result = add(37, 5);
Console.WriteLine(result);
}
Instead of declaring a lambda expression, you can define a local
function. A local function is declared in a similar way to a normal
method, with a return type, the name, and parameters. The local
function is invoked in the same way as the lambda expression shown
earlier:
private static void IntroWithLocalFunctions()


{
int add(int x, int y)
{
return x + y;
}
int result = add(37, 5);
Console.WriteLine(result);
}
Compared to the lambda expression, the syntax is simpler with the
local function, and the local function also performs better. Whereas a
delegate needs an instance of a class and a collection of references to
methods, with a local function only the reference to the function is
needed, and this function can be invoked directly. The overhead is like
other methods.
Of course, if the local function can be implemented with a single
statement, the implementation can be done using an expression-
bodied member:
private static void
IntroWithLocalFunctionsWithExpressionBodies()
{
int add(int x, int y) => x + y;
int result = add(37, 5);
Console.WriteLine(result);
}
Within the method body, the local function can be implemented in any
location. There’s no need to implement them in the top of the body; it
can also be implemented elsewhere, and the local function can be
invoked before that. This behavior is like normal methods. However,
unlike normal methods, local functions cannot be virtual , abstract ,
private , or use other modifiers. The only modifiers allowed are async
and unsafe .
Like lambda expressions, local functions can access variables from the
outer scope (also known as closures) as shown in the following code
snippet where the local function accesses variable z , which is defined
outside of the local function:
private static void IntroWithLocalFunctionsWithClosures()


{
int z = 3;
int result = add(37, 5);
Console.WriteLine(result);
int add(int x, int y) => x + y + z;
}
NOTE
The only modifiers allowed with local functions are async and
unsafe . The async modifier is explained in Chapter 15,
“Asynchronous Programming,” and the unsafe modifier is
explained in Chapter 17, “Managed and Unmanaged Memory.”
A reason to use local functions is if you need the functionality only
within the scope of a method (or property, constructor, and so on).
There still would be other options to local functions. Performance is a
good reason to use local functions instead of lambda expressions. In
comparing local functions to normal private methods, local functions
don’t have a performance advantage. Of course, local functions can use
closures, whereas private methods can’t. Is this enough reason to use
local functions? To understand the real benefits of local functions, you
need to see some useful examples, which are shown in the next
sections.
Local Functions with the yield Statement
The previous chapter, “Language Integrated Query,” includes a simple
implementation of the Where method with the yield statement. What
isn’t covered there is the checking of parameters. Let’s add this to the
implementation of the Where1 method, checking the source and
predicate parameters for null (code file
LocalFunctions/EnumerableExtensions.cs ):
public static IEnumerable<T> Where1<T>(this IEnumerable<T>
source,


Func<T, bool> predicate)
{
if (source == null) throw new
ArgumentNullException(nameof(source));
if (predicate == null) throw new
ArgumentNullException(nameof(predicate));
foreach (T item in source)
{
if (predicate(item))
{
yield return item;
}
}
}
Writing code to test for the ArgumentNullException , the preprocessor
statement #line is defined to start with the source code line 1000. The
exception does not happen in the line 1004 where the null is passed to
the Where1 method; instead it happens in line 1006 with the foreach
statement. The reason for finding this error late is because of the
deferred execution of the yield statement in the implementation of the
Where1 method (code file LocalFunctions/Program.cs ):
private static void YieldSampleSimple()
{
#line 1000
Console.WriteLine(nameof(YieldSampleSimple));
try
{
string[] names = { "James", "Niki", "John", "Gerhard",
"Jack" };
var q = names.Where1(null);
foreach (var n in q) // callstack position for exception
{
Console.WriteLine(n);
}
}
catch (ArgumentNullException ex)
{
Console.WriteLine(ex);
}
Console.WriteLine();
}


To fix this issue, and to give earlier error information to the caller, the
Where1 method is implemented in two parts with the Where2 method.
Here, the Where2 method just checks for incorrect parameters and does
not include yield statements. The implementation with yield return is
done in a separate private method, the WhereImpl . This method is
invoked from the Where2 method after the input parameters have been
checked (code file LocalFunctions/EnumerationExtensions.cs ):
public static IEnumerable<T> Where2<T>(this IEnumerable<T>
source,
Func<T, bool> predicate)
{
if (source == null) throw new
ArgumentNullException(nameof(source));
if (predicate == null) throw new
ArgumentNullException(nameof(predicate));
return Where2Impl(source, predicate);
}
private static IEnumerable<T> Where2Impl<T>(IEnumerable<T>
source,
Func<T, bool> predicate)
{
foreach (T item in source)
{
if (predicate(item))
{
yield return item;
}
}
}
Calling the method now, the stack trace shows the error happened in
line 1004, where the Where2 method was invoked (code file
LocalFunctions/Program.cs ):
private static void YieldSampleWithPrivateMethod()
{
#line 1000
Console.WriteLine(nameof(YieldSampleWithPrivateMethod));
try
{
string[] names = { "James", "Niki", "John", "Gerhard",
"Jack" };


var q = names.Where2(null);
exception
// callstack position for
foreach (var n in q)
{
Console.WriteLine(n);
}
}
catch (ArgumentNullException ex)
{
Console.WriteLine(ex);
}
Console.WriteLine();
}
The issue was fixed with the Where2 method. However, now you have a
private method that is needed in only one place. The body of the
Where2 method includes parameter checks and the invocation of the
method Where2Impl . This is a great scenario for a private method. The
implementation of the Where3 method includes the checks for the
input parameters as before, as well as a private function instead of the
previous private method Where2Impl . The local function can have a
simpler signature, as it’s possible to access the variable’s source and
predicate from the outer scope (code file
LocalFunctions/EnumerableExtensions.cs ):
public static IEnumerable<T> Where3<T>(this IEnumerable<T>
source,
Func<T, bool> predicate)
{
if (source == null) throw new
ArgumentNullException(nameof(source));
if (predicate == null) throw new
ArgumentNullException(nameof(predicate));
return Iterator();
IEnumerable<T> Iterator()
{
foreach (T item in source)
{
if (predicate(item))
{
yield return item;
}


}
}
}
Invoking the method Where3 results in the same behavior as invoking
the method Where2 . The stack trace shows the issue with the invocation
of the Where3 method.
Recursive Local Functions
Another scenario that uses local function is recursive invocation,
which is shown in the next example with the QuickSort method. Here,
the local function Sort is invoked recursively until the collection is
sorted (code file LocalFunctions/Algorithms.cs ):
public static void QuickSort<T>(T[] elements) where T :
IComparable<T>
{
void Sort(int start, int end)
{
int i = start, j = end;
var pivot = elements[(start + end) / 2];
while (i <= j)
{
while (elements[i].CompareTo(pivot) < 0) i++;
while (elements[j].CompareTo(pivot) > 0) j--;
if (i <= j)
{
T tmp = elements[i];
elements[i] = elements[j];
elements[j] = tmp;
i++;
j--;
}
}
if (start < j) Sort(start, j);
if (i < end) Sort(i, end);
}
Sort(0, elements.Length - 1);
}


NOTE
When using C#, you need to be careful with recursive calls. A
recursive loop such as the following ends after about 24,000
iterations because of a stack overflow. The C# compiler does not
implement tail call optimization as the F# compiler does. With tail
call optimization, recursive calls are converted to iterations to not
consume this stack space.
public static void WhenDoesItEnd()
{
Console.WriteLine(nameof(WhenDoesItEnd));
void InnerLoop(int ix)
{
Console.WriteLine(ix++);
InnerLoop(ix);
}
InnerLoop(1);
}
TUPLES
Tuples enable you to combine objects of different types. With arrays,
you can combine objects of the same type, whereas tuples allow using
different combinations of types. Tuples help reduce the need for the
following two things:
Defining custom classes or structs for returning multiple values
Defining parameters to return multiple values from methods.
Tuples have been in the .NET Framework since version 4.0 in the form
of generic Tuple classes. However, they have not been used much as
the different objects of a tuple can be accessed using Item1 , Item2 ,
Item3 , and so on properties, and this is neither very attractive nor does
it give any information about its meaning.
This changes with C# 7, which offers tuple functionality integrated in
the programming language, and this gives great improvements as


shown in the next example, which uses a simple immutable Person
class (code file TuplesSample/Person.cs ):
public class Person
{
public Person(string firstName, string lastName)
{
FirstName = firstName;
LastName = lastName;
}
public string FirstName { get; }
public string LastName { get; }
public override string ToString() => $"{FirstName}
{LastName}";
//...
}
Declaring and Initializing Tuples
A tuple can be declared using parentheses and initialized using a tuple
literal that is created with parentheses as well. In the following code
snippet, on the left side a tuple variable t is declared containing a
string , an int , and a Person . On the right side, a tuple literal is used to
create a tuple with the string magic , the number 42 , and a Person object
initialized using a constructor of the Person class. The tuple can be
accessed using the variable t with the members declared in the
parentheses ( s , i , and p in this example; code file Tuples/Program.cs ):
private static void IntroTuples()
{
(string s, int i, Person p) t = ("magic", 42, new Person(
"Stephanie", "Nagel"));
Console.WriteLine($"s: {t.s}, i: {t.i}, p: {t.p}");
//...
}
When you run the application, the output shows the values of the
tuple:
s: magic, i: 42, p: Stephanie Nagel
The tuple literal also can be assigned to a tuple variable without
declaring its members. This way the members of the tuple are accessed


using the member names of the ValueTuple struct: Item1 , Item2 , and
Item3 :
private static void IntroTuples()
{
//...
var t2 = ("magic", 42, new Person("Matthias", "Nagel"));
Console.WriteLine($"string: {t2.Item1}, int: {t2.Item2},
person: {t2.Item3}");
//...
}
You can assign names to the tuple in the tuple literal by defining the
name followed by a colon, which is the same syntax as with object
literals:
private static void IntroTuples()
{
//...
var t3 = (s: "magic", i: 42, p: new Person("Matthias",
"Nagel"));
Console.WriteLine($"s: {t3.s}, i: {t3.i}, p: {t3.p}");
//...
}
With all this, names are just a convenience. You can assign one tuple
to another one when the types match; the names do not matter:
private static void IntroTuples()
{
//...
(string astring, int anumber, Person aperson) t4 = t3;
Console.WriteLine($"s: {t4.astring}, i: {t4.anumber}, p:
{t4.aperson}");
}
Tuple Deconstruction
You also can deconstruct tuples into variables. To do this you just need
to remove the tuple variable from the previous code sample and just
define variable names in parentheses. The variables can then be
directly accessed that contain the values of the tuple parts (code file
Tuples/Program.cs ):


private static void TupleDeconstruction()
{
(string s, int i, Person p) = ("magic", 42, new
Person("Stephanie",
"Nagel"));
Console.WriteLine($"s: {s}, i: {i}, p: {p}");
//...
}
You can also declare the variables for deconstruction using the var
keyword; the types are defined by the tuple literal. You can also
declare the variables before initialization and deconstruct the tuple to
existing variables:
private static void TupleDeconstruction()
{
//...
(var s1, var i1, var p1) = ("magic", 42, new
Person("Stephanie", "Nagel"));
Console.WriteLine($"s: {s1}, i: {i1}, p: {p1}");
string s2;
int i2;
Person p2;
(s2, i2, p2) = ("magic", 42, new Person("Katharina",
"Nagel"));
Console.WriteLine($"s: {s2}, i: {i2}, p: {p2}");
//...
}
In case you don’t need all the parts of the tuple, you can use _ to ignore
this part as shown here:
private static void TupleDeconstruction()
{
//...
(string s3, _, _) = ("magic", 42, new Person("Katharina",
"Nagel"));
Console.WriteLine(s3);
}
NOTE


Probably you already used _ when you invoked methods with out
parameter modifiers for cases where the result was not needed. In
this scenario, using _ is only a naming convention. Using _ with
tuples is different. You don’t need to declare a type, and you can
use _ multiple times; it’s a compiler feature to ignore this part
with deconstruction.
Returning Tuples
Let’s get into a more useful example: a method returning a tuple. The
method Divide from the following code snippet receives two
parameters and returns a tuple consisting of two int values. The result
is returned with a tuple literal (code file Tuples/Program.cs ):
static (int result, int remainder) Divide(int dividend, int
divisor)
{
int result = dividend / divisor;
int remainder = dividend % divisor;
return (result, remainder);
}
The result is deconstructed into the result and remainder variables:
private static void ReturningTuples()
{
(int result, int remainder) = Divide(7, 2);
Console.WriteLine($"7 / 2 - result: {result}, remainder:
{remainder}");
}
NOTE
Using tuples, you can avoid declaring method signatures with out
parameters. out parameters cannot be used with async methods;
this restriction does not apply with tuples.
Behind the Scenes


Using the new tuple syntax, the C# compiler creates ValueTuple
structures behind the scenes. .NET defines multiple ValueTuple
structures for one to seven generic parameters, and another one where
the eighth parameter can be another tuple. Using a tuple literal results
in an invocation of Tuple.Create . The Tuple structure defines fields
named Item1 , Item2 , Item3 , and so on to access all the items (code file
Tuples/Program.cs ):
private static void BehindTheScenes()
{
(string s, int i) t1 = ("magic", 42); // tuple literal
Console.WriteLine($"{t1.s} {t1.i}");
ValueTuple<string, int> t2 = ValueTuple.Create("magic",
42);
Console.WriteLine($"{t2.Item1}, {t2.Item2}");
}
How does the naming of the fields come from returning tuples from
methods? A method signature, as shown here with the Divide method,
public static (int result, int remainder) Divide(int
dividend, int divisor)
is translated to the return of a ValueTuple with the TupleElementNames
attribute for the return type:
[return: TupleElementNames(new string[] {"result",
"remainder" })]
public static ValueTuple<int, int> Divide(int dividend, int
divisor)
When using this manner of invoking the method, the compiler reads
the information from the attribute to match the names to the ItemX
fields. With the invocation, the ItemX fields are used instead of the
nicer names.
With the automatic usage of the TupleElementNames attribute, a method
returning a tuple can be declared inside a library (code file
TuplesLib/SimpleMath.cs ):
public class SimpleMath
{
public static (int result, int remainder) Divide(int
dividend, int divisor)


{
int result = dividend / divisor;
int remainder = dividend % divisor;
return (result, remainder);
}
}
The library is used from the console application where the result and
remainder names are directly available:
private static void UseALibrary()
{
var t = SimpleMath.Divide(5, 3);
Console.WriteLine($"result: {t.result}, remainder:
{t.remainder}");
}
Whereas the older Tuple type is a class, the new tuple ValueTuple is a
struct. This reduces the work needed by the garbage collector as value
types are stored on the stack. The old Tuple type is implemented as an
immutable class with read-only properties. With the new ValueTuple ,
the members are public fields. Public fields make this type mutable
(code file Tuples/Program.cs ):
static void Mutability()
{
// old tuple is a immutable reference type
Tuple<string, int> t1 = Tuple.Create("old tuple", 42);
// t1.Item1 = "new string"; // not possible with Tuple
// new tuple is a mutable value type
(string s, int i) t2 = ("new tuple", 42);
t2.s = "new string";
t2.i = 43;
t2.i++;
Console.WriteLine($"new string: {t2.s} int: {t2.i}");
}
NOTE
It looks like Microsoft broke some rules with ValueType : Structs


should be immutable, and fields should not be declared public.
However, the new tuples can be compared to simple value types
such as int and long ; breaking the rules with tuples is completely
excusable to also get best performance optimizations.
Compatibility of ValueTuple with Tuple
The older tuple types haven’t been used much because of the unkind
naming. However, for programs using the Tuple type, there’s an easy
conversion to a ValueTuple .
The Tuple type can be converted to a ValueTuple by invoking the
ToValueTuple extension method. As the old Tuple type doesn’t offer the
nicer names, you need to define the names with parentheses (code file
Tuples/Program.cs ):
static void TupleCompatibility()
{
// convert Tuple to ValueTuple
Tuple<string, int, bool, Person> t1 = Tuple.Create("a
string", 42, true,
new Person("Katharina", "Nagel"));
Console.WriteLine($"old tuple - string: {t1.Item1}, number:
{t1.Item2},
bool: {t1.Item3}, Person: {t1.Item4}");
(string s, int i, bool b, Person p) t2 = t1.ToValueTuple();
Console.WriteLine($"new tuple - string: {t2.s}, number:
{t2.i}, bool: {t2.b},
Person: {t2.p}");
//...
}
Old tuples can also be deconstructed to specific fields. The following
example shows deconstructing the tuple t1 to the fields s , i , and b :
static void TupleCompatibility()
{
//...
(string s, int i, bool b, Person p) = t1; // Deconstruct
Console.WriteLine($"new tuple - string: {s}, number: {i},
bool: {b},
Person {p}");
//...


}
It’s also possible to do this the other way around. New value tuples can
be converted to tuples with the ToTuple method. Of course, then you
need to specify the members using Item1 , Item2 , Item3 , and so on.
static void TupleCompatibility()
{
//...
// convert ValueTuple to Tuple
Tuple<string, int, bool, Person> t3 = t2.ToTuple();
Console.WriteLine($"old tuple - string: {t1.Item1}, number:
{t1.Item2}, " +
$"bool: {t1.Item3}, Person: {t1.Item4}");
}
Infer Tuple Names
A new feature of C# 7.1 is the inference of tuple names. The Divide
method declared earlier returns a tuple with the names result and
remainder . The returned tuple is written to the variable t1 where these
names are used to access the tuple fields. When you invoke the Divide
method the second time, the tuple result is written to a tuple with the
names res and rem . From the returned tuple, the result is written to
res , and remainder is written to rem . t3 is created using a tuple literal
where the res and rem fields are defined, and the values from tuple t1
are assigned accordingly. The fourth tuple in this example makes use
of name inference. t4 is created using a tuple literal where the names
are the same as the names from tuple t1 . Accessing the result and
remainder fields without giving a name to the tuple members takes the
same names as coming from t1 . t4 also has members named result
and remainder (code file Tuples/Program.cs ):
private static void TupleNames()
{
var t1 = Divide(9, 4);
Console.WriteLine($"{t1.result}, {t1.remainder}");
(int res, int rem) t2 = Divide(11, 3);
Console.WriteLine($"{t2.res}, {t2.rem}");
var t3 = (res: t1.result, rem: t1.remainder);


// use inferred names
var t4 = (t1.result, t1.remainder);
Console.WriteLine($"{t4.result}, {t4.remainder}");
}
NOTE
Inference of tuple names requires at least C# 7.1. You need to
specify this version using LangVersion in the csproj project file or
by using the Project Settings in Visual Studio.
Tuples with Linked Lists
A practical use of tuples is with linked lists. With a linked list, an item
(which is a LinkedListNode ) contains the value and a reference to the
next item. In the following code snippet, you create a LinkedList that
contains 10 elements. Then the do/while statement is used to walk
through this list. Within the loop, a tuple literal is used to access the
Value and Next properties of the LinkedListNode . With deconstruction,
the value is written to the variable value , and the next item in the
linked list is written to the variable node , which itself is the
LinkedListNode again (code file Tuples/Program.cs ):
static void TuplesWithLinkedList()
{
Console.WriteLine(nameof(TuplesWithLinkedList));
var list = new LinkedList<int>(Enumerable.Range(0, 10));
int value;
LinkedListNode<int> node = list.First;
do
{
(value, node) = (node.Value, node.Next);
Console.WriteLine(value);
} while (node != null);
Console.WriteLine();
}


NOTE
Linked lists are discussed in Chapter 10, “Collections.”
Tuples with LINQ
The previous chapter demonstrates anonymous types and tuples with
a LINQ statement. Let’s change one LINQ query from anonymous
types to tuples. The following LINQ query creates an anonymous type
with LastName and Starts property in the parameter of the Select
method (code file Tuples/Program.cs ):
static void UsingAnonymousTypes()
{
var racerNamesAndStarts = Formula1.GetChampions()
.Where(r => r.Country == "Italy")
.OrderByDescending(r => r.Wins)
.Select(r => new
{
r.LastName,
r.Starts
});
foreach (var r in racerNamesAndStarts)
{
Console.WriteLine($"{r.LastName}, starts: {r.Starts}");
}
}
Changing the curly brackets to parentheses creates a tuple with the
fields LastName and Starts :
static void UsingTuples()
{
var racerNamesAndStarts = Formula1.GetChampions()
.Where(r => r.Country == "Italy")
.OrderByDescending(r => r.Wins)
.Select(r =>
(
r.LastName,
r.Starts


));
foreach (var r in racerNamesAndStarts)
{
Console.WriteLine($"{r.LastName}, starts: {r.Starts}");
}
}
NOTE
With anonymous types, a class is created, and thus instances of
this class are allocated on the heap and need to be collected from
the garbage collector. By comparison, tuples are value types and
stored on the stack. Tuples can have a performance advantage.
Deconstruction
You’ve already seen deconstruction with tuples—writing tuples into
simple variables. Deconstruction can also be done with any type:
deconstructing a class or struct into its parts.
For example, the previously shown Person class can be deconstructed
into first name and last name (code file Tuples/Program.cs ):
private static void Deconstruct()
{
var p1 = new Person("Katharina", "Nagel");
(var first, var last) = p1;
Console.WriteLine($"{first} {last}");
}
All that needs to be done is to create a Deconstruct method that fills
the separate parts into out parameters (code file Tuples/Person.cs ):
public class Person
{
public Person(string firstName, string lastName)
{
FirstName = firstName;
LastName = lastName;


}
public string FirstName { get; }
public string LastName { get; }
public override string ToString() => $"{FirstName}
{LastName}";
public void Deconstruct(out string firstName, out string
lastName)
{
firstName = FirstName;
lastName = LastName;
}
}
Deconstruction is implemented with the method name Deconstruct .
This method is always of type void and returns the part with out
parameters. You might wonder why a method creating a tuple can’t be
implemented by returning a tuple. The reason is that overloads are
allowed. You can implement multiple Deconstruct methods using
different parameter types. This wouldn’t be possible when returning a
tuple. With C#, an overloaded method cannot be selected just by its
return type.
Deconstruction with Extension Methods
Deconstruction can also be implemented without adding a Deconstruct
method to the class that should be deconstructed: by using extension
methods. The following code example defines an extension method for
the Racer type to deconstruct a Racer to firstName , lastName , starts ,
and wins (code file Tuples/RacerExtensions.cs ):
public static class RacerExtensions
{
public static void Deconstruct(this Racer r, out string
firstName,
out string lastName, out int starts, out int wins)
{
firstName = r.FirstName;
lastName = r.LastName;
starts = r.Starts;
wins = r.Wins;
}
}


The following code snippet deconstructs a Racer to the variables first
and last . Starts and wins are ignored (code file Tuples/Program.cs ):
static void DeconstructWithExtensionsMethods()
{
var racer = Formula1.GetChampions().Where(
r => r.LastName == "Lauda").First();
(string first, string last, _, _) = racer;
Console.WriteLine($"{first} {last}");
}
Tuples are one of the most important improvements (if not the most
important one) of C# 7. Next, let’s get into pattern matching, which is
another great feature of C# 7.
PATTERN MATCHING
From an object-oriented view, it would be best to always use concrete
types and interfaces to solve a problem. However, often this is not easy
to do. From a database, a query might give you different object types
that are not related to any hierarchy. When you access API services, a
list or a single object can be returned—or perhaps nothing at all is
returned. Thus, a method often should work with diverse types. This is
where pattern matching can help.
For the example, an array of different objects is created. The array
named data contains null with the first element, the integer with the
value 42 , a string, an object of type Person , and an array containing
Person objects (code file PatternMatching/Program.cs ):
static void Main()
{
var p1 = new Person("Katharina", "Nagel");
var p2 = new Person("Matthias", "Nagel");
var p3 = new Person("Stephanie", "Nagel");
object[] data = { null, 42, "astring", p1, new Person[] {
p2, p3 } };
foreach (var item in data)
{
IsOperator(item);
}


foreach (var item in data)
{
SwitchStatement(item);
}
}
With pattern matching in C# 7, the is operator and the switch
statement have been enhanced with three kinds of patterns: the const
pattern, the type pattern, and the var pattern. Let’s get into details
starting with the is operator.
Pattern Matching with the is Operator
A simple match with the is operator is the const pattern. With this
pattern, you can compare an object to constant values such as null or
42 (code file PatternMatching/Program.cs ):
static void IsOperator(object item)
{
// const pattern
if (item is null)
{
Console.WriteLine("item is null");
}
if (item is 42)
{
Console.WriteLine("item is 42");
}
//...
}
When you run the application with the previously declared array, the
first two items of the array match with the two if statements as shown
in this program output:
item is null
item is 42
NOTE


Parameters of methods usually have been checked for null
comparing to null using the equal operator. For example,
if (item == null) throw ArgumentNullException("null");
This can now be replaced using pattern matching:
if (item is null) throw ArgumentNullException("null");
Behind the scenes, the C# compiler generates the same
Intermediate Language (IL) code.
The most interesting pattern match is the type pattern. With this
pattern you can match for a specific type, such as int or string . This
pattern also enables you to declare a variable, such as if (item is int
i) . The variable i is assigned to the item if the pattern applies:
static void IsOperator(object item)
{
//...
// type pattern
if (item is int)
{
Console.WriteLine($"Item is of type int");
}
if (item is int i)
{
Console.WriteLine($"Item is of type int with the value
{i}");
}
if (item is string s)
{
Console.WriteLine($"Item is a string: {s}");
}
//...
}
With the previous type patterns, these matches apply with the value 42
and the string astring :
Item is of type int
Item is of type int with a value 42
Item is a string: astring


Declaring a variable of the type allows strongly typed access. You can
access all the members of the type without the need for a cast. This
also allows using logical operators in the if statement to check for
other constraints than just the type, such as if the FirstName starts with
the string Ka :
static void IsOperator(object item)
{
//...
if (item is Person p && p.FirstName.StartsWith("Ka"))
{
Console.WriteLine($"Item is a person: {p.FirstName}
{p.LastName}");
}
if (item is IEnumerable<Person> people)
{
string names = string.Join(", ",
people.Select(p1 => p1.FirstName).ToArray());
Console.WriteLine($"it's a Person collection containing
{names}");
}
//...
}
With the previous two type patterns and the object array applied, these
matches apply:
Item is a person: Katharina Nagel
it's a Person collection containing Matthias, Stephanie
One more pattern type needs to be discussed: the var pattern.
Everything can be applied to a var ; you just get the concrete type. With
the sample code, the GetType method is invoked to get the name of the
type and to write the concrete type to the console. When the value is
null , the var pattern applies as well. That’s why the null-conditional
operator is used with the every variable. every is null if the item is
null , which writes the string null to the console:
static void IsOperator(object item)
{
//...
// var pattern
if (item is var every)


{
Console.WriteLine($"it's var of type
{every?.GetType().Name ?? "null"} " +
$"with the value {every ?? "nothing"}");
}
}
The output of the application for the var pattern shows that all items of
the array match with this pattern:
it's var of type null with the value nothing
it's var of type Int32 with the value 42
it's var of type String with the value astring
it's var of type Person with the value Katharina Nagel
it's var of type Person[] with the value
PatternMatching.Person[]
Pattern Matching with the switch Statement
With the switch statement, the three pattern types can be used as well.
The following code snippet shows the const pattern with cases for null
and 42 ; the type pattern for int , string , and Person ; and the var
pattern. Like the extension of the is operator, with the switch
statement a variable can be specified with the type pattern to write the
matching result to this variable. You also can apply an additional filter
with the when clause. The first type match for the Person class applies
only when the FirstName property of the Person has the value
Katharina . With the switch statement, the ordering of the cases is
important. As soon as one case applies, the other cases are not checked
further. If the first match to the Person type with the when clause
applies, the second case for Person does not apply. That’s why when
filtering must be done before general cases for a type. The var pattern
that is defined with the last case matches with every object passed to
the switch. However, this case is checked only if none of the other
cases that are defined earlier apply. The default clause can be on every
position of the switch statement, and it applies only if none of the
cases match. It’s just a good practice to put this clause last (code file
PatternMatching/Program.cs ):
static void SwitchStatement(object item)
{
switch (item)


{
case null:
case 42:
Console.WriteLine("it's a const pattern");
break;
case int i:
Console.WriteLine($"it's a type pattern with int:
{i}");
break;
case string s:
Console.WriteLine($"it's a type pattern with string:
{s}");
break;
case Person p when p.FirstName == "Katharina":
Console.WriteLine($"type pattern match with Person and
" +
$"when clause: {p}");
break;
case Person p:
Console.WriteLine($"type pattern match with Person:
{p}");
break;
case var every:
Console.WriteLine($"var pattern match:
{every?.GetType().Name}");
break;
default:
}
}
When you run the application, the const pattern of the switch
statement applies with null and 42 , the string pattern applies with the
string astring , with the Person object the first Person case applies, and
finally, the Person array matches the var pattern—because no other
pattern applied earlier. A match to the type pattern with the int type
did not apply because the const pattern was an earlier match:
it's a const pattern
it's a const pattern
it's a type pattern with string: astring
type pattern match with Person and when clause: Katharina
Nagel
var pattern match: Person[]
Pattern Matching with Generics


If you need pattern matching with generics, you need the compiler be
configured to at least C# 7.1. C# 7.1 adds pattern matching for
generics. With C# 7, you can define a generic method as shown and
use the is operator to check a variable of a generic type for a specific
type to apply (code file PatternMatching/HttpManager.cs ):
public void Send<T>(T package)
{
if (package is HealthPackage hp)
{
hp.CheckHealth();
}
//...
}
You can do pattern matching with generics similarly to the manner
you use with generic classes. You can also use generics with pattern
matching and the switch statement as well.
NOTE
Generic methods and generic classes are discussed in Chapter 5,
“Generics.”
SUMMARY
In this chapter, you’ve seen new features of C# 7 such as local
functions, tuples, and pattern matching. All these features are coming
from the functional programming paradigm, but all are very useful for
creating normal .NET applications. Local functions are useful in a few
scenarios, such as for allowing better error handling with delayed
methods using the yield statement. Tuples offer an efficient way to
combine different data types. It’s not necessary to always create
custom classes for such combinations.
You’ve also seen how tuples can replace anonymous types in LINQ
queries. Pattern matching allows dealing with different types using
enhancements of the is operator and the switch statement.


The next chapter goes into the details of errors and exceptions.