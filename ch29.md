

Tracing, Logging, and Analytics
WHAT’S IN THIS CHAPTER?
Simple tracing with EventSource
Advanced tracing with EventSource
Creating a custom trace listener
Using the ILogger interface
Using Visual Studio App Center with Windows apps
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory Diagnostics .
The code for this chapter is divided into the following major
examples:
SimpleEventSourceSample
EventSourceSampleInheritance
EventSourceSampleAnnotations
ClientApp/MyApplicationEvents


LoggingSample
WinAppAnalytics
DIAGNOSTICS OVERVIEW
As release cycles for applications become faster and faster, it’s
becoming more and more important to learn how the application
behaves while it’s running in production. What exceptions are
occurring? Knowing what features are used is also of interest. Do users
find the new feature of the app? How long do they stay in the page? To
answer these questions, you need real-time information on the
application.
When you’re getting information about the application, you need to
differ logging, tracing, and analytics. With logging, error information
is recorded in centralized places. This information is used by system
administrators to find out issues with applications. Tracing helps to
find out which method is called by which method. This information is
useful for development, and you should turn it off when the
application runs in production. With .NET, the same technology can
be used for logging and tracing using classes from the
System.Diagnostics namespace. Analytics gives information about the
users, where they reside, what operating system version they use, and
what features they use in the application. This helps to know if there
are some issues with the application based on a location, hardware, or
an operating system, and it also helps to understand what the users
are doing. Users might not find a new feature of the application if it’s
hard to find out about this feature.
This chapter explains how to get real-time information about your
running application to identify any issues that it might have during
production or to monitor resource usage to ensure that higher user
loads can be accommodated. This is where the namespace
System.Diagnostics.Tracing comes into play. This namespace offers
classes for tracing using Event Tracing for Windows (ETW).
One way to deal with errors in your application, of course, is by
throwing exceptions. However, an application might not fail with an


exception, but it still doesn’t behave as expected. The application
might be running well on most systems but have a problem on a few.
On the live system, you can change the log by starting a trace collector
and get detailed live information about what’s going on in the
application. You can do this using ETW.
If there are problems with applications, the system administrator
needs to be informed. The Event Viewer is a commonly used tool that
not only the system administrator should be aware of but also the
software developer. With the Event Viewer, you can both interactively
monitor problems with applications and can add subscriptions to be
informed about specific events that happen. ETW enables you to write
information about the application.
Application Insights is a Microsoft Azure cloud service that enables
you to monitor apps in the cloud. With just a few lines of code, you can
get detailed information about how a web application or service is
used.
Visual Studio App Center allows monitoring of Windows and Xamarin
apps. After you’ve registered the app, you just need a few lines of code
to receive useful information about the app.
This chapter explains these facilities and demonstrates how you can
use them for your applications.
TRACING WITH EVENTSOURCE
Tracing enables you to see informational messages about the running
application. To get information about a running application, you can
start the application in the debugger. During debugging, you can walk
through the application step by step and set breakpoints at specific
lines and when you reach specific conditions. The problem with
debugging is that a program with release code can behave differently
from a program with debug code. For example, while the program is
stopping at a breakpoint, other threads of the application are
suspended as well. Also, with a release build, the compiler-generated
output is optimized and, thus, different effects can occur. With
optimized release code, garbage collection is much more aggressive


than with debug code. The order of calls within a method can be
changed, and some methods can be removed completely and be called
in place. There is a need to have runtime information from the release
build of a program as well. Trace messages are written with both
debug and release code.
A scenario showing how tracing helps is described here. After an
application is deployed, it runs on one system without problems,
whereas on another system intermittent problems occur. When you
enable verbose tracing, the system with the problems gives you
detailed information about what’s happening inside the application.
The system that is running without problems has tracing configured
just for error messages redirected to the Windows event log system.
Critical errors are seen by the system administrator. The overhead of
tracing is very small because you configure a trace level only when
needed.
Tracing has quite a history with .NET. After a simple tracing
functionality with the first version of .NET and the Trace class, .NET
2.0 made huge improvements on tracing and introduced the
TraceSource class. The architecture behind TraceSource is very flexible
in separating the source, the listener, and a switch to turn tracing on
and off based on a list of trace levels.
Starting with .NET 4.5, again a new tracing class was introduced and
enhanced with .NET 4.6: the EventSource class. This class is defined in
the System.Diagnostics.Tracing namespace in the NuGet package
Sytem.Diagnostics .
The new tracing architecture is based on Event Tracing for Windows
(ETW), which was introduced with Windows Vista. It allows for fast
system-wide messaging that is also used by the Windows event-
logging and performance-monitoring facilities.
Let’s get into the concepts of ETW tracing and the EventSource class.
An ETW provider is a library that fires ETW events. The
applications created with this chapter are ETW providers.
An ETW manifest describes the events that can be fired from
ETW providers. Using a predefined manifest has the advantage


that the system administrator already knows what events an
application can fire as soon as the application is installed. This way
the administrator can already configure listening for specific
events. The new version of the EventSource allows both self-
describing events and events described by a manifest.
ETW keywords can be used to create categories for events. They
are defined as bit-flags.
ETW tasks are another way to group events. Tasks can be created
to define events based on different scenarios of the program. Tasks
are usually used with opcodes.
ETW opcodes identify operations within a task. Both tasks and
opcodes are defined with integer values.
An event source is the class that fires events. You can either use
the EventSource class directly or create a class that derives from the
base class EventSource .
An event method is a method of the event source that fires
events. Deriving from the class EventSource , every void method is
an event method if it is not annotated with the NonEvent attribute.
Event methods can be annotated with the Event attribute.
The event level defines the severity or verbosity of an event. This
can be used to differ between critical, error, warning,
informational, and verbose events.
ETW channels are sinks for events. Events can be written to
channels and log files. Admin, Operational, Analytic, and Debug
are predefined channels.
Using the EventSource class, you will see the ETW concepts in action.
Examining a Simple Use of EventSource
The sample code using the EventSource class makes use of these
namespaces:
System
System.Collections.Generic


System.Diagnostics.Tracing
System.IO
System.Net.Http
System.Threading.Tasks
The EventSource class offers various ways to use it. There’s a simple
way when instantiating this class and invoking methods for logging,
and a more advanced way when using it as a base class. There’s also a
way of adding annotations.
The first example for using EventSource shows a simple case that is
useful in small projects. EventSource is instantiated as a static member
of the Program class with a Console App (.NET Core) project. With the
constructor, the name of the event source is specified (code file
SimpleEventSourceSample/Program.cs ):
private static EventSource sampleEventSource =
new EventSource("Wrox-EventSourceSample1");
With the Main method of the Program class, the unique identifier of the
event source is retrieved using the Guid property. This identifier is
created based on the name of the event source. After this, the first
event is written to invoke the Write method of EventSource . The
parameter required is the event name that needs to be passed. Other
parameters are available with overloads of the object. The second
parameter that is passed is an anonymous object defining the Info
property. This can be used to pass any information about the event to
the event log (code file SimpleEventSourceSample/Program.cs ):
static async Task Main()
{
Console.WriteLine($"Log Guid: {sampleEventSource.Guid}");
Console.WriteLine($"Name: {sampleEventSource.Name}");
sampleEventSource.Write("Startup", new { Info = "started
app" });
await NetworkRequestSampleAsync();
Console.ReadLine();
sampleEventSource?.Dispose();
}


NOTE
Instead of passing an anonymous object with custom data to the
EventSource.Write method, you can create a class that derives
from the base class EventSource and mark it with the attribute
EventData . This attribute is shown later in this chapter.
The method NetworkRequestSampleAsync that is invoked from the Main
method makes a network request and writes a trace log passing the
URL that is requested to the trace information. On completion of the
network call, trace information is written again. The exception-
handling code shows another method overload on writing trace
information. Different overloads allow passing specific information
that is shown in the next sections. The following code snippet shows
EventSourceOptions setting a trace level. The Error event level is set by
writing error information. This level can be used to filter specific trace
information. With filtering you can decide to read just error
information—for example, information with the error level and
information that is more critical than the error level. During another
tracing session you can decide to read all trace information using the
verbose level. The EventLevel enumeration defines the values
LogAlways , Critical , Error , Warning , Informational , and Verbose (code
file SimpleEventSourceSample/Program.cs ):
private static async Task NetworkRequestSample()
{
try
{
using (var client = new HttpClient())
{
string url = "http://www.cninnovation.com";
sampleEventSource.Write("Network", new { Info =
$"requesting {url}" });
string result = await client.GetStringAsync(url);
sampleEventSource.Write("Network",
new
{
Info =


$"completed call to {url}, result string length:
{result.Length}"
});
}
Console.WriteLine("Complete.................");
}
catch (Exception ex)
{
sampleEventSource.Write("Network Error",
new EventSourceOptions { Level = EventLevel.Error },
new { Message = ex.Message, Result = ex.HResult });
Console.WriteLine(ex.Message);
}
}}
Before you run the application, you need to do some preparation:
download and configure tools you use for reading the traces. The next
section explains how to do this.
Understanding Tools for Tracing
For analyzing trace information, several tools are available. logman is
a tool that is part of Windows. With logman you can create and
manage event trace sessions and write ETW traces to a binary log file.
tracerpt is also available with Windows. This tool enables you to
convert the binary information written from logman to a CSV, XML, or
EVTX file format. PerfView is a tool that offers graphical information
for ETW traces.
Logman
Let’s begin using logman to create a trace session from the previously
created application. You need to first start the application to copy the
GUID that’s created for the application. You need this GUID to start a
log session with logman . The start option starts a new session to log.
The -p option defines the name of the provider; here the GUID is used
to identify the provider. The -o option defines the output file, and the -
ets option sends the command directly to the event trace system
without scheduling. Be sure to start logman in a directory where you
have write access; otherwise it fails to write the output file
mytrace.etl :


logman start mysession -p {3b0e7fa6-0346-5781-db55-
49d84d7103de}
-o mytrace.etl -ets
After running the application, you can stop the trace session with the
stop command:
logman stop mysession -ets
NOTE
logman has a lot more commands that are not covered here.
Using logman, you can see all the installed ETW trace providers
and their names and identifiers, create data collectors to start
and stop at specified times, define maximum log file sizes, and
more. You can see the different options of logman with logman -h .
Tracerpt
The log file is in a binary format. To get a readable representation, you
can use the utility tracerpt . With this tool, it’s possible to extract CSV,
XML, and EVTX formats, as specified with the -of option:
tracerpt mytrace.etl -o mytrace.xml -of XML
Now the information is available in a readable format. With the
information that is logged by the application, you can see the event
name passed to the EventSource.Write method manifests within the
Task element, and you can find the anonymous object within the
EventData element:
<Event
xmlns="http://schemas.microsoft.com/win/2004/08/events/event">
<System>
<Provider Name="Wrox-SimpleEventSourceSample"
Guid="{3b0e7fa6-0346-5781-db55-49d84d7103de}" />
<EventID>2</EventID>
<Version>0</Version>
<Level>5</Level>


<Task>0</Task>
<Opcode>0</Opcode>
<Keywords>0x0</Keywords>
<TimeCreated SystemTime="2017-12-
23T10:42:07.960330900+00:59" />
<Correlation ActivityID="{00000000-0000-0000-0000-
000000000000}" />
<Execution ProcessID="12700" ThreadID="19340"
ProcessorID="1"
KernelTime="30" UserTime="15" />
<Channel />
<Computer />
</System>
<EventData>
<Data Name="Info">started app</Data>
</EventData>
<RenderingInfo Culture="en-US">
<Task>Startup</Task>
</RenderingInfo>
</Event>
The error information is shown with the trace as shown here:
<EventData>
<Data Name="Message">An error occurred while sending the
request.</Data>
<Data Name="Result">-2146233088</Data>
</EventData>
PerfView
Another tool to read trace information is PerfView. You can download
this tool from the Microsoft downloads page
https://www.microsoft.com/download/details.aspx?id=28567 ). Version
1.9 of this tool has great enhancements for using it with Visual Studio
and the self-describing ETW format from EventSource . This tool
doesn’t need to be installed; just copy the tool where you need it. After
you start this tool, it makes use of the subdirectories where it is located
and allows directly opening the binary ETL file. Figure 29-1 shows
PerfView opening the file mytrace.etl created by logman.


FIGURE 29-1
Deriving from EventSource
Instead of directly using an instance of EventSource , all the
information that could be traced can be defined in a single place. For
many applications, it’s enough to define just one event source. This
event source can be defined in a separate logging assembly. The event
source class needs to derive from the base class EventSource . With this
custom class, all the trace information that should be written can be
defined by separate methods that invoke the WriteEvent method of the
base class. The class is implemented with the Singleton pattern, which
offers a static Log property that returns an instance. Naming this
property Log is a convention used with event sources. The private
constructor calls the constructor of the base class to set the event
source name (code file
EventSourceSampleInheritance/SampleEventSource .cs ):
public class SampleEventSource : EventSource
{
private SampleEventSource()
: base("Wrox-SampleEventSource2") { }
public static SampleEventSource Log = new
SampleEventSource();
public void Startup() => WriteEvent(1);
public void CallService(string url) => WriteEvent(2, url);
public void CalledService(string url, int length) =>
WriteEvent(3, url, length);


public void ServiceError(string message, int error) =>
WriteEvent(4, message, error);
}
All the void methods of an event source class are used to write event
information. In case you’re defining a helper method, it needs to be
annotated with the NonEvent attribute.
In a simple scenario where only information messages should be
written, nothing more is necessary. Besides passing an event ID to the
trace log, the WriteEvent method has 18 overloads that allow passing
message string s, int , and long values, and any number of object s.
With this implementation, you can use the members of the
SampleEventSource type to write trace messages as shown in the
Program class. The Main method makes a trace log calling the Startup
method, invokes the NetworkRequestSample method to create a trace
log via the CallService method, and makes a trace log in case of an
error (code file EventSourceSampleInheritance/Program.cs ):
public class Program
{
Static async Task Main()
{
SampleEventSource.Log.Startup();
Console.WriteLine($"Log Guid:
{SampleEventSource.Log.Guid}");
Console.WriteLine($"Name: {SampleEventSource.Log.Name}");
await NetworkRequestSampleAsync();
Console.ReadLine();
}
private static async Task NetworkRequestSampleAsync()
{
try
{
var client = new HttpClient();
string url = "http://www.cninnovation.com";
SampleEventSource.Log.CallService(url);
string result = await client.GetStringAsync(url);
SampleEventSource.Log.CalledService(url,
result.Length);
Console.WriteLine("Complete.................");


}
catch (Exception ex)
{
SampleEventSource.Log.ServiceError(ex.Message,
ex.HResult);
Console.WriteLine(ex.Message);
}
}
}
When you run the app with these commands with a developer
command prompt from the directory of the project, you produce an
XML file that contains information about the traces:
> logman start mysession -p "{1cedea2a-a420-5660-1ff0-
f718b8ea5138}"
-o log2.etl -ets
> dotnet run
> logman stop mysession -ets
> tracerpt log2.etl -o log2.xml -of XML
The event information about the service call is shown here:
<Event
xmlns="http://schemas.microsoft.com/win/2004/08/events/event">
<System>
<Provider Name="Wrox-SampleEventSource2"
Guid="{1cedea2a-a420-5660-1ff0-f718b8ea5138}" />
<EventID>7</EventID>
<Version>0</Version>
<Level>4</Level>
<Task>0</Task>
<Opcode>0</Opcode>
<Keywords>0xF00000000000</Keywords>
<TimeCreated SystemTime="2017-12-
23T13:32:59.015066500+00:59" />
<Correlation ActivityID="{00000000-0000-0000-0000-
000000000000}" />
<Execution ProcessID="6196" ThreadID="36392"
ProcessorID="0"
KernelTime="30" UserTime="45" />
<Channel />
<Computer />
</System>
<EventData>
<Data Name="url">http://www.cninnovation.com</Data>


</EventData>
<RenderingInfo Culture="en-US">
<Task>CallService</Task>
</RenderingInfo>
</Event>
Using Annotations with EventSource
Creating an event source class that derives from EventSource , you have
more control on defining the trace information. You can add
annotations to the methods by using attributes.
By default, the name of the event source is the same as the name of the
class, but you can change the name and the unique identifier by
applying the EventSource attribute. Every event trace method can be
accompanied by the Event attribute. Here you can define the ID of the
event, an opcode, the trace level, custom keywords, and tasks. This
information is used to create manifest information for Windows to
define what information is logged. The base methods WriteEvent that
are called within the methods using the EventSource need to match the
event ID defined by the Event attribute, and the variable names passed
to the WriteEvent methods need to match the argument names of the
declared method.
With the sample class SampleEventSource , custom keywords are
defined by the inner class Keywords . The members of this class are cast
to the enumeration type EventKeywords . EventKeywords is a flag-based
enum of type long that defines only values with upper bits starting
with bit 42. You can use all the lower bits to define custom keywords.
The Keywords class defines values for the lowest four bits set to
Network , Database , Diagnostics , and Performance . The enum EventTask
is a similar flags-based enumeration. Contrary to EventKeywords , an
int is enough for its backing store, and EventTask doesn’t have
predefined values (only the enumeration value None = 0 is
predefined). Like the Keywords class, the Task class defines custom
tasks for the EventTask enumeration (code file
EventSourceSampleAnnotations/SampleEventSource.cs ):
class SampleEventSource : EventSource
{
public class Keywords


{
public const EventKeywords
public const EventKeywords
public const EventKeywords
(EventKeywords)4;
public const EventKeywords
(EventKeywords)8;
}
Network = (EventKeywords)1;
Database = (EventKeywords)2;
Diagnostics =
Performance =
public class Tasks
{
public const EventTask CreateMenus = (EventTask)1;
public const EventTask QueryMenus = (EventTask)2;
}
private SampleEventSource()
{
}
public static SampleEventSource Log = new SampleEventSource
();
[Event(1, Opcode=EventOpcode.Start,
Level=EventLevel.Verbose)]
public void Startup() => WriteEvent(1);
[Event(2, Opcode=EventOpcode.Info,
Keywords=Keywords.Network,
Level=EventLevel.Verbose, Message="{0}")]
public void CallService(string url) => WriteEvent(2, url);
[Event(3, Opcode=EventOpcode.Info,
Keywords=Keywords.Network,
Level=EventLevel.Verbose, Message="{0}, length: {1}")]
public void CalledService(string url, int length) =>
WriteEvent(3, url, length);
[Event(4, Opcode=EventOpcode.Info,
Keywords=Keywords.Network,
Level=EventLevel.Error, Message="{0} error: {1}")]
public void ServiceError(string message, int error) =>
WriteEvent(4, message, error);
[Event(5, Opcode=EventOpcode.Info, Task=Tasks.CreateMenus,
Level=EventLevel.Verbose, Keywords=Keywords.Network)]
public void SomeTask() => WriteEvent(5);
}


The Program class to write these events is unchanged. The information
from these events can now be used on using a listener and filtering
only events for specific keywords, for specific log levels, or for specific
tasks. You see how to create listeners later in this chapter in the
“Creating Custom Listeners” section.
Creating Event Manifest Schema
Creating a custom event source class has the advantage that you can
create a manifest that describes all the trace information. Using the
EventSource class without inheritance, the Settings property is set to
the value EtwSelfDescribingEventFormat of the enumeration
EventSourceSettings . The events are directly described by the methods
invoked. When you use a class that inherits from EventSource , the
Settings property has the value EtwManifestEventFormat . The event
information is described by a manifest.
You can create the manifest file by using the static method
GenerateManifest of the EventSource class. The first parameter defines
the class of the event source; the second parameter describes the path
of the assembly that contains the event source type (code file
EventSourceSampleAnnotations/Program.cs ):
public static void GenerateManifest()
{
string schema = SampleEventSource.GenerateManifest(
typeof(SampleEventSource), ".");
File.WriteAllText("sampleeventsource.xml", schema);
}
This is the manifest information containing tasks, keywords, events,
and templates for the event messages (code file
EventSourceSampleAnnotations/sampleeventsource.xml ):
<instrumentationManifest
xmlns="http://schemas.microsoft.com/win/2004/08/events">
<instrumentation
xmlns:xs="http://www.w3.org/2001/XMLSchema"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:win="http://manifests.microsoft.com/win/2004/08/windows/events">


<events
xmlns="http://schemas.microsoft.com/win/2004/08/events">
<provider name="EventSourceSample"
guid="{45fff0e2-7198-4e4f-9fc3-df6934680096}"
resourceFileName="."
messageFileName="." symbol="EventSourceSample">
<tasks>
<task name="CreateMenus"
message="$(string.task_CreateMenus)"
value="1"/>
<task name="QueryMenus"
message="$(string.task_QueryMenus)"
value="2"/>
<task name="ServiceError"
message="$(string.task_ServiceError)"
value="65530"/>
<task name="CalledService"
message="$(string.task_CalledService)"
value="65531"/>
<task name="CallService"
message="$(string.task_CallService)"
value="65532"/>
<task name="EventSourceMessage"
message="$(string.task_EventSourceMessage)"
value="65534"/>
</tasks>
<opcodes>
</opcodes>
<keywords>
<keyword name="Network"
message="$(string.keyword_Network)"
mask="0x1"/>
<keyword name="Database"
message="$(string.keyword_Database)"
mask="0x2"/>
<keyword name="Diagnostics"
message="$(string.keyword_Diagnostics)"
mask="0x4"/>
<keyword name="Performance"
message="$(string.keyword_Performance)"
mask="0x8"/>
<keyword name="Session3"
message="$(string.keyword_Session3)"
mask="0x100000000000"/>
<keyword name="Session2"
message="$(string.keyword_Session2)"
mask="0x200000000000"/>
<keyword name="Session1"


message="$(string.keyword_Session1)"
mask="0x400000000000"/>
<keyword name="Session0"
message="$(string.keyword_Session0)"
mask="0x800000000000"/>
</keywords>
<events>
<event value="0" version="0" level="win:LogAlways"
symbol="EventSourceMessage"
task="EventSourceMessage"
template="EventSourceMessageArgs"/>
<event value="1" version="0" level="win:Verbose"
symbol="Startup"
opcode="win:Start"/>
<event value="2" version="0" level="win:Verbose"
symbol="CallService"
message="$(string.event_CallService)"
keywords="Network"
task="CallService" template="CallServiceArgs"/>
<event value="3" version="0" level="win:Verbose"
symbol="CalledService"
message="$(string.event_CalledService)"
keywords="Network" task="CalledService"
template="CalledServiceArgs"/>
<event value="4" version="0" level="win:Error"
symbol="ServiceError"
message="$(string.event_ServiceError)"
keywords="Network"
task="ServiceError" template="ServiceErrorArgs"/>
<event value="5" version="0" level="win:Verbose"
symbol="SomeTask"
keywords="Network" task="CreateMenus"/>
</events>
<templates>
<template tid="EventSourceMessageArgs">
<data name="message" inType="win:UnicodeString"/>
</template>
<template tid="CallServiceArgs">
<data name="url" inType="win:UnicodeString"/>
</template>
<template tid="CalledServiceArgs">
<data name="url" inType="win:UnicodeString"/>
<data name="length" inType="win:Int32"/>
</template>
<template tid="ServiceErrorArgs">
<data name="message" inType="win:UnicodeString"/>
<data name="error" inType="win:Int32"/>


</template>
</templates>
</provider>
</events>
</instrumentation>
<localization>
<resources culture="en-US">
<stringTable>
<string id="event_CalledService" value="%1 length:
%2"/>
<string id="event_CallService" value="%1"/>
<string id="event_ServiceError" value="%1 error:
%2"/>
<string id="keyword_Database" value="Database"/>
<string id="keyword_Diagnostics"
value="Diagnostics"/>
<string id="keyword_Network" value="Network"/>
<string id="keyword_Performance"
value="Performance"/>
<string id="keyword_Session0" value="Session0"/>
<string id="keyword_Session1" value="Session1"/>
<string id="keyword_Session2" value="Session2"/>
<string id="keyword_Session3" value="Session3"/>
<string id="task_CalledService"
value="CalledService"/>
<string id="task_CallService" value="CallService"/>
<string id="task_CreateMenus" value="CreateMenus"/>
<string id="task_EventSourceMessage"
value="EventSourceMessage"/>
<string id="task_QueryMenus" value="QueryMenus"/>
<string id="task_ServiceError" value="ServiceError"/>
</stringTable>
</resources>
</localization>
</instrumentationManifest>
Having this metadata and registering it with the system allows the
system administrator to filter for specific events and get notifications
when something happens. You can handle registration in two ways:
static and dynamic. Static registration requires administrative
privileges, and a registration via the wevtutil.exe command-line tool,
which passes the DLL that contains the manifest. The EventSource
class also offers the preferred dynamic registration. This happens
during runtime without the need for administrative privileges
returning the manifest in an event stream, or in a response to a


standard ETW command.
Using Activity IDs
A new feature of the new version of TraceSource makes it possible to
easily write activity IDs. As soon as you have multiple tasks running, it
helps to know which trace messages belong to each other and not have
the trace message based only on time. For example, when you’re using
tracing with a web application, multiple requests from clients are dealt
concurrently when it is good to know which trace messages belong to
one request. Such issues don’t occur only on the server; the problem is
also in the client application as soon as you’re running multiple tasks,
or when you’re using the C# async and await keywords on calling
asynchronous methods. Different tasks come into play.
When you create a class that derives from TraceSource , all you have to
do to create activity IDs is define methods that are post-fixed with
Start and Stop .
For the sample showing activity IDs in action, a Class Library (.NET
Standard) is created. You can use this library from both .NET
Framework and .NET Core applications.
Previous versions of .NET don’t support the new TraceSource features
for activity IDs. The ProcessingStart and RequestStart methods are
used to start activities; ProcessingStop and RequestStop stop activities
(code file MyApplicationEvents/SampleEventSource ):
public class SampleEventSource : EventSource
{
private SampleEventSource()
: base("Wrox-SampleEventSource") { }
public static SampleEventSource Log = new
SampleEventSource();
public void ProcessingStart(int x) => WriteEvent(1, x);
public void Processing(int x) => WriteEvent(2, x);
public void ProcessingStop(int x) => WriteEvent(3, x);
public void RequestStart() => WriteEvent(4);


public void RequestStop() => WriteEvent(5);
}
The client application that’s writing the events makes use of the
following dependency and namespaces:
Dependency
MyApplicatonEvents
Namespaces
System
System.Collections.Generic
System.Diagnostics.Tracing
System.Net.Http
System.Threading.Tasks
The ParallelRequestSample method invokes the RequestStart and
RequestStop methods to start and stop the activity. Between these
calls, a parallel loop is created using Parallel.For . The Parallel class
uses multiple tasks to run concurrently by calling the delegate of the
third parameter. This parameter is implemented as a lambda
expression to invoke the ProcessTaskAsync method (code file
ClientApp/Program.cs ):
private static void ParallelRequestSample()
{
SampleEventSource.Log.RequestStart();
Parallel.For(0, 20, async x =>
{
await ProcessTaskAsync(x);
});
SampleEventSource.Log.RequestStop();
Console.WriteLine("Activity complete");
}


NOTE
The Parallel class is explained in detail in Chapter 21, “Tasks and
Parallel Programming.”
The method ProcessTaskAsync writes traces using ProcessingStart and
ProcessingStop . Here, an activity is started within another activity. As
you can see from the output analyzing the logs, activities can be
hierarchical (code file ClientApp/Program.cs ):
private static async Task ProcessTaskAsync(int x)
{
SampleEventSource.Log.ProcessingStart(x);
var r = new Random();
await Task.Delay(r.Next(500));
using (var client = new HttpClient())
{
var response = await
client.GetAsync("http://www.bing.com");
}
SampleEventSource.Log.ProcessingStop(x);
}
Previously, you have used the PerfView tool to open an ETL log file.
PerfView can also analyze running applications. You can run PerfView
with the following option:
> PerfView /onlyproviders=*Wrox-SampleEventSource collect
The option collect starts the data collection. Using the qualifier
/onlyproviders turns off the Kernel and CLR providers and only logs
messages from the providers listed. Use the qualifier -h to see possible
options and qualifiers of PerfView. When you start PerfView this way,
data collection starts immediately and continues until you click the
Stop Collection button (see Figure 29-2).


FIGURE 29-2
When you run the application after you’ve started the trace collection,
and then have stopped the collection afterward, you can see activity
IDs generated with the event type Wrox-
SampleEventSource/ProcessingStart/Start . The IDs allow a hierarchy,
such as //1/2 with one parent activity and a child activity. For every
loop iteration, you see a different activity ID (see Figure 29-3). With
the event type Wrox-SampleEventSource/ProcessingStop/Stop , you can
see the same activity IDs as they relate to the same activity.
FIGURE 29-3
Using PerfView, you can select multiple event types on the left, and
add a filter—for example, //1/1/4 —so you see all the events that
belong to this activity (see Figure 29-4). Here you can see that an
activity ID can span multiple threads. The start and stop events from
the same activity use different threads.


FIGURE 29-4
CREATING CUSTOM LISTENERS
As you’ve written trace messages, you’ve seen how to read them using
tools such as logman, tracerpt, and PerfView. You can also create a
custom in-process event listener to write the events where you want.
You create custom event listeners by creating a class that derives from
the base class EventListener . All you need to do is to override the
OnEventWritten method. With this method, trace messages are passed
to the parameter of type EventWrittenEventArgs . The sample
implementation sends information about the event, including the
payload, which is the additional data passed to the WriteEvent method
of the EventSource (code file ClientApp/MyEventListener.cs ):
public class MyEventListener : EventListener
{
protected override void OnEventSourceCreated(EventSource
eventSource)
{
Console.WriteLine($"created {eventSource.Name}
{eventSource.Guid}");
}
protected override void
OnEventWritten(EventWrittenEventArgs eventData)
{
Console.WriteLine($"event id: {eventData.EventId} source:
" +
$" {eventData.EventSource.Name}");
foreach (var payload in eventData.Payload)
{


Console.WriteLine($"\t{payload}");
}
}
}
The listener is activated in the Main method of the Program class. You
can access event sources by calling the static method GetSources of the
EventSource class (code file ClientApp/Program.cs ):
The InitListener method invokes the EnableEvents method of the
custom listener and passes every event source. The sample code
registers the setting EventLevel.LogAlways to listen to every log
message written. You can also specify to just write information
messages—which also include errors—or to write errors only.
private static void InitListener(IEnumerable<EventSource>
sources)
{
listener = new MyEventListener();
foreach (var source in sources)
{
listener.EnableEvents(source, EventLevel.LogAlways);
}
}
When you run the application, you see events of the
FrameworkEventSource and the Wrox-SampleEventSource written to the
console. Using a custom event listener like this, you can easily write
events to Application Insights, which is a cloud-based telemetry
service that’s explained in the next section.
WRITING LOGS WITH THE ILOGGER INTERFACE
Over the years several different logging and tracing facilities in .NET,
and there also are many different third-party loggers. Trying to change
an application from one logging technology to another one is not an
easy task because the use of the logging API is spread throughout the
source code. To make logging independent of any logging technology,
interfaces can be used.
.NET Core defines the generic ILogger interface in the NuGet package
Microsoft.Extensions.Logging . This interface defines a Log method.


The Log method defines parameters to specify a LogLevel (an
enumeration value), an event ID (using the struct EventId ), generic
state information, an Exception type to log exception information, and
a formatter to define how the output should look with a string:
void Log<TState>(LogLevel logLevel, EventId eventide, TState
state,
Exception exception, Func<TState, Exception, string>
formatter);
Other than the Log method, the ILogger interface also defines the
IsEnabled method to check whether logging is currently enabled based
on a LogLevel , and the method BeginScope that returns a disposable
scope for logging. The members from the ILogger interface are really
all that’s needed for logging. The Log method just has many
parameters that need to be filled. To make logging easier, extension
methods for the ILogger interface are defined in the LoggerExtensions
class. You will see extension methods such as LogDebug , LogTrace ,
LogInformation , LogWarning , LogError , LogCritical , and BeginScope
with several overloads and easier-to-use parameters.
Let’s make use of dependency injection and inject the ILogger
interface using the contained class SampleController as a generic
parameter. The generic parameter defines the category of the logger.
With the generic parameter, the category is made of the class name,
including the namespace (code file
LoggingSample/SampleController.cs ):
class SampleController
{
private readonly ILogger<SampleController> _logger;
public SampleController(ILogger<SampleController> logger)
{
_logger = logger;
}
//...
}
In the section “Filtering” you can read how the category name can be
used to filter the logs.


NOTE
Dependency injection is discussed in detail in Chapter 20,
“Dependency Injection.”
The logging samples make use of the following dependencies and
namespaces:
Dependencies
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Logging
Microsoft.Extensions.Logging.Configuration
Microsoft.Extensions.Logging.Console
Microsoft.Extensions.Logging.Debug
Microsoft.Extensions.Logging.EventSource
Microsoft.Extensions.Logging.Filter
Namespaces
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Logging
Microsoft.Extensions.Logging.Console
System
System.Net.Http
System.Threading.Tasks
The ILogger interface can simply be used to invoke an extension
method such as LogInformation :
_logger.LogInformation("NetworkRequestSample started");


The extension methods offer overloads to pass additional parameters,
exception information, and an event ID. For using the event ID, a list
of constant values is defined with the application (code file
LoggingSample/LoggingEvents.cs ):
class LoggingEvents
{
public const int Injection = 2000;
public const int Networking = 2002;
}
Next, LogInformation and LogError extension methods are used to
show the start of the NetworkRequestSampleAsync method, when it
finishes, and error information when an exception is thrown (code file
LoggingSample/SampleController.cs ):
public async Task NetworkRequestSampleAsync(string url)
{
try
{
_logger.LogInformation(LoggingEvents.Networking,
"NetworkRequestSampleAsync started with url {0}", url);
var client = new HttpClient();
string result = await client.GetStringAsync(url);
_logger.LogInformation(LoggingEvents.Networking,
"NetworkRequestSampleAsync completed, received {0}
characters",
result.Length);
}
catch (Exception ex)
{
_logger.LogError(LoggingEvents.Networking, ex,
"Error in NetworkRequestSampleAsync, error message:
{0}, HResult: {1}",
ex.Message, ex.HResult);
}
}
NOTE
One of the overloaded ILogger extension methods requires EventId


with the first parameter. With the sample code, an int is passed.
This is possible because the EventId struct implements an implicit
operator to convert int to EventId . Operator overloading is
discussed in Chapter 6, “Operators and Casts.”
When you pass the message to the LogXX methods, any number of
objects can be supplied that are put into the format message
string. This format string uses positional arguments to pass in the
following objects. Formattable strings are not used because
format strings often are coming from resources that allow for
localization of these messages. Localization is discussed in
Chapter 27, “Localization.”
Next, logging providers need to be configured to make the log
information available.
Configuring Providers
The location where logs are configured needs to be defined with the
ILoggingBuilder . The ILoggingBuilder can be configured when you
invoke the AddLogging extension method for the IServiceCollection —
one overload of this method accepts an Action<ILoggingBuilder>
parameter. When you use ILoggingBuilder , you can add providers. The
sample code adds providers for the console, debugs (which shows up
in the Output window with Visual Studio), and adds the event source
(code file LoggingSample/Program.cs ):
static void RegisterServices()
{
var services = new ServiceCollection();
services.AddLogging(builder =>
{
builder.AddEventSourceLogger();
builder.AddConsole();
#if DEBUG
builder.AddDebug();
#endif
//...
});
services.AddScoped<SampleController>();
AppServices = services.BuildServiceProvider();


}
public static IServiceProvider AppServices { get; private
set; }
The Main method of the sample application invokes the
RegisterServices method to register the services in the dependency
injection container, and then it invokes the RunSampleAsync method
(code file LoggingSample/Program.cs ):
private static string s_url =
"https://csharp.christiannagel.com";
static async Task Main(string[] args)
{
if (args.Length == 1)
{
s_url = args[0];
}
RegisterServices();
await RunSampleAsync();
Console.ReadLine();
}
static async Task RunSampleAsync()
{
var controller = AppServices.GetService<SampleController>
();
await controller.NetworkRequestSampleAsync(s_url);
}
When you run the application successfully, you can see these
informational logs on the console output:
info: LoggingSample.SampleController[2002]
NetworkRequestSampleAsync started with url
https://csharp.christiannagel.com
info: LoggingSample.SampleController[2002]
NetworkRequestSampleAsync completed, received 76318
characters
Passing an invalid hostname results in the error information shown
here:
info: LoggingSample.SampleController[2002]
NetworkRequestSampleAsync started with url
https://csharp.christiannagel1.com


fail: LoggingSample.SampleController[2002]
Error in NetworkRequestSampleAsync, error message: An error
occurred
while sending the request., HResult: -2147012889
Using Scopes
With scopes, you can combine log information that belongs with the
output.
A scope can be defined by invoking the BeginScope method and
passing a message to the scope. The message will be shown in the
output with every log message defined within the scope. BeginScope
returns an IDisposable object. Invoking the Dispose method (which is
done in the code sample with the using statement) ends the scope
(code file LoggingScopeSample/SampleController.cs ):
public async Task NetworkRequestSampleAsync(string url)
{
using (_logger.BeginScope("NetworkRequestSampleAsync, url:
{0}", url))
{
try
{
_logger.LogInformation(LoggingEvents.Networking,
"Started");
var client = new HttpClient();
string result = await client.GetStringAsync(url);
_logger.LogInformation(LoggingEvents.Networking,
"Completed with characters {0} received",
result.Length);
}
catch (Exception ex)
{
_logger.LogError(LoggingEvents.Networking, ex,
"Error, error message: {0}, HResult: {1}",
ex.Message, ex.HResult);
}
}
}
With the providers, the scope needs to be enabled to show it. You can
change the configuration of the AddConsole method to set the
IncludeScopes property (code file LoggingScopeSample/Program.cs ):


static void RegisterServices()
{
var services = new ServiceCollection();
services.AddLogging(builder =>
{
builder.AddEventSourceLogger();
builder.AddConsole(options => options.IncludeScopes =
true);
builder.AddDebug();
});
services.AddScoped<SampleController>();
AppServices = services.BuildServiceProvider();
}
When you run the application now, you can see the information you
passed to the scope after the => , as shown in the following code
snippet:
info: LoggingScopeSample.SampleController[2002]
=> NetworkRequestSampleAsync, url:
https://csharp.christiannagel.com
Started
info: LoggingScopeSample.SampleController[2002]
=> NetworkRequestSampleAsync, url:
https://csharp.christiannagel.com
Completed with characters 76395 received
Filtering
You don’t need all log messages at all times. While the application is
running in the production environment, error and critical information
are of interest. As you’re debugging the application, you might change
the configuration to show trace messages for specific trace sources to
learn all the things going on in the application. You can define filters
for the logging needs you have.
Filtering is possible based on the logger provider and based on the log
categories.
The following code snippet defines a filter for the
ConsoleLoggerProvider and the category name LoggingSample to filter
only errors with the log level Error and higher (code file
LoggingSample/Program.cs ):


static void RegisterServices()
{
var services = new ServiceCollection();
services.AddLogging(builder =>
{
builder.AddEventSourceLogger();
builder.AddConsole();
#if DEBUG
builder.AddDebug();
#endif
builder.AddFilter<ConsoleLoggerProvider>("LoggingSample",
LogLevel.Error);
//...
Instead of just specifying the name of the category and the LogLevel ,
you can also pass a delegate with category and LogLevel parameters.
The following code snippet returns a filter value true if the category
name includes SampleController , and the received LogLevel is at least
Information . For all other categories, the filter returns true if the
LogLevel has at least the value Error :
builder.AddFilter<ConsoleLoggerProvider>((category, logLevel)
=>
{
if (category.Contains("SampleController") &&
logLevel >= LogLevel.Information) return true;
else if (logLevel >= LogLevel.Error) return true;
else return false;
});
Configure Logging
Filtering can also be defined by using a configuration file.
With .NET Core, you can use providers for configuration files, such as
reading configuration from JSON or XML files, environment
variables, or command-line arguments. You just need to create a
ConfigurationBuilder from the NuGet package
Microsoft.Extensions.Configuration and add providers to this
builder. To add the JSON provider, you need to invoke the extension
method AddJsonFile . The Build method of the builder returns an
object that implements IConfiguration . You can use this interface to
access configured values with any of the configured providers. With


the sample code, the section Logging is retrieved from the
configuration and passed to the RegisterServices method (code file
LoggingConfigurationSample/Program.cs ):
var configurationBuilder = new ConfigurationBuilder();
configurationBuilder.AddJsonFile("appsettings.json");
IConfiguration configuration = configurationBuilder.Build();
RegisterServices(configuration);
The configuration file of the sample application configures different
configuration values based on providers and categories. For the Debug
provider, the LogLevel is set to Information. With this, for all
categories, Information and up is logged to the Output window of
Visual Studio. With the Console provider, the LogLevel differs based
on categories. Below the configuration of the Console provider, the
default configuration for all other providers is defined with specific log
levels based on categories (configuration file
LoggingConfigurationSample/appsettings.json ):
{
"Logging": {
"Debug": {
"LogLevel": "Information"
},
"Console": {
"LogLevel": {
"LoggingConfigurationSample.SampleController":
"Information",
"Default": "Warning"
}
},
"LogLevel": {
"Default": "Warning",
"System": "Information",
"LoggingConfigurationSample.SampleController":
"Warning"
}
}
}
With the logging configuration in place, now the AddConfiguration
method is invoked to pass a reference to the IConfiguration object.
The AddConfiguration method expects the content of the Logging
section from the configuration file (code file


LoggingConfigurationSample/Program.cs ):
static void RegisterServices(IConfiguration configuration)
{
var services = new ServiceCollection();
services.AddLogging(builder =>
{
builder.AddConfiguration(configuration.GetSection("Logging"))
.AddConsole();
#if DEBUG
builder.AddDebug();
#endif
});
services.AddScoped<SampleController>();
AppServices = services.BuildServiceProvider();
}
Without changing any code, you now have flexibility in defining the
logging configuration.
NOTE
Read more about the architecture of
and using different
configuration providers in Chapter 30, “ASP.NET Core.”
Microsoft.Extensions.Configuration
Using ILogger Without Dependency Injection
Dependency injection has big advantages. However, you can use the
logging API without DI as well. All you need to do is to create a
LoggerFactory and create a logger using the CreateLogger method.
Configuration providers can be added to the logger factory—similar as
they provide extension methods for the ILoggingBuilder interface,
extension methods for the ILoggerFactory are provided as well (code
file LoggingWithoutDI/Program.cs ):
var loggerFactory = new LoggerFactory();
loggerFactory.AddConsole().AddDebug();
ILogger<Program> logger = loggerFactory.CreateLogger<Program>


();
logger.LogInformation("Info Message");
ANALYTICS WITH VISUAL STUDIO APP CENTER
Visual Studio App Center ( https://appcenter.ms ) is Microsoft’s entry
point to build Windows and mobile apps, distribute apps to beta
testers, test apps, extend apps with push notifications, and get user
analytics for apps.
You can get reports of users having issues with your apps—for
example, you can find out about exceptions—and you can also find out
the features users are using from your apps. For example, let’s say you
have added a new feature to your app. Are users finding the button to
activate the feature?
When you use Application Insights, it’s easy to identify issues that
users are having with the app. There’s a good reason Microsoft makes
it easy to integrate Application Insights with all kinds of apps.
NOTE
Here are some examples of features that users had trouble finding
from Microsoft’s own products. The Xbox was the first device to
offer a user interface with large tiles. The search feature was
available directly below the tiles. Although this button was
available directly in front of the user, users didn’t see it. Microsoft
moved the search functionality within a tile, and now users can
find it.
Another example is the physical Search button on the Windows
Phone. This button was meant to be used to search within apps.
Users complained about not having an option to search within
email because they didn’t think to press this physical button to
search for emails. Microsoft changed the functionality. Now the
physical Search button is used only to search content from the
web, and the mail app has its own Search button.


Windows 8 had a similar issue with search; users didn’t use the
search functionality from the Charms bar to search within apps.
Windows 8.1 changed the guideline to use search from the
Charms bar, and now the app contains its own Search box; in
Windows 10 there’s also an auto suggest box. Does it look like
some commonalities?
To enable app analytics, you first need to register with the Visual
Studio App Center. Don’t be afraid of costs that are too high—crash
reporting and analytics are available for free (at the time of this
writing). Next, you need to create an app, and copy the App Secret
from the web portal. Then you can create a new Blank App (Universal
Windows) with Visual Studio. To enable analytics, add the NuGet
package Microsoft.AppCenter.Analytics to the project.
With just a few API calls, you’re can find out issues your users have. In
the constructor of the App class, add AppCenter.Start , and add your
previously copied App Secret. To enable Analytics, you need to pass
the type of the Analytics object as the second argument to the Start
method (code file WinAppAnalytics/App.xaml.cs ):
public App()
{
this.InitializeComponent();
this.Suspending += OnSuspending;
AppCenter.Start("84df09c4-d560-4c46-a44f-a5524c3abb7f",
typeof(Analytics));
}
NOTE
Remember to add your App Secret from your app configuration
in the Visual Studio App Center to the Application.Start method.
Running the application now, you’ll see user information, when users
start the application, and locations as well as devices from users.


To get some more information from users, you need to create calls to
Analytics.TrackEvent . All the possible events from the app are defined
within the class EventNames (code file WinAppAnalytics/EventNames.cs ):
public class EventNames
{
public const string ButtonClicked = nameof(ButtonClicked);
public const string PageNavigation =
nameof(PageNavigation);
public const string CreateMenu = nameof(CreateMenu);
}
The sample application contains controls to enable/disable analytics,
to enter some text, and to click a button (see Figure 29-5). Events are
collected when the MainPage is activated. The TrackEvent method
requires a string for the event name, which is taken from the
EventNames class. The name of the event is not prefixed by the class
name because a using static declaration is used to import the
members of this class. The second argument of the TrackEvent method
is optional. Here you can pass a dictionary of strings to track
additional information. In the sample code, when the page is
navigated to, the PageNavigation event contains information about the
type of the page navigated to (code file
WinAppAnalytics/MainPage.xaml.cs ):
protected override void OnNavigatedTo(NavigationEventArgs e)
{
base.OnNavigatedTo(e);
Analytics.TrackEvent(PageNavigation,
new Dictionary<string, string> { ["Page"] =
nameof(MainPage) });
}


FIGURE 29-5
With the click of the button, TrackEvent tracks the ButtonClick event,
with the information the user entered in the TextBox control:
private void OnButtonClick(object sender, RoutedEventArgs e)
{
Analytics.TrackEvent(ButtonClicked,
new Dictionary<string, string> { ["State"] =
textState.Text });
}
Users might not agree to allow you to collect information as they
wander around your app, so you can create a setting the user can use
to enable and disable this functionality. If you set
Analytics.SetEnabledAsync(false) , the Analytics APIs no longer
report data:
private async void OnAnalyticsChanged(object sender,
RoutedEventArgs e)
{
if (sender is CheckBox checkbox)
{
bool isChecked = checkbox?.IsChecked ?? true;
await Analytics.SetEnabledAsync(isChecked);
}


}
Visual Studio App Center has some limits regarding analytics, as
shown in this list:
You can have only 200 or fewer event names.
The event name is limited to 256 characters.
The dictionary can contain only 5 or fewer properties.
Event property names and event property values are limited to 64
characters.
NOTE
These are the limits at the time of this writing. They might change
with future versions.
When you run the application and monitor the Visual Studio App
Center portal, you can see the events that occurred and the number of
users that were affected (see Figure 29-6). When you click into the
events, you can see event count by user, events per session, and the
details of the dictionary properties passed. You can also see the live
event log flow, as shown in Figure 29-7.


FIGURE 29-6
FIGURE 29-7
Apart from this information, Visual Studio App Center Analytics also
gives you information about the following:
The number of active users
Daily sessions per user
Session duration
Top devices
OS versions used
Languages
SUMMARY
In this chapter, you have looked at tracing and logging facilities that
can help you find intermittent problems in your applications. You
should plan early and build these features into your applications;
doing so will help you avoid many troubleshooting problems later.
With tracing, you can write debugging messages to an application that
you can also use for the final product delivered. If there are problems,
you can turn tracing on by changing configuration values and find the
issues.
With Visual Studio App Center Analytics, you’ve seen that many


features come out of the box when you use this cloud service. You can
easily get information from your users with just a few lines of code. If
you add some more lines, you can find out if users don’t use some
features of the app because they are having trouble finding them.
This was the last chapter of the second part of this book, “.NET Core
and Windows Runtime.” The next part, “Web Applications and
Services,” is based on a lot of features you were introduced to in this
part. The next chapter, “ASP.NET Core,” is where you begin to dig into
web applications and services.