

ASP.NET Core
WHAT’S IN THIS CHAPTER?
Understanding ASP.NET Core and web technologies
Using static content
Working with HTTP request and response
Using dependency injection with ASP.NET
Defining custom simple routing
Creating middleware components
Using sessions for state management
Reading configuration settings
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
http://www.wrox.com on the Download Code tab. The source code is
also available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory aspnetcore .
The code for this chapter contains this example project:
Simple Host
WebSampleApp


CustomConfiguration
ASP.NET CORE
After more than 15 years of ASP.NET, ASP.NET Core was a complete
rewrite of ASP.NET. ASP.NET Core features modular programming,
makes use of modern patterns, is fully open sourced, is lightweight for
best use in the cloud, and is available to non-Microsoft platforms.
A full rewrite of ASP.NET gives a lot of advantages, but this also means
reworking existing web applications based on older versions of
ASP.NET. Is it necessary to rewrite existing web applications to
ASP.NET Core? Let’s try to answer this question.
ASP.NET Web Forms is no longer part of ASP.NET Core. However,
having web applications that include this technology does not mean
you have to rewrite them. It’s still possible to maintain legacy
applications written with ASP.NET Web Forms with the full
framework. ASP.NET Web Forms even received some enhancements
with the latest versions of the .NET Framework, such as asynchronous
model binding.
The ASP.NET MVC variant of ASP.NET is still part of ASP.NET Core,
but it’s different from the previous framework with the .NET
Framework. When doing a high-level comparison of ASP.NET MVC
and ASP.NET Core MVC, the two technologies look very much alike.
However, behind the scenes everything is different. When you transfer
ASP.NET MVC applications to ASP.NET Core MVC, you need to make
some changes to the source code to bring it to the new application
stack. For some applications this might mean making minor changes
to namespaces, types, and some methods. If the application makes use
of more advanced features from ASP.NET MVC, you must do more
work to move the application to the new technology.
Converting ASP.NET Web Forms to ASP.NET Core MVC might be a
lot of work. ASP.NET Web Forms abstracts HTML and JavaScript
from the developer. Using ASP.NET Web Forms, it’s not necessary to
know HTML and JavaScript. Instead you use server-side controls with
C# code. The server-side controls themselves return HTML and


JavaScript. This programming model is like the old Windows Forms
programming model. With ASP.NET MVC, developers need to know
HTML and JavaScript. ASP.NET MVC is based on the Model-View-
Controller (MVC) pattern, which makes unit testing easy. Because
ASP.NET Web Forms and ASP.NET MVC are based on very different
architecture patterns, it can be a huge undertaking to migrate
ASP.NET Web Forms applications to ASP.NET MVC. Before taking on
this task, you should create a checklist of the advantages and the
disadvantages of keeping the old technology with your solution and
compare this with the advantages and disadvantages of going to the
new technology. You will still be able to work with ASP.NET Web
Forms for many years to come.
**NOTE**
My website at http://www.cninnoation.com was originally created
with ASP.NET Web Forms. I’ve converted this website with an
early version of ASP.NET MVC to this new technology stack.
Because my original site already made use of a lot of separate
components to abstract the database and service code, it was not
really a huge undertaking and was done very fast. I was able to
use the database and service code directly from ASP.NET MVC.
On the other hand, if I had used Web Forms controls to access the
database instead of using my own controls, it would have been a
lot more work. Nowadays, this web application is implemented
with ASP.NET Core.
**NOTE**
This book does not cover the legacy technology ASP.NET Web
Forms. ASP.NET MVC also is not covered. This book has a focus
on new technologies; consequently, the material about web
applications is based on ASP.NET Core and ASP.NET Core MVC.
You should use these technologies for new web applications. In


case you need to maintain older applications, you should read
older editions of this book, such as Professional C# 5.0 and .NET
4.5.1, which covers ASP.NET 4.5, ASP.NET Web Forms 4.5, and
ASP.NET MVC 5.
This chapter covers the foundation of ASP.NET Core 2.0. Chapter 31
covers ASP.NET Core MVC, a framework that is built on top of
ASP.NET Core. Chapter 32 covers creating a web API with ASP.NET
Core MVC.
WEB TECHNOLOGIES
Before getting into the foundations of ASP.NET Core later in this
chapter, this section describes core web technologies that are
important to know when creating web applications: HTML, CSS,
JavaScript, scripting libraries.
HTML
HTML is the markup language that is interpreted by web browsers. It
defines elements to display various headings, tables, lists, and input
elements such as text and combo boxes.
HTML5 has been a W3C recommendation since October 2014
( http://w3.org/TR/html5 ), and it is offered by all the major browsers.
You can find lists of work in progress at http://w3.org/TR/html . At the
time of this writing, HTML 5.2 has been a W3C recommendation since
December 2017. With the features of HTML 5, several browser add-ins
(such as Flash and Silverlight) are not required anymore because the
things the add-ins do can now be done directly with HTML and
JavaScript. Of course, you might still need Flash and Silverlight
because not all websites have moved to the new technologies or your
users might still be using older browser versions that don’t support
HTML 5.
HTML 5 adds new semantic elements that search engines are better
able to use for analyzing the site. A canvas element enables the
dynamic use of 2D shapes and images, and video and audio elements


make the object element obsolete. With recent additions to the media
source ( http://w3c.github.io/media-source ), adaptive streaming is
also offered by HTML; previously this had been an advantage of
Silverlight.
HTML 5 also defines JavaScript APIs for drag-and-drop, storage, web
sockets, and much more.
CSS
Whereas HTML defines the content of web pages, CSS defines the
look. In the earlier days of HTML, for example, the list item tag <li>
defined whether list elements should be displayed with a circle, a disc,
or a square. Nowadays such information is completely removed from
HTML and is instead put into a cascading style sheet (CSS).
With CSS styles, you can use flexible selectors to select HTML
elements, and you can define styles for these elements. You can select
an element via its ID or its name, and you can define CSS classes that
can be referenced from within the HTML code. With newer versions of
CSS, you can define quite complex rules for selecting specific HTML
elements.
As of Visual Studio 2017, some web project templates make use of
Twitter Bootstrap. This is a collection of CSS and HTML conventions,
and you can easily adapt different looks and download ready-to-use
templates. Visit www.getbootstrap.com for documentation and basic
templates.
JavaScript and TypeScript
Not all platforms and browsers can use .NET code, but nearly every
browser understands JavaScript. One common misconception about
JavaScript is that it has something to do with Java. In fact, only the
name is similar because Netscape (the originator of JavaScript) made
an agreement with Sun (Sun invented Java) to be allowed to use Java
in the name. Nowadays, neither of these companies exist. Sun was
bought by Oracle, and now Oracle holds the trademark for Java.
Both Java and JavaScript (and C#) have the same roots——the C


programming language. JavaScript is a functional programming
language that is not object-oriented, although object-oriented
capabilities have been added to it.
JavaScript enables accessing the document object model (DOM) from
the HTML page, which makes it possible to change elements
dynamically on the client.
ECMAScript is the standard that defines the current and upcoming
features of the JavaScript language. Because other companies are not
allowed to use the term Java with their language implementations, the
standard has the name ECMAScript. Microsoft’s implementation of
JavaScript had the name JScript. Check
https://tc39.github.io/ecma262/ for the current state and future
changes of the JavaScript language.
Even though many browsers don’t support the newest ECMAScript
version, you can still write ECMAScript 2018 code. Instead of writing
JavaScript code, you can use TypeScript. The TypeScript syntax is
based on ECMAScript, but it has some enhancements, such as strongly
typed code and annotations. You’ll find many similarities between C#
and TypeScript. Because the TypeScript compiler compiles to
JavaScript, TypeScript can be used in every place where JavaScript is
needed. For more information on TypeScript, check
http://www.typescriptlang.org .
Scripting Libraries
Beside the JavaScript programming language, you also need scripting
libraries to make life easier. Scripting libraries can be used with the
server-side functionality of ASP.NET Core.
jQuery ( http://www.jquery.org ) is a library that abstracts browser
differences when accessing DOM elements and reacting to events.
A few years ago, this library was used with nearly every website.
Nowadays, more options are available, and you can’t expect to have
jQuery available everywhere.
Angular ( https://angular.io ) is a library from Google based on the
MVC pattern for simplifying development and testing with single-


page web applications. (Unlike ASP.NET MVC, Angular offers the
MVC pattern with client-side code.)
React ( https://reactjs.org ) is a library from Facebook that offers
functionality to easily update user interfaces as data changes in the
background.
ASP.NET Core 2.0 templates for Visual Studio include templates for
Angular and React. Visual Studio 2017 supports IntelliSense and
debugging JavaScript code.
**NOTE**
Styling web applications and writing JavaScript code is not
covered in this book. You can read more about HTML and styles
in HTML and CSS: Design and Build Websites by John Duckett
(John Wiley & Sons, 2011); and get up to speed with Beginning
JavaScript, Fifth Edition by Jeremy McPeak (Wrox, 2015).
ASP.NET WEB PROJECT
Start by creating an empty ASP.NET Core 2.0 web application. The
first application is a simple host that does nothing more than answer
requests. You start with a new ASP.NET Core web application and
select the Empty template (see Figure 30-1). However, for the first
sample, empty is not empty enough. Delete the file Startup.cs and the
directory wwwroot from the template.
The Main method is simplified to invoke the Start method of the
WebHost class. This method has a parameter of RequestDelegate .
RequestDelegate is a delegate that receives an HttpContext as
parameter and returns a Task . The HttpContext can be used to read the
request from the client and send a return. With the sample code, a
response containing an HTML string is returned (code file
SimpleHost/Program.cs ):
using Microsoft.AspNetCore;


using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
namespace SimpleHost
{
public class Program
{
public static void Main()
{
WebHost.Start(async context =>
{
await context.Response.WriteAsync("<h1>A Simple Host!
</h1>");
}).WaitForShutdown();
}
}
}
FIGURE 30-1
When you run the application, you can see the HTML content in the
browser.
Creating a web host with ASP.NET Core is extremely simple, but now


we get into a more complex scenario to see the features. The next
application is named WebSampleApp and is created with the same Empty
template.
After you’ve created the project, you see a solution and a project file
named WebSampleApp , which includes a few files and folders (see Figure
30-2).
FIGURE 30-2
Within the project structure, you can see a Dependencies folder. This
contains a NuGet subfolder that includes NuGet packages. With
ASP.NET Core 2.0, the package list has been simplified, and you see
only the reference package Microsoft.AspNetCore.All . This is a
reference package that includes a whole bunch of ASP.NET Core
packages. You can see the list of packages that are referenced by
opening Microsoft.AspNetCore.All in Solution Explorer.
In the project file you also can see the reference to this package. The
project file lists the project SDK (Software Development Kit) with
Microsoft.NET.Sdk.Web . This makes use of the SDK installed on the
system. This entry is different from console applications where the
SDK is Microsoft.NET.Sdk . With the Web SDK, additional tools for web
development are available (project file WebSampleApp.cspoj ):
<Project Sdk="Microsoft.NET.Sdk.Web">


<PropertyGroup>
<TargetFramework>netcoreapp2.0</TargetFramework>
</PropertyGroup>
<ItemGroup>
<Folder Include="wwwroot\" />
</ItemGroup>
<ItemGroup>
<PackageReference Include="Microsoft.AspNetCore.All"
Version="2.0.0" />
</ItemGroup>
</Project>
You can configure the web server that is used while developing with
Visual Studio with the Debug option in Project settings (see Figure 30-
3). By default, IIS Express is configured with the port number
specified with the Debug settings. IIS Express derives from Internet
Information Server (IIS) and offers all the core features of IIS. This
makes it easy to develop the web application in practically the same
environment where the application will be hosted later (if IIS is used
for hosting).
To run the application with the Kestrel server, you can select the
profile with the name of the project with the Debug Project settings.
The settings that you change with the Visual Studio project settings
influence the configuration of the launchSettings.json file. With this
file you can define some additional configurations such as command
line arguments (code file
WebSampleApp/Properties/launchsettings.json ):
{
"iisSettings": {
"windowsAuthentication": false,
"anonymousAuthentication": true,
"iisExpress": {
"applicationUrl": "http://localhost:19879/",
"sslPort": 0
}
},
"profiles": {
"IIS Express": {
"commandName": "IISExpress",


"launchBrowser": true,
"environmentVariables": {
"Hosting:Environment": "Development"
}
},
"web": {
"commandName": "web",
"launchBrowser": true,
"launchUrl": "http://localhost:5000/",
"commandLineArgs": "Environment=Development",
"environmentVariables": {
"Hosting:Environment": "Development"
}
}
}
}
FIGURE 30-3


**NOTE**
The Kestrel server was developed by the ASP.NET Core team to
provide simple hosting with ASP.NET Core. When hosting the web
application with IIS, IIS forwards requests to the Kestrel server.
This is like web applications that are hosted with the Apache
server on Linux——the request is forwarded to the Kestrel server.
Starting with ASP.NET Core 2.0, the Kestrel server is supported
for public-facing use, so you can directly host the web application
in the Kestrel server and have it reachable from port 80.
The Dependencies folder in the project structure in Solution Explorer
shows the dependencies on the JavaScript libraries. When you create
an empty project, this folder is empty. You add dependencies later in
this chapter in the section “Adding Static Content.”
The wwwroot folder is the folder for static files that need to be published
to the server. Currently, this folder is empty, but as you work through
this chapter you add HTML and CSS files and JavaScript libraries.
A C# source file—— Startup.cs ——is included with an empty project as
well. This file is discussed next.
During the creation of the project, these namespaces are needed:
Microsoft.AspNetCore.Builder;
Microsoft.AspNetCore.Hosting;
Microsoft.AspNetCore.Http;
Microsoft.Extensions.Configuration
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Logging
Microsoft.Extensions.PlatformAbstractions
Newtonsoft.Json


System
System.Collections.Generic
System.Globalization
System.Linq
System.Text
System.Text.Encodings.Web
System.Threading.Tasks
Startup
It’s time to start to get some functionality out of the web application.
To get information about the client and return a response, you need to
write a response to the HttpContext .
The empty ASP.NET web application template creates a Main method
in the Program class that contains the following code (code file
WebSampleApp/Program.cs ):
public class Program
{
public static void Main(string[] args)
{
BuildWebHost(args).Run();
}
public static IWebHost BuildWebHost(string[] args) =>
WebHost.CreateDefaultBuilder(args)
.UseStartup<Startup>()
.Build();
}
The CreateDefaultBuilder returns an object that implements
IWebHostBuilder , which set up the following functionality:
It configures Kestrel as the web server to be used.
The root path for the content is set to the current directory.
Configurations are defined to load configuration from the file


appsettings.json .
An additional JSON configuration file is added with different
names based on the environment: appsettings.
{environmentname}.json
The configuration from user secrets is read when the environment
name is Development .
The configuration settings providers are configured to load settings
from environment variables and the command line.
The logger factory is configured to log to the console and the debug
output window.
IIS integration is enabled.
**NOTE**
User secrets are discussed in Chapter 24, “Security.”
When you use the IWebHostBuilder returned from
CreateDefaultBuilder , the UseStartup method is invoked. This method
defines the Startup class that will be instantiated and the methods that
will be invoked when you run the web host.
The UseStartup method is implemented as a fluent API and returns
IWebHostBuilder again. IWebHostBuilder can be used to configure
additional services that are needed before the Startup class, and to
define additional configuration providers.
The Build method is the final method in the chain to set up the web
host. This method builds the host to run the application and returns
the IWebHost interface. You can use this interface to access the
dependency injection container using the Services property, and you
can access hosting server features from the ServerFeatures property.
IServerAddressesFeature is one server feature that you can use to
retrieve the addresses of the host. Calling the Start method starts the
listening on the socket for the configured ports.


**NOTE**
Dependency injection and the .NET Core dependency injection
container Microsoft.Extensions.DependencyInjection are
discussed in Chapter 20, “Dependency Injection.”
The empty ASP.NET web application template creates a Startup class
that contains the following code:
//...
using
using
using
using
Microsoft.AspNetCore.Builder;
Microsoft.AspNetCore.Hosting;
Microsoft.AspNetCore.Http;
Microsoft.Extensions.DependencyInjection;
namespace WebSampleApp
{
public class Startup
{
public void ConfigureServices(IServiceCollection
services)
{
}
public void Configure(IApplicationBuilder app,
IHostingEnvironment env)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
app.Run(async (context) =>
{
await context.Response.WriteAsync("Hello World!");
});
}
}
}
Because the Startup class is passed to the UseStartup method with a
generic template parameter, in turn the methods ConfigureServices


and Configure are invoked.
You can use the ConfigureServices method to configure services in the
dependency injection container. This method has a
IServiceCollection property that contains all the services already
registered in the Main method, and it allows you to add additional
services. IServiceCollection derives from the base interface IList<T>
with a ServiceDescriptor as generic parameter and thus allows not
only read services but also add services.
The Configure method receives parameters via dependency injection.
The parameters defined in the template are of type
IApplicationBuilder and IHostingEnvironment .
The interface IHostingEnvironment allows you to access the name of
the environment ( EnvironmentName ), the root path for the content (the
directory of the sources), and the root path for the web content files
(the subdirectory wwwroot ). The default provider that accesses these
directories is the PhysicalFileProvider . With a different provider, the
content can be served from other sources——for example, from a
database. Within the implementation of the Configure method, the
IHostingEnvironment is used to check whether the current
environment is Development by invoking the extension method
IsDevelopment . Only in this environment are exceptions shown.
Because of security issues, in the production environment the user
doesn’t see detail information on the exception.
The IApplicationBuilder interface is used to add middleware to the
HTTP request pipeline. When you invoke the Use method of this
interface, you can build the HTTP request pipeline to define what
should be done in answer to a request. The Use method is
implemented using fluent API, and it again returns an
IApplicationBuilder . With this, multiple middleware objects can
easily be added to the pipeline. Several extension methods exist that
make it easier to add middleware. Later in this chapter, in the section
“Using Middleware,” you can create custom middleware and add it to
the pipeline.
The Run method is an extension method for the interface
IApplicationBuilder and returns void . Thus, it registers the last


middleware in the request pipeline. The parameter of the Run method
is a delegate of type RequestDelegate . This type receives an
HttpContext as a parameter, and it returns a Task . With the
HttpContext (the context variable in the code snippet), you have access
to the request information from the browser (HTTP headers, cookies,
and form data) and can send a response. The generated code returns a
simple string——Hello, World!——to the client, as shown in Figure 30-4.
FIGURE 30-4
**NOTE**
If you’re using Microsoft Edge for testing the web application, you
need to enable localhost. Type about:flags in the URL box and
enable the Allow Localhost Loopback option (see Figure 30-5).
Instead of using the built-in user interface of Microsoft Edge to set
this option, you can also use a command line option: the utility
CheckNetIsolation. The command CheckNetIsolation
LoopbackExempt -a -n=Microsoft.MicrosoftEdge_8wekyb3d8bbwe
enables localhost similarly to using the friendlier user interface
for Microsoft Edge. The utility CheckNetIsolation is useful if you
want to configure other Windows apps to allow localhost.


FIGURE 30-5
Sample Application
The sample application contains an entry page where all the features
shown by the application can easily be accessed using HTML links:
app.Run(async (context) =>
{


string[] lines = new[]
{
@"<ul>",
@"<li><a href=""/hello.html"">Static Files</a> -
requires " +
@"UseStaticFiles</li>",
@"<li>Request and Response",
@"<ul>",
@"<li><a href=""/RequestAndResponse"">Request and
Response</a></li>",
@"<li><a
href=""/RequestAndResponse/header"">Header</a></li>",
@"<li><a href=""/RequestAndResponse/add?
x=38&y=4"">Add</a></li>",
//...
@"</ul>",
@"</li>",
@"</ul>"
};
var sb = new StringBuilder();
foreach (var line in lines)
{
sb.Append(line);
}
string html = sb.ToString().HtmlDocument("Web Sample App");
await context.Response.WriteAsync(html);
});
The HTMLExtensions class is defined to create some specific HTML and
reduce the HTML code needed to write. This class defines extension
methods to create div , span , and li elements (code file
WebSampleApp/HtmlExtensions.cs ):
public static class HtmlExtensions
{
public static string Div(this string value) =>
$"<div>{value}</div>";
public static string Span(this string value) =>
$"<span>{value}</span>";
public static string Div(this string key, string value) =>
$"{key.Span()}: {value.Span()}".Div();


public static string Li(this string value) =>
$@"<li>{value}</li>";
public static string Li(this string value, string url) =>
$@"<li><a href="{url}">{value}</a></li>";
public static string Ul(this string value) =>
$"<ul>{value}</ul>";
public static string HtmlDocument(this string content,
string title)
{
var sb = new StringBuilder();
sb.Append("<!DOCTYPE HTML>");
sb.Append("<head><meta charset=\"utf-8\"><title>{title}
</title></head>");
sb.Append("<body>");
sb.Append(content);
sb.Append("</body>");
return sb.ToString();
}
}
ADDING CLIENT-SIDE CONTENT
Usually you don’t want to just send simple strings to the client. By
default, simple HTML files and other static content can’t be sent.
ASP.NET Core reduces the overhead as much as possible. Even static
files are not returned from the server if you do not enable them.
To enable static files served from the web server, you can add the
extension method UseStaticFiles to add the required middleware
(code file WebSampleApp/Startup.cs ):
public void Configure(IApplicationBuilder app,
IHostingEnvironment env)
{
/...
app.UseStaticFiles();
app.Run(async (context) =>
{
await context.Response.WriteAsync("Hello World!");
});


}
The folder where you add static files is the wwwroot folder within the
project. Let’s add static content by adding a simple HTML file to the
wwwroot folder (code file WebSampleApp/wwwroot/Hello.html ), as shown
here:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>ASP.NET Core Sample</title>
</head>
<body>
<h1>Hello, ASP.NET with Static Files</h1>
</body>
</html>
Now you make a request to the HTML file from the browser after
starting the server——for example, http://localhost:32146/Hello.html .
Depending on the configuration you are using, the port number might
differ for your project. If you uncomment the extension method
UseStaticFiles , the HTML file is not returned from the request.
**NOTE**
When creating web applications with ASP.NET Core, you also
need to know HTML, CSS, JavaScript, and some JavaScript
libraries. As this book’s focus is C# and .NET Core, the content for
these topics is kept to a minimum. I just cover the most important
tasks you need to know with ASP.NET Core.
Using Tools for Client Content
To create content for the client, you also need some tools. With the
older version of ASP.NET, everything was integrated within Visual
Studio. JavaScript libraries could be downloaded and installed in the
project using NuGet packages. However, because communities around


script libraries typically don’t use the NuGet server, they also don’t
create NuGet packages for JavaScript libraries. Instead of NuGet,
communities around JavaScript libraries use servers with functionality
like NuGet.
Microsoft and the community around NuGet were building NuGet
packages for JavaScript libraries to have them available with Visual
Studio. This always generated some delay, and often the experience of
using Visual Studio was not the best in the web world.
Many tools and libraries to develop web applications offer command-
line interfaces. This is now also true for the .NET Core CLI. You’ve
already seen the dotnet command for creating applications, and you
also used some extensions, such as dotnet user-secrets (Chapter 24,
“Security”) and dotnet ef (Chapter 26, “Entity Framework Core”).
This experience fits now a lot better with the tools used to create web
applications. On the other hand, Visual Studio offers a great
integration of some web tools.
What tools are needed to develop the client part of the web
application?
Tools to download packages
Tools to process compile or transpile source files (for example,
TypeScript to JavaScript)
Tools to analyze source files
Tools for bundling script files
Tools for unit testing
Depending on the templates you use, different tools are integrated to
use the source code. For example, if you create an ASP.NET Core MVC
web application using the template from the dotnet CLI, these tools
are integrated in the project:
Bower is for downloading JavaScript libraries
( https://www.bower.io ).
Bundler and Minifier is a Visual Studio extension from Mads
Kristensen to bundle and minify JavaScript and CSS files, see more


at https://github.com/madskristensen/BundlerMinifier .
When you create a new Angular project with Visual Studio or the
dotnet CLI, you see these tools and libraries to be used:
npm to download JavaScript packages ( https://www.npmjs.com )
tsc (the TypeScript compiler) to transpile TypeScript files to
JavaScript ( https://www.typescriptlang.org )
Jasmine, a JavaScript testing framework
( https://jasmine.github.io /)
Karma, a test runner to test JavaScript code ( http://karma-
runner.github.io/1.0/index.html )
Chai, which is an assertion library for unit tests
( http://chaijs.com /)
webpack, a module bundler to package, bundle, and load
JavaScript libraries ( https://webpack.js.org /)
You are not restricted to using the tools from the templates. You can
customize the code and project configuration to use the tools that best
fit your way of work.
Using Client-Side Libraries with Bower
.NET packages are available from the NuGet server. With .NET Core,
JavaScript libraries are no longer available on this server. The
JavaScript community uses other servers and is more agile on
changing the server. When Visual Studio 2015 was released, nearly all
client-side JavaScript libraries had been available on the Bower server.
That’s why Microsoft built integration with Bower like NuGet into
Visual Studio. At that time, scripting libraries for use on the server
usually have been available on the npm (Node Package Manager)
server ( https://www.npmjs.com ). Today, not only the scripting libraries
used on the server but also the scripting libraries used on the client are
available on the npm server.
With .NET projects, NuGet packages are managed in the csproj
project file. When using packages from the Bower server, the Visual


Studio item template Bower Configuration File adds the file
bower.json to the project.
When you select the bower configuration file in Solution Explorer, you
can manage bower packages and open the package manager that looks
like the NuGet package manager (see Figure 30-6). You can browse
and search for packages, install specific versions, and update packages
in a way that’s like using the NuGet package manager.
FIGURE 30-6
Installing Bootstrap via the Bower package manager adds a reference
to bootstrap to the bower configuration file (configuration file
WebSampleApp/bower.json ):
{
"name": "asp.net",
"private": true,
"dependencies": {


"bootstrap": "v3.3.7"
}
}
Bower dependencies show up within the Dependencies list in the
Solution Explorer as well. The package is automatically downloaded to
wwwroot/lib . The location where the package is downloaded is
specified by the .bowerrc file:
{
"directory": "wwwroot/lib"
}
When you use bower from the command line, you can install the
bower command-line utility with npm:
> npm install -g bower
You also can install packages, which writes the packages to the
bower.json file:
> bower install jquery
Using a JavaScript Package Manager: npm
Today, the host of the Node Package Manager (npm) not only serves
server-side JavaScript libraries but most of the client-side JavaScript
libraries also are available from the npm server.
**NOTE**
With the Visual Studio Installer, you can install the Node Package
Manager as optional component. You can also get it directly from
https://nodejs.org/ .
Using Visual Studio 2017, you can add npm to the project by adding
the NPM Configuration File from the item templates. When you add
the item template, the following package.json file is added to the
project:


{
"version": "1.0.0",
"name": "ASP.NET",
"private": "true",
"devDependencies": {
}
}
is the section for the libraries that are needed only
during development. The section dependencies is for libraries needed
during runtime; these need to be deployed on the production server.
devDependencies
You can add libraries with their version to the corresponding section
within package.json . Visual Studio offers IntelliSense and contacts the
package server to get package names and available versions.
Alternatively, you can use the npm command line to add packages——for
example, as shown with the following command-line statement in
which the option --save writes the dependency to the package.json
file:
> npm install @angular/core --save
When you select the version number in the Visual Studio editor, you
can select between ^ and ~ prefixes. Without a prefix, the version of the
library with the exact name you typed is retrieved from the server.
With the ^ prefix, the latest library with the same major version
number is retrieved; with the ~ prefix, the latest library with the same
minor version number is retrieved.
After the packages are added, you can easily update or uninstall the
package using the npm node within the Dependencies section in
Solution Explorer.
Bundling
Returning JavaScript and CSS files to the browser should be different
in a production environment than in the development environment.
Comments and whitespaces can be removed——a process known as
minifying——and multiple files can be combined to one——which is
known as bundling. Both minifying and bunding increases the
performance. Minifying reduces the file size. Bundling reduces the


number of network transfers.
One option for bunding is the Visual Studio 2017 integrated Bundler
and Minifier. All you need to do is add a bundleconfig.json file (which
is automatically added from the ASP.NET Core MVC project template)
as shown in the following snippet. This file contains sections with
outputFileName and inputFiles directives. The input files are minified
and bundled to create one output file. You can add all your CSS files to
bundle into one CSS file, and the JavaScript files of your project to
bundle into one JavaScript file:
[
{
"outputFileName": "wwwroot/css/site.min.css",
// An array of relative input file paths. Globbing
patterns supported
"inputFiles": [
"wwwroot/css/site.css"
]
},
{
"outputFileName": "wwwroot/js/site.min.js",
"inputFiles": [
"wwwroot/js/site.js"
],
// Optionally specify minification options
"minify": {
"enabled": true,
"renameLocals": true
},
// Optionally generate .map file
"sourceMap": false
}
]
Packaging with webpack
As previously mentioned, webpack is a modern (at the time of this
writing) way to package web projects. Using the ASP.NET Core
template for Angular makes use of webpack and creates the file
webpack.config.js to configure webpack for the web application. In
this file you can find bundle configuration to bundle JavaScript and
CSS files.


For starting webpack also check the .NET project file csproj . With the
Angular project AngularWithDotnetCore , this file contains the
DebugRunWebpack task that runs before a build and executes the webpack
JavaScript file:
<Target Name="DebugRunWebpack" BeforeTargets="Build"
Condition=" '$(Configuration)' == 'Debug' And
!Exists('wwwroot\dist') ">
<!-- Ensure Node.js is installed -->
<Exec Command="node --version" ContinueOnError="true">
<Output TaskParameter="ExitCode" PropertyName="ErrorCode"
/>
</Exec>
<Error Condition="'$(ErrorCode)' != '0'"
Text="Node.js is required to build and run this project.
To continue,
please install Node.js from https://nodejs.org/, and then
restart your command
prompt or IDE." />
<!-- In development, the dist files won't exist on the
first run or when
cloning to a different machine, so rebuild them if not
already present. -->
<Message Importance="high" Text="Performing first-run
Webpack build..." />
<Exec Command="node node_modules/webpack/bin/webpack.js
--config webpack.config.vendor.js" />
<Exec Command="node node_modules/webpack/bin/webpack.js" />
</Target>
You use the task PublishRunWebpack where npm modules are installed,
and webpack is started with minifying and bundling:
<Target Name="PublishRunWebpack"
AfterTargets="ComputeFilesToPublish">
<!-- As part of publishing, ensure the JS resources are
freshly built in
production mode -->
<Exec Command="npm install" />
<Exec Command="node node_modules/webpack/bin/webpack.js --
config
webpack.config.vendor.js --env.prod" />
<Exec Command="node node_modules/webpack/bin/webpack.js --
env.prod" />


<!-- Include the newly-built files in the publish output --
>
<ItemGroup>
<DistFiles Include="wwwroot\dist\**; ClientApp\dist\**"
/>
<ResolvedFileToPublish Include="@(DistFiles->'%
(FullPath)')"
Exclude="@(ResolvedFileToPublish)">
<RelativePath>%(DistFiles.Identity)</RelativePath>
<CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
</ResolvedFileToPublish>
</ItemGroup>
</Target>
REQUEST AND RESPONSE
With the HTTP protocol, the client sends an HTTP request to the
server. This request is answered with an HTTP response.
The request consists of a header and, in many cases, body information
to the server. The server uses the header information to know about
the needs of the client and can send different results based on this
information. Let’s have a look at what information is sent by the client.
To return an HTML-formatted output to the client, the Span and Div
methods create an HTML div element that contains HTML span
elements with the passed arguments key and value (code file
WebSampleApp/HtmlExtensions.cs ):
public static string Span(this string value) =>
$"{value}";
public static string Div(this string key, string value) =>
$"{key.Span()}:&nbsp;{value.Span()}".Div();
The method GetRequestInformation uses an HttpRequest object to
access Scheme , Host , Path , QueryString , Method , and Protocol properties
(code file WebSampleApp/RequestAndResponseSamples.cs ):
public static string GetRequestInformation(HttpRequest
request)
{


var sb = new StringBuilder();
sb.Append("scheme".Div(request.Scheme));
sb.Append("host".Div(request.Host.HasValue ?
request.Host.Value :
"no host"));
sb.Append("path".Div(request.Path));
sb.Append("query string".Div(request.QueryString.HasValue ?
request.QueryString.Value : "no query string"));
sb.Append("method".Div(request.Method));
sb.Append("protocol".Div(request.Protocol));
return sb.ToString();
}
All the requests to demonstrate the sample code of this section are
served passing the path /RequestAndResponse to the server. That’s why
the Map method is defined in the Configure method of the Startup
class:
app.Map("/RequestAndResponse", app1 =>
{
app1.Run(async context =>
{
//...
}
}
**NOTE**
Routing using the Map method is explained later in this chapter in
the section “Simple Routing.”
The implementation of the Run method invokes the
GetRequestInformation method and pass the HttpRequest via the
Request property of the HttpContext . The result is written to the
Response object (code file WebSampleApp/Startup.cs ):
app1.Run(async context =>
{
await context.Response.WriteAsync(
RequestAndResponseSample.GetRequestInformation(context.Request));


});
Starting the program and accessing
http://localhost:32146/RequestAndResponse/
results in the following
information:
scheme: http
host: localhost:32146
path: /
query string: no query string
method: GET
protocol: HTTP/1.1
Adding a path, such as
http://localhost:32146/RequestAndResponse/Index ,
to the request
results in the path value set:
scheme:http
host:localhost:32146
path: /Index
query string: no query string
method: GET
protocol: HTTP/1.1
When you add a query string, such as
http://localhost:32146/RequestAndResponse/Sub?x=3&y=5 ,
string accessing the property QueryString shows up:
the query
query string: ?x=3&y=5
In the next code snippet, you use the Path property of the HttpRequest
to create a lightweight custom routing. Depending on the path that is
set by the client, different methods are invoked (code file
WebSampleApp/Startup.cs ):
app.Run(async (context) =>
{
context.Response.ContentType = "text/html";
string result = string.Empty;
switch (context.Request.Path.Value.ToLower())
{
case "/header":
result =
RequestAndResponseSamples.GetHeaderInformation(context.Request);


break;
case "/add":
result =
RequestAndResponseSamples.QueryString(context.Request);
break;
case "/content":
result =
RequestAndResponseSamples.Content(context.Request);
break;
case "/encoded":
result =
RequestAndResponseSamples.ContentEncoded(context.Request);
break;
case "/form":
result =
RequestAndResponseSamples.GetForm(context.Request);
break;
case "/writecookie":
result =
RequestAndResponseSamples.WriteCookie(context.Response);
break;
case "/readcookie":
result =
RequestAndResponseSamples.ReadCookie(context.Request);
break;
case "/json":
result =
RequestAndResponseSamples.GetJson(context.Response);
break;
default:
result =
RequestAndResponseSamples.GetRequestInformation(context.Request);
break;
}
await context.Response.WriteAsync(result);
});
The following sections implement the different methods to show
request headers, query strings, and more.
Request Headers
Let’s have a look at what information the client sends within the HTTP
header. To access the HTTP header information, the HttpRequest


object defines the Headers property. This is of type IHeaderDictionary ,
and it contains a dictionary with the name of the header and a string
array for the values. Using this information, the GetDiv method
created earlier is used to write div elements for the client (code file
WebSampleApp/RequestAndResponseSamples.cs ):
public static string GetHeaderInformation(HttpRequest
request)
{
var sb = new StringBuilder();
foreach (var header in request.Headers)
{
sb.Append(header.Key.Div(string.Join("; ",
header.Value)));
}
return sb.ToString();
}
The results you see depend on the browser you’re using. Let’s compare
a few of them. The following is from Internet Explorer 11 on a
Windows 10 touch device:
Connection: Keep-Alive
Accept: text/html,application/xhtml+xml,image/jxr,*.*
Accept-Encoding: gzip, deflate
Accept-Language: en-Us,en;q=0.8,de-AT;q=0.5,de;q=0.3
Host: localhost:32146
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0;
Touch; rv:11.0)
like Gecko
MS-ASPNETCORE-TOKEN: f7fd3899-4436-40a2-b736-1118f43cbef3
X-Original-Proto: http
X-Original-For: 127.0.0.1:8639
Google Chrome version 61.0 shows this information, including version
numbers from AppleWebKit, Chrome, and Safari:
Connection: Keep-Alive
Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,
image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Host: localhost:32146


User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62
Safari/537.36
Upgrade-Insecure-Requests: 1
MS-ASPNETCORE-TOKEN: f7fd3899-4436-40a2-b736-1118f43cbef3
X-Original-Proto: http
X-Original-For: 127.0.0.1:8693
And Microsoft Edge comes with this information, including version
numbers from AppleWebKit, Chrome, Safari, and Edge:
Connection: Keep-Alive
Accept: text/html, application/xhtml+xml, image/jxr, */*
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.8,de-AT;q=0.5,de;q=0.3
Cookie: color=red
Host: localhost:32146
Referer: http://localhost:32146/
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110
Safari/537.36 Edge/16.16299
MS-ASPNETCORE-TOKEN: f7fd3899-4436-40a2-b736-1118f43cbef3
X-Original-Proto: http
X-Original-For: 127.0.0.1:8639
What can you get out of this header information?
The Connection header was an enhancement of the HTTP 1.1 protocol.
With this header the client can request to keep connections open.
Usually with HTML, the client makes multiple requests, e.g. to get the
images, CSS, and JavaScript files. The server might honor the request,
or it might ignore the request in case the load is too high and it’s better
to close the connection.
The Accept header defines the mime formats the browser accepts. The
list is in order by the preferred formats. Depending on this
information, you might decide to return data with different formats
based on the client’s needs. IE prefers HTML followed by XHTML and
JXR. Google Chrome has a different list. It prefers these formats:
HTML, XHTML, XML, and WEBP. With some of this information, a
quantifier is also defined. The browsers used for the output all have
* . * at the end of this list to accept all data returned.
The Accept-Language header information shows the languages the user


has configured. Using this information, you can return localized
information. Localization is discussed in Chapter 29, “Localization.”
**NOTE**
In ancient times, the server kept long lists of browser capabilities.
These lists have been used to know what feature is available with
which browser. To identify a browser, the agent string from the
browser was used to map the capabilities. Over time, browsers
lied by giving wrong information, or they even allowed the user
to configure the browser name that should be used so that they
could get some more features (because browser lists often were
not updated on the server). In the past, Internet Explorer (IE)
often required different programming than all the other
browsers. Microsoft Edge is very different from IE and has more
features in common with other vendors’ browsers. That’s why
Microsoft Edge shows Mozilla, AppleWebKit, Chrome, Safari, and
Edge in the User-Agent string. It’s best not to use this User-Agent
string at all for getting a list of features available. Instead, check
for specific features you need programmatically.
The header information that you’ve seen so far that was sent with the
browser is what is sent for very simple sites. Usually, there will be
more detail, such as cookies, authentication information, and custom
information. To see all the information that is sent to and from a
server, including the header information, you can use the browser’s
developer tools and start a Network session; you’ll see not only all the
requests that are sent to the server but also header, body, parameters,
cookies, and timing information as shown in Figure 30-7.


FIGURE 30-7
Query String
You can use the Add method to analyze the query string. This method
requires x and y parameters, makes an addition if these parameters
are numbers, and returns the calculation within a div tag. The method
GetRequestInformation shown in the previous section demonstrated
how to access the complete query string using the QueryString
property of the HttpRequest object. To access the parts of the query
string, you can use the Query property. The following code snippet
accesses the values of x and y by using the Get method. This method
returns null if the corresponding key is not found in the query string
(code file WebSampleApp/RequestAndResponseSamples.cs ):
public static string QueryString(HttpRequest request)
{


string xtext = request.Query["x"];
string ytext = request.Query["y"];
if (xtext == null || ytext == null)
{
return "x and y must be set".Div();
}
if (!int.TryParse(xtext, out int x))
{
return $"Error parsing {xtext}".Div();
}
if (!int.TryParse(ytext, out int y))
{
return $"Error parsing {ytext}".Div();
}
return $"{x} + {y} = {x + y}".Div();
}
The IQueryCollection returned from the Query string also enables you
to access all the keys using the Keys property, and it offers a
ContainsKey method to check whether a specified key is available.
Using the URL http://localhost:32146/RequestAndResponse/add?
x=39&y=3 shows this result in the browser:
39 + 3 = 42
Encoding
Returning data that has been entered by a user can be dangerous. Let’s
do this with the Content method. The following method directly
returns the data that is passed with the query data string (code file
WebSampleApp/RequestAndResponseSamples.cs ):
public static string Content(HttpRequest request) =>
request.Query["data"];
Invoking this method using the URL
http://localhost:32146/RequestAndResponse/content?data=sample ,
just the string sample is returned. Using the same method, users can
also pass HTML content such as
http://localhost:32146/RequestAndResponse/content?data=


<h1>Heading 1</h1> What’s the result of this? Figure 30-8 shows that
the h1 element is interpreted by the browser, and the text is shown
with the heading format. There are cases where you want to allow this
——for example, when users (maybe not anonymous users) are writing
articles for a site.
FIGURE 30-8
Without checking the user input, it is also possible for the users to pass
JavaScript such as
http://localhost:32146/RequestAndResponse/content?data=
<script>alert("hacker");</script> . You can use the JavaScript
alert
function to make a message box pop up. It’s similarly easy to redirect
the user to a different site. When this user input is stored in the site,
one user can enter such a script, and all other users who open this
page are redirected accordingly.
Returning user-entered data should always be encoded. Let’s have a
look at how the result looks with and without encoding. You can do
HTML encoding using the HtmlEncoder class as shown in the following
code snippet (code file WebSampleApp/RequestResponseSamples.cs ):
public static string ContentEncoded(HttpRequest request) =>
HtmlEncoder.Default.Encode(request.Query["data"]);
When the application is run, the same JavaScript code with encoding
is passed using http://localhost:32146/RequestAndResponse/encoded?
data=<script>alert("hacker");</script> , and the client just sees the
JavaScript code in the browser; it is not interpreted (see Figure 30-9).


FIGURE 30-9
The encoded string that is sent looks like the following example——with
the character reference less-than sign ( <) , greater-than sign ( >) , and
quotation mark ( ") :
Form Data
Instead of passing data from the user to the server with a query string,
you can use the form HTML element. This example uses an HTTP
POST request instead of GET. With a POST request the user data are
passed with the body of the request instead of within the query string.
Using form data is defined with two requests. First, the form is sent to
the client with a GET request and then the user fills in the form and
submits the data with a POST request. The method that is invoked
passing the /form path in turn invokes the GetForm or ShowForm method,
depending on the HTTP method type (code file
WebSampleApp/RequestResponseSamples.cs ):
public static string GetForm(HttpRequest request)
{
string result = string.Empty;
switch (request.Method)
{
case "GET":
result = GetForm();
break;
case "POST":
result = ShowForm(request);
break;
default:
break;
}


return result;
}
The form is created with an input element named text1 and a Submit
button. Clicking the Submit button invokes the form’s action method
with an HTTP method as defined with the method argument:
private static string GetForm() =>
"<form method=\"post\" action=\"form\">" +
"<input type=\"text\" name=\"text1\" />" +
"<input type=\"submit\" value=\"Submit\" />" +
"</form>";
For reading the form data, the HttpRequest class defines a Form
property. This property returns an IFormCollection object that
contains all the data from the form that is sent to the server:
private static string ShowForm(HttpRequest request)
{
var sb = new StringBuilder();
if (request.HasFormContentType)
{
IFormCollection coll = request.Form;
foreach (var key in coll.Keys)
{
sb.Append(key.Div(HtmlEncoder.Default.Encode(coll[key])));
}
return sb.ToString();
}
else return "no form".Div();
}
Using the /form link, the form is received with the GET request (see
Figure 30-10). When you click the Submit button, the form is sent with
the POST request, and you can see the text1 key of the form data (see
Figure 30-11).


FIGURE 30-10
FIGURE 30-11
Cookies
To remember user data between multiple requests, you can use
cookies. Adding a cookie to the HttpResponse object sends the cookie
within the HTTP header from the server to the client. By default, a
cookie is temporary (not stored on the client), and the browser sends it
back to the server if the URL is the same domain where the cookie was
coming from. You can set the Path to restrict when the browser
returns the cookie. In this case, the cookie is only returned when it
comes from the same domain and the path /cookies is used. When you
set the Expires property, the cookie is a persistent cookie and thus is
stored on the client. When the expiration time passes, the cookie will
be removed. However, there’s no guarantee that the cookie isn’t
removed earlier (code file WebSampleApp/RequestResponseSamples.cs ):
public static string WriteCookie(HttpResponse response)
{
response.Cookies.Append("color", "red", new CookieOptions
{
Path = "/cookies",
Expires = DateTime.Now.AddDays(1)
});


return "cookie written".Div();
}
The cookie can be read again by reading the HttpRequest object. The
Cookies property contains all the cookies that are returned by the
browser:
public static string ReadCookie(HttpRequest request)
{
var sb = new StringBuilder();
IRequestCookieCollection cookies = request.Cookies;
foreach (var key in cookies.Keys)
{
sb.Append(key.Div(cookies[key]));
}
return sb.ToString();
}
For testing cookies, you can also use the browser’s developer tools. The
tools show all the information about the cookies that are sent and
received.
Sending JSON
The server returns more than HTML code; it also returns many
different kind of data formats, such as CSS files, images, and videos.
The client knows what kind of data it receives with the help of a mime
type in the response header.
The method GetJson creates a JSON string from an anonymous object
with Title , Publisher , and Author properties. To serialize this object
with JSON, the NuGet package NewtonSoft.Json is added, and the
namespace NewtonSoft.Json imported. The mime type for the JSON
format is application/json . This is set via the ContentType property of
the HttpResponse (code file WebSampleApp/RequestResponseSample.cs ):
public static string GetJson(HttpResponse response)
{
var b = new
{
Title = "Professional C# 7",
Publisher = "Wrox Press",
Author = "Christian Nagel"


};
string json = JsonConvert.SerializeObject(b);
response.ContentType = "application/json";
return json;
}
**NOTE**
The JsonConvert class is part of the NuGet package
Newtonsoft.Json . This third-party package is automatically
referenced from the reference package Microsoft.AspNetCore.All .
This is the data returned to the client.
{"Title":"Professional C# 7","Publisher":"Wrox Press",
"Author":"Christian Nagel"}
**NOTE**
Sending and receiving JSON is covered in Chapter 32, “ASP.NET
Core Web API.”
DEPENDENCY INJECTION
Dependency injection is deeply integrated within ASP.NET Core. This
design pattern gives loose coupling as a service is used only with an
interface. The concrete type that implements the interface is injected.
With the ASP.NET Core built-in dependency injection mechanism,
injection happens via constructors that have arguments of the injected
interface type.
**NOTE**


For more details on dependency injection, read Chapter 20.
Dependency injection separates the service contract and the service
implementation. The service can be used without knowing the
concrete implementation——just a contract is needed. This allows
replacing the service (for example, logging) in a single place for all
using the service.
Let’s have a more detailed look at dependency injection by creating a
custom service.
Defining a Service
First, a contract for a sample service is declared. Defining a contract
via an interface enables you to separate the service implementation
from its use——for example, to use a different implementation for unit
testing (code file WebSampleApp/Services/ISampleService.cs ):
public interface ISampleService
{
IEnumerable<string> GetSampleStrings();
}
You implement the interface ISampleService with the class
DefaultSampleService (code file
WebSampleApp/Services/DefaultSampleService.cs ):
public class DefaultSampleService : ISampleService
{
private List<string> _strings = new List<string> { "one",
"two", "three" };
public IEnumerable<string> GetSampleStrings() => _strings;
}
Registering the Service
Using the AddTransient method (which is an extension method for
IServiceCollection defined in the assembly
Microsoft.Extensions.DependencyInjection.Abstractions in the
namespace Microsoft.Extensions.DependencyInjection ), the type
DefaultSampleService is mapped to ISampleService . When you use the


interface, the DefaultSampleService type is
instantiated (code file WebSampleApp/Startup.cs ):
ISampleService
public void ConfigureServices(IServiceCollection services)
{
services.AddTransient<ISampleService, DefaultSampleService>
();
//...
}
The built-in dependency injection service defines several lifetime
options. Using the AddTransient method, the service is newly
instantiated every time the service is injected.
Using the AddSingleton method, the service is instantiated only once.
Every injection makes use of the same instance:
services.AddSingleton<ISampleService, DefaultSampleService>
();
The AddInstance method requires you to instantiate a service and pass
the instance to this method. This way you’re defining the lifetime of
the service:
var sampleService = new DefaultSampleService();
services.AddInstance<ISampleService>(sampleService);
With the fourth option, the lifetime of the service is based on the
current context. With ASP.NET MVC, the current context is based on
the HTTP request. As long as actions for the same request are invoked,
the same instance is used with different injections. With a new
request, a new instance is created. For defining a context-based
lifetime, the AddScoped method maps the service contract to the
service:
services.AddScoped<ISampleService>();
Injecting the Service
After the service is registered, you can inject it. A controller type
named HomeController is created in the directory Controllers . The
built-in dependency injection framework makes use of constructor


injection; thus, a constructor is defined that receives an
ISampleService interface. The method Index receives an HttpContext
and can use this to read request information. Within the
implementation, the ISampleService is used to get the strings from the
service. The controller adds some HTML elements to put the strings in
a list and sets the status code (code file
WebSampleApp/Controllers/HomeController.cs ):
public async Task Index(HttpContext context)
{
var sb = new StringBuilder();
sb.Append("<ul>");
sb.Append(string.Join(string.Empty,
_service.GetSampleStrings().Select(s =>
s.Li()).ToArray()));
sb.Append("</ul>");
context.Response.StatusCode = 200;
await context.Response.WriteAsync(sb.ToString());
}
}
**NOTE**
This sample controller directly returns HTML code. It’s better to
separate the functionality from the user interface and to create
the HTML code from a different class——a view. For this separation
it’s best to use a framework: ASP.NET MVC. This framework is
explained in Chapter 31.
Calling the Controller
To instantiate the controller via dependency injection, the
HomeController class is registered with the IServiceCollection
services. This time you do not use an interface; thus, you need only the
concrete implementation of the service type with the AddTransient
method call (code file WebSampleApp/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{


services.AddTransient<ISampleService, DefaultSampleService>
();
services.AddTransient<HomeController>();
//...
}
The Configure method that contains the route information is now
changed to add a map for the /Home path. If this expression returns
true , the HomeController is instantiated via dependency injection by
calling the GetService method on the registered application services.
The IApplicationBuilder interface defines an ApplicationServices
property that returns an object implementing IServiceProvider . Here,
you can access all the services that have been registered. Using this
controller, the Index method is invoked by passing the HttpContext :
public void Configure(IApplicationBuilder app, ILoggerFactory
loggerFactory)
{
//...
app.Map("/Home", homeApp =>
{
homeApp.Run(async (context) =>
{
HomeController controller =
homeApp.ApplicationServices.GetService<HomeController>();
await controller.Index(context);
}
});
//...
}
Figure 30-12 shows the output of the unordered list when you run the
application with a URL to the home address.


FIGURE 30-12
SIMPLE ROUTING
The Map method—— an extension method of the IApplicationBuilder
interface to create a simple routing——was used in the previous code
samples. The Map method offers a simple routing facility with ASP.NET
Core. With each map defined, ASP.NET Core specifies a new
middleware pipeline that ends with the Run method based on an URL
path.
If the request is received, and the path of a Map succeeds, the method
assigned to the Action parameter defines the remaining pipeline that is
active with the request. The Run method in the implementation of the
code block specifies the last step of the pipeline.
The following code snippet defines a map to the /Home path and runs
the Invoke method of the HomeController when a request is received
(code file WebSampleApp/Startup.cs ):
public void Configure(IApplicationBuilder app, ILoggerFactory
loggerFactory)
{
//...
app.Map("/Home", homeApp =>
{
homeApp.Run(async context =>
{
HomeController controller =
app.ApplicationServices.GetService<HomeController>();
await controller.Index(context);
});
});
//...
}
Instead of using the Map method, you can also use MapWhen . With the
following code snippet, the map managed by MapWhen applies when the
path contains the string hello . It doesn’t matter if hello is at the begin
or at the end, or if it is prefixed or postfixed (code file
WebSampleApp/Startup.cs ):
public void Configure(IApplicationBuilder app,


IHostingEnvironment env)
{
//...
app.MapWhen(context =>
context.Request.Path.Value.Contains("hello"),
helloApp =>
{
helloApp.Run(async context =>
{
await context.Response.WriteAsync("hello in the
path".Div());
});
});
//...
}
Instead of just using the path, you can also access any other
information of the HttpContext , such as the host information of the
client ( context.Request.Host ) or authenticated users
( context.User.Identity.IsAuthenticated ).
CREATING CUSTOM MIDDLEWARE
ASP.NET Core makes it easy to create modules that are invoked before
the Run method is invoked. This can be used to add header
information, verify tokens, build a cache, create log traces, and so on.
One middleware module is chained after the other until all connected
middleware types have been invoked.
You can create a middleware class by using the Visual Studio item
template Middleware Class. With this middleware type, you create a
constructor that receives a reference to the next middleware type.
RequestDelegate is a delegate that receives an HttpContext as
parameter and returns a Task . This is exactly the signature of the
Invoke method. Within this method, you have access to request and
response information. The type HeaderMiddleware adds a sample
header to the response of the HttpContext . As the last action, the
Invoke method invokes the next middleware module (code file
WebSampleApp/Middleware/HeaderMiddleware.cs ):
public class HeaderMiddleware
{


private readonly RequestDelegate _next;
public HeaderMiddleware(RequestDelegate next) =>
_next = next;
public Task Invoke(HttpContext httpContext)
{
httpContext.Response.Headers.Add("sampleheader",
new[] { "addheadermiddleware"});
return _next(httpContext);
}
}
For making it easy to configure the middleware type, the extension
method UseHeaderMiddleware extends the interface
IApplicationBuilder where the method UseMiddleware is called:
public static class HeaderMiddlewareExtensions
{
public static IApplicationBuilder UseHeaderMiddleware(
this IApplicationBuilder builder) =>
builder.UseMiddleware<HeaderMiddleware>();
}
Now it’s the job of the Startup class and the Configure method to
configure all the middleware types. The extension methods are already
prepared for invocation (code file WebSampleApp/Startup.cs ):
public void Configure(IApplicationBuilder app, ILoggerFactory
loggerFactory)
{
//...
app.UseHeaderMiddleware();
//...
}
When you run the application, you see the header returned to the
client (using the browser’s developer tools), and the heading shows up
in every page, no matter which of the previously created links you use
(see Figure 30-13).


FIGURE 30-13
SESSION STATE
A service that is implemented using middleware is session state.
Session state enables temporarily remembering data from the client
on the server. Session state itself is implemented as middleware.
Session state is initiated when a user first requests a page from a
server. While the user keeps opening pages on the server, the session
continues until a timeout (typically 10 minutes) occurs. To keep state
on the server while the user navigates to a new page, state can be
written to a session. When a timeout is reached, the session data is
removed.
To identify a session, on the first request a temporary cookie with a
session identifier is created. This cookie is returned from the client
with every request to the server until the browser is closed, and then


the cookie is deleted. Session identifiers can also be sent in the URL
string as an alternative to using cookies.
On the server side, session information can be stored in memory. In a
web farm, session state that is stored in memory doesn’t propagate
between different systems. With a sticky session configuration, the
user always returns to the same physical server. Using sticky sessions,
it doesn’t matter that the same state is not available on other systems
(with the exception when one server fails). Without sticky sessions,
and to also deal with failing servers, options exist to store session state
within distributed memory of a SQL server database. Storing session
state in distributed memory also helps with process recycling of the
server process; recycling kills session state also if you’re using just a
single server process.
For using session state with ASP.NET, you need to add the NuGet
package Microsoft.AspNet.Session . This package gives the AddSession
extension method that can be called within the ConfigureServices
method in the Startup class. The parameter enables you to configure
the idle timeout and the cookie options. The cookie is used to identify
the session. The session also makes use of a service that implements
the interface IDistributedCache . A simple implementation is the cache
for in-process session state. The method AddCaching adds the following
cache service (code file WebSampleApp/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddTransient<ISampleService, DefaultSampleService>
();
services.AddTransient<HomeController>();
services.AddDistributedMemoryCache();
services.AddSession(options =>
options.IdleTimeout = TimeSpan.FromMinutes(10));
}
For using the session, you need to configure the middleware in the
pipeline by calling the UseSession extension method. You need to
invoke this method before any response is written to the response——
such as is done with the UseHeaderMiddleware ——thus UseSession is
called before the other methods. The code that uses session
information is mapped to the /Session path (code file


WebSampleApp/Startup.cs ):
public void Configure(IApplicationBuilder app, ILoggerFactory
loggerFactory)
{
//...
app.UseSession();
app.UseHeaderMiddleware();
app.Map("/Session", sessionApp =>
{
sessionApp.Run(async context =>
{
await SessionSample.SessionAsync(context);
});
});
//...
}
You can write session state using Setxxx methods, such as SetString
and SetInt32 . These methods are defined with the ISession interface
that is returned from the Session property of the HttpContext . Session
data is retrieved using Getxxx methods (code file
WebSampleApp/SessionSample.cs ):
public static class SessionSample
{
private const string SessionVisits = nameof(SessionVisits);
private const string SessionTimeCreated =
nameof(SessionTimeCreated);
public static async Task SessionAsync(HttpContext context)
{
int visits = context.Session.GetInt32(SessionVisits) ??
0;
string timeCreated =
context.Session.GetString(SessionTimeCreated) ??
string.Empty;
if (string.IsNullOrEmpty(timeCreated))
{
timeCreated = DateTime.Now.ToString("t",
CultureInfo.InvariantCulture);
context.Session.SetString(SessionTimeCreated,
timeCreated);
}
DateTime timeCreated2 = DateTime.Parse(timeCreated);
context.Session.SetInt32(SessionVisits, ++visits);
await context.Response.WriteAsync(


$"Number of visits within this session: {visits} " +
$"that was created at {timeCreated2:T}; " +
$"current time: {DateTime.Now:T}");
}
}
**NOTE**
The sample code uses an invariant culture to store the time when
the session was created. The time shown to the user is using a
specific culture. It’s a good practice to use invariant cultures
storing culture-specific data on the server. Information about
invariant cultures and how to set cultures is explained in Chapter
26, “Localization.”
CONFIGURING WITH ASP.NET CORE
With web applications, it’s necessary to store configuration
information that can be changed by system administrators——for
example, connection strings. In the next chapter you create a data-
driven application where a connection string is needed.
Configuration of ASP.NET Core is no longer based on the XML
configuration files web.config and machine.config as was the case with
previous versions of ASP.NET. With the old configuration file,
assembly references and assembly redirects were mixed with database
connection strings and application settings. This is no longer the case.
Application settings are typically stored within appsettings.json , but
the configuration is a lot more flexible and you can choose to make
your configuration with several JSON or XML files and with
environment variables.
When you use the WebHost with the default builder as created with the
default template, several configuration providers are configured (code
file WebSampleApp/Program.cs ):
public static IWebHost BuildWebHost(string[] args) =>
WebHost.CreateDefaultBuilder(args)


.UseStartup<Startup>()
.Build();
In detail, these five providers are configured by default:
MemoryConfigurationProvider
JsonConfigurationProvider ( appsetttings.json )
JsonConfigurationProvider ( appsettings.{environment}.json )
EnvironmentVariablesConfigurationProvider
CommandLineConfigurationProvider
One way to access configuration values from the Startup class is to
inject the IConfiguration interface in the constructor and assign a
property to the received configuration (code file
WebSampleApp/Startup.cs ):
public Startup(IConfiguration configuration)
{
Configuration = configuration;
}
public IConfiguration Configuration { get; }
Create an Application Configuration file with this content
(configuration file WebSampleApp/appsettings.json ):
{
"SampleSettings": {
"Setting1": "Value1"
},
"AppSettings": {
"setting2": "Value2",
"Setting3": "Value3",
"SubSection1": {
"Setting4": "Value4"
}
},
"ConnectionStrings": {
"DefaultConnection":
"Server=(localdb)\\MSSQLLocalDB;Database=_CHANGE_ME;
Trusted_Connection=True;MultipleActiveResultSets=true"
}
}


This setting will be accessed in the next section.
Reading the Configuration
To read the configuration, you can use the IConfiguration interface
and access the sections. The ConfigurationSample class accesses this
interface via dependency injection (code file
WebSampleApp/ConfigurationSample.cs ):
public class ConfigurationSample
{
private readonly IConfiguration _configuration;
public ConfigurationSample(IConfiguration configuration) =>
_configuration = configuration;
//...
}
The settings can be retrieved using an indexer, and the sections within
the configuration file can be accessed using GetSection .
GetSection( " SampleSettings " ) retrieves the SampleSettings section,
followed by accessing the indexer passing the string Setting1 . With
this, the value Value1 is retrieved:
public async Task ShowApplicationSettingsAsync(HttpContext
context)
{
string settings =
_configuration.GetSection("SampleSettings")["Setting1"];
await context.Response.WriteAsync(settings.Div());
}
Instead of using the GetSection method to access hierarchical
configuration, the colon syntax can be used with the indexer to
separate all the hierarchies. The following code snippet retrieves the
same values from the configuration file as the previous one:
public async Task
ShowApplicationSettingsUsingColonsAsync(HttpContext context)
{
string settings =
_configuration["SampleSettings:Setting1"];
await context.Response.WriteAsync(settings.Div());
}


For the section named ConnectionStrings an extension method exists
to easily access connection strings. Instead of using GetSection and the
indexer, you can use just the method GetConnectionString , retrieving
the settings in this section:
public async Task
ShowConnectionStringSettingAsync(HttpContext context)
{
string connectionString = _configuration
.GetConnectionString("DefaultConnection");
await context.Response.WriteAsync(connectionString.Div());
}
You can also create a class for strongly typed access to configuration
values. To use this feature, you can create the classes AppSettings and
SubSection1 with property names that map directly to keys in the
configuration file (code file WebSampleApp/ConfigurationSample.cs ):
public class SubSection1
{
public string Setting4 { get; set; }
}
public class AppSettings
{
public string Setting2 { get; set; }
public string Setting3 { get; set; }
public SubSection1 SubSection1 { get; set; }
}
The custom classes to map the custom configuration types are filled by
invoking the generic Get method and passing the AppSettings class as a
generic parameter.
public async Task
ShowApplicationSettingsStronglyTyped(HttpContext context)
{
AppSettings settings =
_configuration.GetSection("AppSettings")
.Get<AppSettings>();
await context.Response.WriteAsync($"setting 2:
{settings.Setting2}, " +
$"setting3: {settings.Setting3}, " +
$"setting4: {settings.SubSection1.Setting4}".Div());
}


For running the application and calling the different methods of the
ConfigurationSample class, the MapWhen defines a map to the
/Configuration link and passes the remaining path to the
remainingPath variable. Depending on the remaining part, different
methods from the ConfigurationSample class are invoked (code file
WebSampleApp/Startup.cs ):
PathString remainingPath;
// out var not possible with lambda following in next
parameter
app.MapWhen(context =>
context.Request.Path.StartsWithSegments("/Configuration",
out remainingPath),
configurationApp =>
{
configurationApp.Run(async context =>
{
var configSample = app.ApplicationServices
.GetService<ConfigurationSample>();
if (remainingPath.StartsWithSegments("/appsettings"))
{
await
configSample.ShowApplicationSettingsAsync(context);
}
else if (remainingPath.StartsWithSegments("/colons"))
{
await
configSample.ShowApplicationSettingsUsingColonsAsync(context);
}
else if
(remainingPath.StartsWithSegments("/database"))
{
await
configSample.ShowConnectionStringSettingAsync(context);
}
else if
(remainingPath.StartsWithSegments("/stronglytyped"))
{
await
configSample.ShowApplicationSettingsStronglyTyped(context);
}
});
});


Changing Configuration Providers
You’ve seen that five configuration providers are configured with the
default host builder. The order of these providers is important. If
different values for the same key are specified multiple times, the last
configured value is returned. For example, when you pass values from
the command line, these values are taken rather than configured in a
JSON file. Make a complete custom configuration with a .NET Core
console application and add the following NuGet packages to this
application:
Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.CommandLine
Microsoft.Extensions.Configuration.EnvironmentVariables
Microsoft.Extensions.Configuration.Json
The configuration of the console application is done using a
ConfigurationBuilder . The ConfigurationBuilder class implements the
interface IConfigurationBuilder . For this interface, various extension
methods are defined in the NuGet packages
Microsoft.Extensions.Configuration.* . The method
SetupConfiguration adds providers for JSON, environmental
variables, and the command line (code file
CustomConfiguration/Program.cs ):
static void SetupConfiguration(string[] args)
{
var builder = new ConfigurationBuilder()
.SetBasePath(Directory.GetCurrentDirectory())
.AddJsonFile("appsettings.json")
.AddEnvironmentVariables()
.AddCommandLine(args);
Configuration = builder.Build();
}
public static IConfigurationRoot Configuration { get; private
set; }
The configuration is read using the GetSection method and the indexer
of the IConfiguration interface, as discussed in earlier sections:


private static void ReadConfiguration()
{
string val1 = Configuration.GetSection("section1")["key1"];
Console.WriteLine(val1);
string val2 = Configuration.GetSection("section1")["key2"];
Console.WriteLine(val2);
}
The JSON configuration file defines these settings (configuration file
CustomConfiguration/appsettings.json ):
{
"section1": {
"key1": "value 1",
"key2": "value 2"
}
}
Because the environment variables and the command-line providers
are added after the JSON provider, settings defined by these providers
override the other settings. When you use the command line with the
dotnet command, arguments to the application are assigned after a --
to separate the arguments from the application from the arguments of
the dotnet command. Hierarchical configuration sections are
separated with a colon:
> dotnet run -- section1:key1="settings from command line"
Command-line arguments and environment variables can be
configured from within Visual Studio in the Debug settings as shown
in Figure 30-14.


FIGURE 30-14
The debug settings are written to the file LaunchSettings.json :
{
"profiles": {
"CustomConfiguration": {
"commandName": "Project",
"commandLineArgs": "section1:key2=\"app argument\"",
"environmentVariables": {
"section1:key1": "env variable"
}
}
}
}
With an ASP.NET Core web application, you can define the
configuration providers, as you’ve seen previously with the console
application. However, ASP.NET Core 2 offers a simpler way to add
extra configuration with extension methods of the IWebHostBuilder ,
such as the ConfigureAppConfiguration method. The following code
snippet adds the XML file appsettings.xml by using the AddXmlFile
extension method. A runtime exception should not occur when the file
does not exist, thus the file is marked as optional (code file


WebSampleApp/Program.cs )
public static IWebHost BuildWebHost(string[] args) =>
WebHost.CreateDefaultBuilder(args)
.UseStartup<Startup>()
.ConfigureAppConfiguration(configure =>
{
configure.AddXmlFile("appsettings.xml", optional:
true);
})
.Build();
Different Configurations Based on the
Environment
When running your web application with different environments——for
example, during development, testing, and production——you might
also use a staging server because it’s likely you are using some
different configurations. You don’t want to add test data to the
production database. For the configuration values that should be
different, you can use different configuration files.
The default builder of the WebHost adds two JSON configuration files,
appsettings.json and appsettings.{env.EnvironmentName}.json . The
second file is configured to be optional, just like the XML file
configuration from the previous section. The environment name is
configured differently based on debug and release builds.
You can configure the environment by setting the environmental
variable named ASPNETCORE_ENVIRONMENT in the Visual Studio project
properties as shown in Figure 30-15.


FIGURE 30-15
To verify the hosting environment programmatically, extension
methods are defined for the interface IHostingEnvironment , such as
IsDevelopment , IsStaging , and IsProduction . You can use these
methods, or to test for any environmental name, you can pass a
verification string to IsEnvironment :
if (env.IsDevelopment())
{
//...
}
SUMMARY
In this chapter, you explored the foundation of ASP.NET Core and web


applications. You’ve seen requests from a browser and returning
simple responses after reading request information. You’ve seen the
foundation of ASP.NET Core with dependency injection and services,
and you’ve seen a concrete implementation using dependency
injection such as session state. You’ve also seen how configuration
information can be stored in different ways, such as JSON
configuration for different environments such as development and
production.
The next chapter shows how ASP.NET Core MVC, which uses the
foundation discussed in this chapter, can be used to create web
applications.