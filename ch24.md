

Security
WHAT’S IN THIS CHAPTER?
Authentication and authorization
Creating and verifying signatures
Secure data exchange
Signing and hashing
Data protection
Access control to resources
Web security
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available in the GitHub repository
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the folder Security . The code for this chapter is divided into the
following major examples:
WindowsPrincipal
SigningDemo
SecureTransfer


RSASample
DataProtection
UserSecretsSample
FileAccessControl
WebApplicationSecurity
INTRODUCTION
Security has several key elements that you need to consider to make
your applications secure. The primary one, of course, is the user of the
application. Is the user the person authorized to access the
application, or someone posing as the user? How can this user be
trusted? As you see in this chapter, ensuring the security of an
application in regard of the user is a two-part process: First, users
need to be authenticated, and then they need to be authorized to verify
that they are allowed to use the requested resources.
What about data that is stored or sent across the network? Is it
possible for someone to access this data, for example, by using a
network sniffer? Encryption of data is important in this regard. Some
technologies, such as Windows Communication Foundation (WCF),
provide encryption capabilities by simple configuration, so you can see
what’s done behind the scenes.
Yet another aspect is the application itself. If the application is hosted
by a web provider, how is the application restricted from doing harm
to the server?
This chapter explores the features available in .NET to help you
manage security, demonstrating how .NET protects you from
malicious code, how to administer security policies, and how to access
the security subsystem programmatically.
You can also read about the issues you need to be aware of when
making web applications secure.
VERIFYING USER INFORMATION


Two fundamental pillars of security are authentication and
authorization. Authentication is the process of identifying the user,
and authorization occurs afterward to verify that the identified user is
allowed to access a specific resource. This section shows how to get
information about users with identities and principals.
Working with Windows Identities
You can identify the user running the application by using an identity.
The WindowsIdentity class represents a Windows user. If you don’t
identify the user with a Windows account, you can use other classes
that implement the interface IIdentity . With this interface you have
access to the name of the user, information about whether the user is
authenticated, and the authentication type.
A principal is an object that contains the identity of the user and the
roles to which the user belongs. The interface IPrincipal defines the
property Identity , which returns an IIdentity object, and the method
IsInRole with which you can verify that the user is a member of a
specific role. A role is a collection of users who have the same security
permissions, and it is the unit of administration for users. Roles can be
Windows groups or just a collection of strings that you define.
The principal classes available with .NET are WindowsPrincipal ,
GenericPrincipal , and RolePrincipal . Since .NET 4.5, these principal
types derive from the base class ClaimsPrincipal . You can also create a
custom principal class that implements the interface IPrincipal or
derives from ClaimsPrincipal .
The sample code runs only on Windows and makes use of the
following dependency and namespaces:
Dependency
System.Security.Principal.Windows
Namespaces
System
System.Collections.Generic


System.Security.Claims
System.Security.Principal
The following example creates a Console App (.NET Core) that
provides access to the principal in an application that, in turn, enables
you to access the underlying Windows account. You need to import the
System.Security.Principal and System.Security.Claims namespaces.
The Main method invokes the method ShowIdentityInformation to
write information about the WindowsIdentity to the console,
ShowPrincipal to write additional information that is available with
principals, and ShowClaims to write information about claims (code file
WindowsPrincipal/Program.cs ):
static void Main()
{
WindowsIdentity identity = ShowIdentityInformation();
WindowsPrincipal principal = ShowPrincipal(identity);
ShowClaims(principal.Claims);
}
The method ShowIdentityInformation creates a WindowsIdentity object
by invoking the static GetCurrent method of the WindowsIdentity and
accesses its properties to show the identity type, name of the identity,
authentication type, and other values (code file
WindowsPrincipal/Program.cs ):
public static WindowsIdentity ShowIdentityInformation()
{
WindowsIdentity identity = WindowsIdentity.GetCurrent();
if (identity == null)
{
Console.WriteLine("not a Windows Identity");
return null;
}
Console.WriteLine($"IdentityType: {identity}");
Console.WriteLine($"Name: {identity.Name}");
Console.WriteLine($"Authenticated:
{identity.IsAuthenticated}");
Console.WriteLine($"Authentication Type:
{identity.AuthenticationType}");
Console.WriteLine($"Anonymous? {identity.IsAnonymous}");
Console.WriteLine($"Access Token: " +
$"{identity.AccessToken.DangerousGetHandle()}");


Console.WriteLine();
return identity;
}
All identity classes, such as WindowsIdentity , implement the IIdentity
interface, which contains three properties—— AuthenticationType ,
IsAuthenticated , and Name ——for all derived identity classes to
implement. The other properties you’ve seen with the WindowsIdentity
are specific to this kind of identity.
When you run the application, you see information like what’s shown
in the following snippet. The authentication type shows CloudAP
because I’m logged into the system using a Microsoft Live account.
Active Directory shows up in the authentication type if you’re using
Active Directory:
IdentityType: System.Security.Principal.WindowsIdentity
Name: THEROCKS\Christian
Authenticated: True
Authentication Type: CloudAP
Anonymous? False
Access Token: 564
Windows Principals
A principal contains an identity and offers additional information,
such as roles the user belongs to. Principals implement the interface
IPrincipal , which offers the method IsInRole in addition to an
Identity property. With Windows, all the Windows groups the user is
member of are mapped to roles. The method IsInRole is overloaded to
accept a security identifier, a role string, or an enumeration value of
the WindowsBuiltInRole enumeration. The sample code verifies
whether the user belongs to the built-in roles User and Administrator
(code file WindowsPrincipal/Program.cs ):
public static WindowsPrincipal ShowPrincipal(WindowsIdentity
identity)
{
Console.WriteLine("Show principal information");
WindowsPrincipal principal = new
WindowsPrincipal(identity);
if (principal == null)
{


Console.WriteLine("not a Windows Principal");
return null;
}
Console.WriteLine($"Users?
{principal.IsInRole(WindowsBuiltInRole.User)}");
Console.WriteLine(
$"Administrators?
{principal.IsInRole(WindowsBuiltInRole.Administrator)}");
Console.WriteLine();
return principal;
}
When I run the application, my account belongs to the role Users but
not Administrator, and I get the following result:
Show principal information
Users? True
Administrators? False
It is enormously beneficial to be able to easily access details about the
current users and their roles. With this information, you can make
decisions about what actions should be permitted or denied. The
ability to make use of roles and Windows user groups provides the
added benefit that administration can be handled using standard user
administration tools, and you can usually avoid altering the code when
user roles change.
All the principal classes derive from the base class ClaimsPrincipal .
This way, it’s possible to access claims from users with the Claims
property of a principal object. The following section looks at claims.
Using Claims
Claims offer a lot more flexibility compared to roles. A claim is a
statement made about an identity from an authority. An authority
such as the Active Directory or the Microsoft Live account
authentication service makes claims about users——for example, the
claim of the name of the user, claims about groups the user belongs to,
or a claim about the age. Is the user already of age 21 or older and
eligible for accessing specific resources?
The method ShowClaims accesses a collection of claims to write subject,


issuer, claim type, and more options to the console (code file
WindowsPrincipal/Program.cs ):
public static void ShowClaims(IEnumerable<Claim> claims)
{
Console.WriteLine("Claims");
foreach (var claim in claims)
{
Console.WriteLine($"Subject: {claim.Subject}");
Console.WriteLine($"Issuer: {claim.Issuer}");
Console.WriteLine($"Type: {claim.Type}");
Console.WriteLine($"Value type: {claim.ValueType}");
Console.WriteLine($"Value: {claim.Value}");
foreach (var prop in claim.Properties)
{
Console.WriteLine($"\tProperty: {prop.Key}
{prop.Value}");
}
Console.WriteLine();
}
}
Here is an extract of the claims from the Microsoft Live account, which
provides information about the name, the primary ID, and the group
identifiers:
Claims
Subject: System.Security.Principal.WindowsIdentity
Issuer: AD AUTHORITY
Type:
http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name
Value type: http://www.w3.org/2001/XMLSchema#string
Value: THEROCKS\Christian
Subject: System.Security.Principal.WindowsIdentity
Issuer: AD AUTHORITY
Type:
http://schemas.microsoft.com/ws/2008/06/identity/claims/primarysid
Value type: http://www.w3.org/2001/XMLSchema#string
Value: S-1-5-21-1413171511-313453878-1364686672-1001
Property:
http://schemas.microsoft.com/ws/2008/06/identity/claims/
windowssubauthority NTAuthority
Subject: System.Security.Principal.WindowsIdentity


Issuer: AD AUTHORITY
Type:
http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid
Value type: http://www.w3.org/2001/XMLSchema#string
Value: S-1-1-0
Property:
http://schemas.microsoft.com/ws/2008/06/identity/claims/
windowssubauthority WorldAuthority
Subject: System.Security.Principal.WindowsIdentity
Issuer: AD AUTHORITY
Type:
http://schemas.microsoft.com/ws/2005/05/identity/claims/denyonlysid
Value type: http://www.w3.org/2001/XMLSchema#string
Value: S-1-5-114
Property:
http://schemas.microsoft.com/ws/2008/06/identity/claims/
windowssubauthority NTAuthority
...
You can add claims to a Windows identity from a claim provider. You
can also add a claim from a simple client program, such as the age
claim here:
identity.AddClaim(new Claim("Age", "25"));
Using claims from a program, it’s just a matter to trust this claim. Is
this claim true——the age 25? Claims can also be lies. Adding this claim
from the client application, you can see that the issuer of this claim is
the LOCAL AUTHORITY. Information from the AD AUTHORITY (the
Active Directory) is more trustworthy, but here you need to trust the
Active Directory system administrators.
The WindowsIdentity deriving from the base class ClaimsIdentity
offers several methods checking for claims or retrieving specific
claims. To test whether a claim is available, you can use the HasClaim
method:
bool hasName = identity.HasClaim(c => c.Type ==
ClaimTypes.Name);
To retrieve specific claims, the method FindAll needs a predicate to


define a match:
var groupClaims = identity.FindAll(c => c.Type ==
ClaimTypes.GroupSid);
**NOTE**
A claim type can be a simple string like the "Age" type used
earlier. The ClaimType defines a list of known types such as
Country , Email , Name , MobilePhone , UserData , Surname , PostalCode ,
and several more.
ENCRYPTING DATA
Confidential data should be secured so that it cannot be read by
unprivileged users. This is valid for both data that is sent across the
network and stored data. You can encrypt such data with symmetric or
asymmetric encryption keys.
With a symmetric key, you can use the same key for encryption and
decryption. With asymmetric encryption, different keys are used for
encryption and decryption: a public key and a private key. Something
encrypted using a public key can be decrypted with the corresponding
private key. This also works the other way around: Something
encrypted using a private key can be decrypted by using the
corresponding public key, but not the private key. It’s practically
impossible to calculate the private or public key from the other one.
Public and private keys are always created as a pair. The public key can
be made available to everybody, and even put on a website, but the
private key must be safely locked away. Following are some examples
that demonstrate how public and private keys are used for encryption.
If Alice sends a message to Bob (see Figure 24-1), and she wants to
ensure that no one other than Bob can read the message, she uses
Bob’s public key. The message is encrypted using Bob’s public key. Bob
opens the message and can decrypt it using his secretly stored private


key. This key exchange guarantees that only Bob can read Alice’s
message.
FIGURE 24-1
There is one problem, however: Bob can’t be sure that the mail comes
from Alice. Eve can use Bob’s public key to encrypt messages sent to
Bob and pretend to be Alice. We can extend this principle using
public/private keys. Let’s start again with Alice sending a message to
Bob. Before Alice encrypts the message using Bob’s public key, she
adds her signature and encrypts the signature using her own private
key. Then she encrypts the mail using Bob’s public key. Therefore, it is
guaranteed that no one other than Bob can read the message. When
Bob decrypts it, he detects an encrypted signature. The signature can
be decrypted using Alice’s public key. For Bob, it is not a problem to
access Alice’s public key because the key is public. After decrypting the
signature, Bob can be sure that it was Alice who sent the message.
The encryption and decryption algorithms using symmetric keys are a
lot faster than those using asymmetric keys. The problem with
symmetric keys is that the keys must be exchanged in a safe manner.
With network communication, one way to do this is by using
asymmetric keys first for the key exchange and then symmetric keys


for encryption of the data that is sent across the wire.
.NET contains classes for encryption in the namespace
System.Security.Cryptography . Several symmetric and asymmetric
algorithms are implemented. You can find algorithm classes for many
different purposes. Some of the classes have a Cng prefix or suffix. CNG
is short for Cryptography Next Generation, which is a newer version
of the native Windows Crypto API. This API makes it possible to write
a program independently of the algorithm by using a provider-based
model.
The following table lists encryption classes and their purposes from
the namespace System.Security.Cryptography . The classes without a
Cng , Managed , or CryptoServiceProvider suffix are abstract base classes,
such as MD5 . The Managed suffix means that this algorithm is
implemented with managed code; other classes might wrap native
Windows API calls. The suffix CryptoServiceProvider is used with
classes that implement the abstract base class. The Cng suffix is used
with classes that make use of the new Cryptography CNG API.
CATEGORY CLASSES
Hash
MD5 SHA1 SHA1Managed SHA256
SHA256Managed SHA256Cng SHA384
SHA384Managed SHA512 SHA512Managed


DESCRIPTION
The purpose of
hash algorithms
is to create a
fixed-length
hash value from
binary strings of
arbitrary length.
These algorithms
are used with
digital signatures
and for data
integrity. If the
same binary
string is hashed
again, the same
hash result is
returned. MD5
Symmetric
(Message Digest
Algorithm 5),
developed at
RSA
Laboratories, is
faster than
SHA1. SHA1 is
stronger against
brute force
attacks. The SHA
algorithms were
designed by the
National
Security Agency
(NSA). MD5 uses
a 128-bit hash
size; SHA1 uses
160 bits. The
other SHA
algorithms
contain the hash
size in the name.
SHA512 is the
strongest of
these algorithms,
with a hash size
of 512 bits; it is
also the slowest.
DES DESCryptoServiceProvider
Symmetric key
TripleDESTripleDESCryptoServiceProvider algorithms use
Aes AesCryptoServiceProvider AesManaged the same key for
RC2 RC2CryptoServiceProvider Rijndael
encryption and
RijndaelManaged
decryption of
data. Data
Encryption
Standard (DES)
is now


Asymmetric
DSA DSACryptoServiceProvider ECDsa
ECDsaCng ECDiffieHellman
ECDiffieHellmanCng RSA
RSACryptoServiceProvider RSACng


considered
insecure because
it uses only 56
bits for the key
size and can be
broken in less
than 24 hours.
Triple-DES is the
successor to DES
and has a key
length of 168
bits, but the
effective security
it provides is
only 112-bit.
Advanced
Encryption
Standard (AES)
has a key size of
128, 192, or 256
bits. Rijndael is
very similar to
AES but offers
more key size
options. AES is
an encryption
standard
adopted by the
U.S.
government.
Asymmetric
algorithms use
different keys for
encryption and
decryption. The
Rivest, Shamir,
Adleman (RSA)
algorithm was
the first one used
for signing as
well as
encryption. This
algorithm is
widely used in e-
commerce
protocols. RSACng
is a class new
with .NET 4.6
and .NET Core
that is based on a
Cryptography
Next Generation
(CNG)
implementation.
Digital Signature
Algorithm (DSA)
is a United
States Federal
Government
standard for
digital
signatures.
Elliptic Curve
DSA (ECDSA)
and EC Diffie-
Hellman use
algorithms based
on elliptic curve
groups. These
algorithms are
more secure,
with shorter key
sizes. For
example, having


a key size of
1024 bits for
DSA is similar in
security to 160
bits for ECDSA.
As a result,
ECDSA is much
faster. EC Diffie-
Hellman is an
algorithm used
to exchange
private keys in a
secure way over
a public channel.
The following section includes some examples demonstrating how
these algorithms can be used programmatically.
**WARNING**
Be aware that all classes with the Cng pre- or postfix (belonging to
Windows Cryptography Next Generation, CNG), are supported
only on Windows. They do not run on Linux or Mac. These APIs
throw a PlatformNotSupportedException on Linux.
Creating and Verifying a Signature
The first example demonstrates a signature using the ECDSA
algorithm, described in the preceding table, for signing. Alice creates a
signature that is encrypted with her private key and can be accessed
using her public key. This way, it is guaranteed that the signature is
from Alice.
The sample application SigningDemo makes use of the following
dependency and namespaces:
Dependency


System.Security.Cryptography.Cng
Namespaces
System
System.Security.Cryptography
System.Text
First, look at the major steps in the Main method: Alice’s keys are
created, and the string "Alice" is signed and then verified to be the
signature from Alice by using the public key. The message that is
signed is converted to a byte array by using the Encoding class. To write
the encrypted signature to the console, the byte array that contains the
signature is converted to a string with the method Convert
.ToBase64String (code file SigningDemo/Program.cs ):
private CngKey _aliceKeySignature;
private byte[] _alicePubKeyBlob;
static void Main()
{
var p = new Program();
p.Run();
}
public void Run()
{
InitAliceKeys();
byte[] aliceData = Encoding.UTF8.GetBytes("Alice");
byte[] aliceSignature = CreateSignature(aliceData,
aliceKeySignature);
Console.WriteLine($"Alice created signature: " +
$"{Convert.ToBase64String(aliceSignature)}");
if (VerifySignature(aliceData, aliceSignature,
alicePubKeyBlob))
{
Console.WriteLine("Alice signature verified
successfully");
}
}


**WARNING**
Never convert encrypted data to a string using the Encoding class.
The Encoding class verifies and converts invalid values that are
not allowed with Unicode; therefore, converting the string back to
a byte array can yield a different result.
is the method that creates a new key pair for Alice. This
key pair is stored in a static field, so it can be accessed from the other
methods. The Create method of CngKey gets the algorithm as an
argument to define a key pair for the algorithm. With the Export
method, the public key of the key pair is exported. This public key can
be given to Bob for verification of the signature. Alice keeps the private
key. Instead of creating a key pair with the CngKey class, you can open
existing keys that are stored in the key store. Usually Alice would have
a certificate containing a key pair in her private store, and the store
could be accessed with CngKey.Open :
InitAliceKeys
private void InitAliceKeys()
{
_aliceKeySignature = CngKey.Create(CngAlgorithm.ECDsaP521);
_alicePubKeyBlob =
aliceKeySignature.Export(CngKeyBlobFormat.GenericPublicBlob);
}
With the key pair, Alice can create the signature using the ECDsaCng
class. The constructor of this class receives the CngKey ——which contains
both the public and private keys——from Alice. The private key is used
to sign the data with the SignData method:
public byte[] CreateSignature(byte[] data, CngKey key)
{
byte[] signature;
using (var signingAlg = new ECDsaCng(key))
{
signature = signingAlg.SignData(data,
HashAlgorithmName.SHA512);
signingAlg.Clear();


}
return signature;
}
To verify that the signature was really from Alice, Bob checks the
signature by using the public key from Alice. The byte array containing
the public key blob can be imported to a CngKey object with the static
Import method. The ECDsaCng class is then used to verify the signature
by invoking VerifyData :
public bool VerifySignature(byte[] data, byte[] signature,
byte[] pubKey)
{
bool retValue = false;
using (CngKey key = CngKey.Import(pubKey,
CngKeyBlobFormat.GenericPublicBlob))
using (var signingAlg = new ECDsaCng(key))
{
retValue = signingAlg.VerifyData(data, signature,
HashAlgorithmName.SHA512);
signingAlg.Clear();
}
return retValue;
}
Implementing Secure Data Exchange
The next example helps explain public/private key principles,
exchanging a secret between two parties, and communication with
symmetric keys. A secret can be exchanged between two parties using
the EC Diffie-Hellman algorithm. This algorithm allows exchanging a
secret just by using public and private keys and exchanging the public
key between two parties. At the time of this writing, an
implementation of this algorithm is not available with .NET Core; it’s
available only with the .NET Framework running on Windows. In your
applications you typically don’t need to implement this functionality
because it’s already offered by infrastructure services.
**NOTE**


At the time of this writing, .NET Core just includes the
ECDiffieHellman abstract base class that can be used by
implementers to create concrete classes. A concrete class is not yet
here, that’s why this sample uses only .NET 4.7.1.
The sample application SecureTransfer has the target framework set to
net471 and makes use of the following dependencies and namespaces:
Dependencies
System.Security.Cryptography.Algorithms
System.Security.Cryptography.Cng
System.Security.Cryptography.Csp
System.Security.Cryptography.Primitives
Namespaces
System
System.IO
System.Security.Cryptography
System.Text
System.Threading.Tasks
The Main method contains the primary functionality. Alice creates an
encrypted message and sends it to Bob. Before the message is created
and sent, key pairs are created for Alice and Bob. Bob has access only
to Alice’s public key, and Alice has access only to Bob’s public key
(code file SecureTransfer/Program.cs ):
private
private
private
private
CngKey
CngKey
byte[]
byte[]
_aliceKey;
_bobKey;
_alicePubKeyBlob;
_bobPubKeyBlob;
static async Task Main()
{
var p = new Program();


await p.RunAsync();
Console.ReadLine();
}
public async Task RunAsync()
{
try
{
CreateKeys();
byte[] encrytpedData =
await AliceSendsDataAsync("This is a secret message for
Bob");
await BobReceivesDataAsync(encrytpedData);
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
}
In the implementation of the CreateKeys method, keys are created to
be used with the EC Diffie-Hellman 521 algorithm:
public void CreateKeys()
{
aliceKey = CngKey.Create(CngAlgorithm.ECDiffieHellmanP521);
bobKey = CngKey.Create(CngAlgorithm.ECDiffieHellmanP521);
alicePubKeyBlob =
aliceKey.Export(CngKeyBlobFormat.EccPublicBlob);
bobPubKeyBlob =
bobKey.Export(CngKeyBlobFormat.EccPublicBlob);
}
In the method AliceSendsDataAsync , the string that contains text
characters is converted to a byte array by using the Encoding class. An
ECDiffieHellmanCng object is created and initialized with the key pair
from Alice. Alice creates a symmetric key by using her key pair and the
public key from Bob, calling the method DeriveKeyMaterial . The
returned symmetric key is used with the symmetric algorithm AES to
encrypt the data. AesCryptoServiceProvider requires the key and an
initialization vector (IV). The IV is generated dynamically from the
method GenerateIV . The symmetric key is exchanged with the help of
the EC Diffie-Hellman algorithm, but the IV must also be exchanged.
From a security standpoint, it is OK to transfer the IV unencrypted


across the network——only the key exchange must be secured. The IV is
stored first as content in the memory stream, followed by the
encrypted data where the CryptoStream class uses the encryptor
created by the AesCryptoServiceProvider class. Before the encrypted
data is accessed from the memory stream, the crypto stream must be
closed. Otherwise, end bits would be missing from the encrypted data:
public async Task<byte[]> AliceSendsDataAsync(string message)
{
Console.WriteLine($"Alice sends message: {message}");
byte[] rawData = Encoding.UTF8.GetBytes(message);
byte[] encryptedData = null;
using (var aliceAlgorithm = new
ECDiffieHellmanCng(aliceKey))
using (CngKey bobPubKey = CngKey.Import(bobPubKeyBlob,
CngKeyBlobFormat.EccPublicBlob))
{
byte[] symmKey =
aliceAlgorithm.DeriveKeyMaterial(bobPubKey);
Console.WriteLine("Alice creates this symmetric key with
" +
$"Bobs public key information:
{Convert.ToBase64String(symmKey)}");
using (var aes = new AesCryptoServiceProvider())
{
aes.Key = symmKey;
aes.GenerateIV();
using (ICryptoTransform encryptor =
aes.CreateEncryptor())
using (var ms = new MemoryStream())
{
// create CryptoStream and encrypt data to send
using (var cs = new CryptoStream(ms, encryptor,
CryptoStreamMode.Write))
{
// write initialization vector not encrypted
await ms.WriteAsync(aes.IV, 0, aes.IV.Length);
cs.Write(rawData, 0, rawData.Length);
}
encryptedData = ms.ToArray();
}
aes.Clear();
}
}
Console.WriteLine("Alice: message is encrypted: "+
$"{Convert.ToBase64String(encryptedData)}");


Console.WriteLine();
return encryptedData;
}
Bob receives the encrypted data in the argument of the method
BobReceivesDataAsync . First, the unencrypted initialization vector must
be read. The BlockSize property of the class AesCryptoServiceProvider
returns the number of bits for a block. The number of bytes can be
calculated by dividing by 8, and the fastest way to do this is by doing a
bit shift of 3 bits (shifting by 1 bit is a division by 2, 2 bits by 4, and 3
bits by 8). With the for loop, the first bytes of the raw bytes that
contain the IV unencrypted are written to the array iv . Next, an
ECDiffieHellmanCng object is instantiated with the key pair from Bob.
Using the public key from Alice, the symmetric key is returned from
the method DeriveKeyMaterial .
Comparing the symmetric keys created from Alice and Bob shows that
the same key value is created. Using this symmetric key and the
initialization vector, the message from Alice can be decrypted with the
AesCryptoServiceProvider class:
public async Task BobReceivesDataAsync(byte[] encryptedData)
{
Console.WriteLine("Bob receives encrypted data");
byte[] rawData = null;
var aes = new AesCryptoServiceProvider();
int nBytes = aes.BlockSize 3;
byte[] iv = new byte[nBytes];
for (int i = 0; i < iv.Length; i++)
{
iv[i] = encryptedData[i];
}
using (var bobAlgorithm = new ECDiffieHellmanCng(bobKey))
using (CngKey alicePubKey = CngKey.Import(alicePubKeyBlob,
CngKeyBlobFormat.EccPublicBlob))
{
byte[] symmKey =
bobAlgorithm.DeriveKeyMaterial(alicePubKey);
Console.WriteLine("Bob creates this symmetric key with "
+
$"Alices public key information:
{Convert.ToBase64String(symmKey)}");
aes.Key = symmKey;
aes.IV = iv;


using (ICryptoTransform decryptor =
aes.CreateDecryptor())
using (MemoryStream ms = new MemoryStream())
{
using (var cs = new CryptoStream(ms, decryptor,
CryptoStreamMode.Write))
{
await cs.WriteAsync(encryptedData, nBytes,
encryptedData.Length - nBytes);
}
rawData = ms.ToArray();
Console.WriteLine("Bob decrypts message to: " +
$"{Encoding.UTF8.GetString(rawData)}");
}
aes.Clear();
}
}
Running the application returns output like the following. The
message from Alice is encrypted, and then decrypted by Bob with the
securely exchanged symmetric key.
Alice sends message: this is a secret message for Bob
Alice creates this symmetric key with Bobs public key
information:
q4D182m7lyev9Nlp6f0av2Jvc0+LmHF5zEjXw1O1I3Y=
Alice: message is encrypted:
WpOxvUoWH5XY31wC8aXcDWeDUWa6zaSObfGcQCpKixzlTJ9exb
tkF5Hp2WPSZWL9V9n13toBg7hgjPbrVzN2A==
Bob receives encrypted data
Bob creates this symmetric key with Alices public key
information:
q4D182m7lyev9Nlp6f0av2Jvc0+LmHF5zEjXw1O1I3Y=
Bob decrypts message to: this is a secret message for Bob
Signing and Hashing Using RSA
A new cryptography algorithm class is RSACng . RSA (the name comes
from the algorithm designers Ron Rivest, Adi Shamir, and Leonard
Adlerman) is an asymmetric algorithm that is widely used. Although
the RSA algorithm was already available with .NET with the RSA and
RSACryptoServiceProvider classes, RSACng is a class based on the CNG
API and is similar in use to the ECDSACng class shown earlier.
With the sample application shown in this section, Alice creates a


document, hashes it to make sure it doesn’t get changed, and signs it
with a signature to guarantee that the document is generated by Alice.
Bob receives the document and checks the guarantees from Alice to
make sure the document hasn’t been tampered with.
The RSA sample code makes use of the following dependency and
namespaces:
Dependency
System.Security.Cryptography.Cng
Namespaces
System
System.IO
System.Linq
The Main method of the application is structured to start with Alice’s
tasks to invoke the method AliceTasks to create a document, a hash
code, and a signature. This information is then passed to Bob’s tasks to
invoke the method BobTasks (code file RSASample/Program.cs ):
class Program
{
private CngKey _aliceKey;
private byte[] _alicePubKeyBlob;
static void Main()
{
var p = new Program();
p.Run();
}
public void Run()
{
AliceTasks(out byte[] document, out byte[] hash, out
byte[] signature);
BobTasks(document, hash, signature);
}
//...
}
The method AliceTasks first creates the keys needed by Alice, converts
the message to a byte array, hashes the byte array, and adds a
signature:
public void AliceTasks(out byte[] data, out byte[] hash, out


byte[] signature)
{
InitAliceKeys();
data = Encoding.UTF8.GetBytes("Best greetings from Alice");
hash = HashDocument(data);
signature = AddSignatureToHash(hash, _aliceKey);
}
Like before, the keys needed by Alice are created using the CngKey
class. As the RSA algorithm is being used now, the enumeration value
CngAlgorithm.Rsa is passed to the Create method to create public and
private keys. Only the public key is given to Bob, so the public key is
extracted with the Export method:
private void InitAliceKeys()
{
_aliceKey = CngKey.Create(CngAlgorithm.Rsa);
_alicePubKeyBlob =
_aliceKey.Export(CngKeyBlobFormat.GenericPublicBlob);
}
The HashDocument method is invoked from Alice’s tasks to create a hash
code for the document. The hash code is created using one of the hash
algorithm classes: SHA384. No matter how long the document is, the
hash code always has the same length. Creating the hash code for the
same document again results in the same hash code. Bob needs to use
the same algorithm on the document. If the same hash code is
returned, the document hasn’t been changed.
private byte[] HashDocument(byte[] data)
{
using (var hashAlg = SHA384.Create())
{
return hashAlg.ComputeHash(data);
}
}
Adding a signature guarantees that the document is from Alice. Here,
the hash is signed using the RSACng class. Alice’s CngKey , including the
public and private keys, is passed to the constructor of the RSACng
class; the signature is created by invoking the SignHash method. When
the hash is signed, the SignHash method needs to know about the
algorithm of the hash; HashAlgorithmName.SHA384 is the algorithm that


was used to create the hash. Also, the RSA padding is needed. Possible
options with the RSASignaturePadding enumeration are Pss and Pkcs1 :
private byte[] AddSignatureToHash(byte[] hash, CngKey key)
{
using (var signingAlg = new RSACng(key))
{
byte[] signed = signingAlg.SignHash(hash,
HashAlgorithmName.SHA384, RSASignaturePadding.Pss);
return signed;
}
}
After hashing and signing from Alice, Bob’s tasks can start in the
method BobTasks . Bob receives the document data, the hash code, and
the signature, and he uses Alice’s public key. First, Alice’s public key is
imported using CngKey.Import and assigned to the aliceKey variable.
Next, Bob uses the helper methods IsSignatureValid and
IsDocumentUnchanged to verify whether the signature is valid and the
document unchanged. Only if both conditions are true, the document
is written to the console:
public void BobTasks(byte[] data, byte[] hash, byte[]
signature)
{
CngKey aliceKey = CngKey.Import(_alicePubKeyBlob,
CngKeyBlobFormat.GenericPublicBlob);
if (!IsSignatureValid(hash, signature, aliceKey))
{
Console.WriteLine("signature not valid");
return;
}
if (!IsDocumentUnchanged(hash, data))
{
Console.WriteLine("document was changed");
return;
}
Console.WriteLine("signature valid, document unchanged");
Console.WriteLine($"document from Alice:
{Encoding.UTF8.GetString(data)}");
}
To verify if the signature is valid, the public key from Alice is used to
create an instance of the RSACng class. With this class, the VerifyHash


method is used to pass the hash, signature, and algorithm information
that was used earlier. Now Bob knows the information is from Alice:
private bool IsSignatureValid(byte[] hash, byte[] signature,
CngKey key)
{
using (var signingAlg = new RSACng(key))
{
return signingAlg.VerifyHash(hash, signature,
HashAlgorithmName.SHA384,
RSASignaturePadding.Pss);
}
}
To verify that the document data is unchanged, Bob hashes the
document again and uses the LINQ extension method SequenceEqual
to verify whether the hash code is the same as was sent earlier. If the
hashes are the same, it can be assumed that the document was not
changed:
private bool IsDocumentUnchanged(byte[] hash, byte[] data)
{
byte[] newHash = HashDocument(data);
return newHash.SequenceEqual(hash);
}
When you run the application, you see output like what’s shown here.
When you debug the application, you can change the document data
after it’s hashed by Alice and see that Bob doesn’t accept the changed
document. To change the document data, you can easily change the
value in the Watch window of the debugger.
signature valid, document unchanged
document from Alice: Best greetings from Alice
PROTECTING DATA
After encrypting, signing, and hashing data, let’s move the abstraction
layer higher. This section gets into protecting data——storing security-
sensitive data. When data is used with web applications, the client
used cannot be trusted. This is where the data protection API takes
place.


Another kind of data that needs to be protected is configuration data.
Configuration data——such as SQL connection strings (including
username and password) or some access tokens to AWS or Microsoft
Azure——shouldn’t be put into a public source code repository. This
information can easily be misused. Indeed, bots are used to crawl over
public GitHub repositories to find secret keys and use them, for
example to spin up virtual machines to farm Bitcoins. App Secrets
offer a way for storing secrets in a user profile.
Both these technologies, data protection and user secrets, are covered
in this section.
Implementing Data Protection
With the .NET Framework, the namespace
System.Security.DataProtection contains a DpApiDataProtector class
that wraps the native Windows Data Protection API (DPAPI). Because
these classes are based on Windows, they do not offer the flexibility
and features needed with .NET Core, that’s why the ASP.NET team
created classes with the Microsoft.AspNetCore.DataProtection
namespace.
With this library, trusted information can be stored for later retrieval,
and the storage media (such as using hosting environments from a
third party) cannot be trusted itself, so the information needs to be
stored encrypted on the host.
The sample application is a simple Console App (.NET Core) that
enables you to read and write information using data protection. With
this sample, you see the flexibility and features of the ASP.NET data
protection.
The data protection sample code makes use of the following
dependencies and namespaces:
Dependencies
Microsoft.AspNetCore.DataProtection
Microsoft.Extensions.DependencyInjection


Namespaces
Microsoft.AspNetCore.DataProtection
Microsoft.Extensions.DependencyInjection
System
System.IO
System.Linq
You can start the console application by using the -r and -w command-
line arguments to either read or write from the storage. Also, you need
to use the command line to set a filename to read and write. After
checking the command-line arguments, the data protection is
initialized calling the SetupDataProtection helper method. This
method returns an object of type MySafe that embeds an
IDataProtector . After that, depending on the command-line
arguments, either the Write or Read method is invoked (code file
DataProtectionSample/Program.cs ):
class Program
{
private const string readOption = "-r";
private const string writeOption = "-w";
private readonly string[] options = { readOption,
writeOption };
static void Main(string[] args)
{
if (args.Length != 2 || args.Intersect(options).Count()
!= 1)
{
ShowUsage();
return;
}
string fileName = args[1];
MySafe safe = SetupDataProtection();
switch (args[0])
{
case writeOption:
Write(safe, fileName);
break;
case readOption:


Read(safe, fileName);
break;
default:
ShowUsage();
break;
}
}
//...
}
The class MySafe holds a member of IDataProtector . This interface
defines the members Protect and Unprotect to encrypt and decrypt
data. This interface defines Protect and Unprotect methods with byte
array arguments and returning byte arrays. However, the sample code
directly sends and returns strings from the Encrypt and Decrypt
methods using extension methods that are defined within the
Microsoft.AspNetCore.DataProtection.Abstractions NuGet package.
The MySafe class receives an IDataProtectionProvider interface via
dependency injection. With this interface, a IDataProtector is returned
passing a purpose string. The same string needs to be used when
reading and writing from this safe (code file
DataProtectionSample/MySafe.cs ):
public class MySafe
{
private IDataProtector _protector;
public MySafe(IDataProtectionProvider provider) =>
_protector =
provider.CreateProtector("MySafe.MyProtection.v2");
public string Encrypt(string input) =>
_protector.Protect(input);
public string Decrypt(string encrypted) =>
_protector.Unprotect(encrypted);
}
With the SetupDataProtection method, the AddDataProtection
extension method is invoked to add data protection via dependency
injection, and to configure it. The AddDataProtection method registers
default services and returns an IDataProtectionBuilder that can be
used to configure data protection further using a fluent API. The
sample code persists the key to the actual directory passing a
DirectoryInfo instance to the method PersistKeysToFileSystem .


Another option is to persist the key to the registry
( PersistKeysToRegistry ), and you can create your own method to
persist the key to a custom store. The lifetime of the created keys is
defined by the method SetDefaultKeyLifetime . Next, the keys are
protected by calling ProtectKeysWithDpapi . This method protects the
keys using the DPAPI, which encrypts the stored keys with the current
user. ProtectKeysWithCertificate allows using a certificate for key
protection. The API also defines the method
UseEphemeralDataProtectionProvider in which keys are stored just in
memory. When the application is started again, new keys need to be
generated. This is a great feature for unit testing (code file
DataProtectionSample/Program.cs ):
public static MySafe SetupDataProtection()
{
var serviceCollection = new ServiceCollection();
serviceCollection.AddDataProtection()
.PersistKeysToFileSystem(new DirectoryInfo("."))
.SetDefaultKeyLifetime(TimeSpan.FromDays(20))
.ProtectKeysWithDpapi();
IServiceProvider services =
serviceCollection.BuildServiceProvider();
return ActivatorUtilities.CreateInstance<MySafe>(services);
}
**NOTE**
Dependency injection is explained in detail in Chapter 20,
“Dependency Injection.”
Now the heart of the data protection application is implemented, and
the Write and Read methods can take advantage of MySafe to encrypt
and decrypt the user’s content:
public static void Write(MySafe safe, string fileName)
{
Console.WriteLine("enter content to write:");


string content = Console.ReadLine();
string encrypted = safe.Encrypt(content);
File.WriteAllText(fileName, encrypted);
Console.WriteLine($"content written to {fileName}");
}
public static void Read(MySafe safe, string fileName)
{
string encrypted = File.ReadAllText(fileName);
string decrypted = safe.Decrypt(encrypted);
Console.WriteLine(decrypted);
}
User Secrets
Having the connection string in the configuration file is not a big
problem as long as Windows authentication is used. When you store
username and password with the connection string, it can be a big
issue to add the connection string to a configuration file and store the
configuration file along with the source code repository. Having a
public repository and storing Amazon or Azure keys with the
configuration can lead to losing thousands of dollars very quickly.
Hackers’ background jobs comb through public GitHub repositories to
find Amazon keys to hijack accounts and create virtual machines for
making Bitcoins. Visit https://www.humankode.com/security/how-a-
bug-in-visual-studio-2015-exposed-my-source-code-on-github-and-
cost-me-6500-in-a-few-hours to find out more about the situation.
.NET Core has some mitigations around this: user secrets. With user
secrets, configuration is not stored in a configuration file of the
project; it is stored in a configuration file associated with your account.
The user secrets sample code makes use of the following dependencies
and namespaces:
Dependencies
Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.CommandLine
Microsoft.Extensions.Configuration.EnvironmentVariables
Microsoft.Extensions.Configuration.Json


Microsoft.Extensions.Configuration.UserSecrets
Namespaces
Microsoft.Extensions.Configuration
System
System.IO
To have the user secrets command-line extension for the dotnet CLI
tools, a reference to Microsoft.Extensions.SecretManager.Tools needs
to be added to the csproj file (project file
UserSecretsSample/UserSecretsSample.csproj ):
<ItemGroup>
<DotNetCliToolReference
Include="Microsoft.Extensions.SecretManager.Tools"
Version="2.0.0" />
</ItemGroup>
In addition, you need to define an initial ID by adding a value to the
UserSecretsId element in the project file (project file
UserSecretsSample/UserSecretsSample.csproj ):
<PropertyGroup>
<OutputType>Exe</OutputType>
<TargetFramework>netcoreapp2.0</TargetFramework>
<UserSecretsId>UserSecretsSample-Id</UserSecretsId>
</PropertyGroup>
This secret ID just needs to be unique on your local system to not mix
up configuration values from different projects. Thus, it’s a good idea
to have the project name contained in the identifier.
The sample application defines using configuration from a JSON file,
environmental variables, the command line, and user secrets. User
secrets are configured to invoke the extension method AddUserSecrets
with the ConfigurationBuilder . This provider is added only if the
application is built with debug mode enabled. Remember, this
provider is available only when you’re running the application with the
user profile that has user secrets enabled. The overloaded method of
AddUserSecrets requires the user secrets ID as a parameter——the same


identifier that has been used with the configuration (code file
UserSecretsSample/Program.cs ):
static void Main(string[] args)
{
var configBuilder = new ConfigurationBuilder();
configBuilder.SetBasePath(Directory.GetCurrentDirectory())
.AddJsonFile("appsettings.json")
.AddEnvironmentVariables()
.AddCommandLine(args);
#if DEBUG
configBuilder.AddUserSecrets("UserSecretsSample-Id");
#endif
IConfigurationRoot configuration = configBuilder.Build();
//...
}
**NOTE**
Read more about application configuration with
Microsoft.Extensions.Configuration in Chapter 30, “ASP.NET
Core.”
With the JSON configuration file appsettings.json , a value to the key
NotASecret is written. This configuration file should not contain
sensitive configuration information when the project is added to a
public source code repository (configuration file
UserSecretsSample/appsettings.json ):
{
"NotASecret": "this is not a secret"
}
Because the SecretManager tool has been configured with the project
file, you can use the dotnet command-line tool to set, list, remove, and
clear secrets. The following command sets the secret with the key
Secret1 :
> dotnet user-secrets set Secret1 "this is a secret"


Use dotnet user-secrets list to show all user secrets, and dotnet
user-secrets clear to remove all user secrets.
On a Windows system, user secrets are stored in the folder
%APPDATA%\microsoft\UserSecrets\<userSecretsId>\secrets.json .
On
a Linux system, the secrets are stored in
~/.microsoft/usersecrets/<userSecretsId>/secrets.json .
To read the configuration values, no matter where the configuration is
stored, the variable of type IConfigurationRoot can be used. Using the
indexer, the values stored with the corresponding keys can be read, no
matter whether the configuration was stored in the JSON file or with
user secrets (code file UserSecretsSample/Program.cs ):
string notASecret1 = configuration["NotASecret"];
Console.WriteLine($"not a secret: {notASecret1}");
string secretValue1 = configuration["Secret1"];
Console.WriteLine($"secret: {secretValue1}");
On the production system, the private profile where the user secrets
are stored are not available. Depending on the technology used,
different providers can be used. For example, with Azure App Services,
configuration can be configured with the Azure portal, and retrieved
using environmental variables. You also can use the Azure Key Vault
configuration provider to read configuration from Azure Key Vault
secrets.
ACCESS CONTROL TO RESOURCES
Operating system resources such as files and registry keys, as well as
handles of a named pipe, are secured by using an access control list
(ACL). Figure 24-2 shows the structure mapping this. Associated with
the resource is a security descriptor that contains information about
the owner of the resource. It references two access control lists: a
discretionary access control list (DACL) and a system access control
list (SACL). The DACL defines who has access; the SACL defines audit
rules for security event logging. An ACL contains a list of access
control entries (ACEs), which contain a type, a security identifier, and
rights. With the DACL, the ACE can be of type access allowed or access


denied. Some of the rights that you can set and get with a file are
create, read, write, delete, modify, change permissions, and take
ownership.
FIGURE 24-2
The classes to read and modify access control are in the namespace
System.Security.AccessControl . The following program demonstrates
reading the access control list from a file.
The sample application FileAccessControl makes use of the following
dependencies and namespaces:
Dependencies
System.IO.FileSystem
System.IO.FileSystem.AccessControl
Namespaces
System
System.IO
System.Security.AccessControl
System.Security.Principal


**WARNING**
Access control APIs are available only on Windows, not on Linux
or Mac. System.IO.FileSystem.AccessControl APIs are part of the
resource management on Windows.
The FileStream class defines the GetAccessControl method, which
returns a FileSecurity object. FileSecurity is the .NET class that
represents a security descriptor for files. FileSecurity derives from the
base classes ObjectSecurity , CommonObjectSecurity ,
NativeObjectSecurity , and FileSystemSecurity . Other classes that
represent a security descriptor are CryptoKeySecurity ,
EventWaitHandleSecurity , MutexSecurity , RegistrySecurity ,
SemaphoreSecurity , PipeSecurity , and ActiveDirectorySecurity . All
these objects can be secured using an ACL. In general, the
corresponding .NET class defines the method GetAccessControl to
return the corresponding security class; for example, the
Mutex.GetAccessControl method returns a MutexSecurity , and the
PipeStream.GetAccessControl method returns a PipeSecurity .
The FileSecurity class defines methods to read and change the DACL
and SACL. The method GetAccessRules returns the DACL in the form
of the class AuthorizationRuleCollection . To access the SACL, you can
use the method GetAuditRules .
With the method GetAccessRules , you can specify whether inherited
access rules, and not only access rules directly defined with the object,
should be used. The last parameter defines the type of the security
identifier that should be returned. This type must derive from the base
class IdentityReference . Possible types are NTAccount and
SecurityIdentifier . Both these classes represent users or groups; the
NTAccount class finds the security object by its name and the
SecurityIdentifier class finds the security object by a unique security
identifier.
The returned AuthorizationRuleCollection contains
AuthorizationRule objects. The AuthorizationRule is the .NET


representation of an ACE. In the following example, a file is accessed,
so the AuthorizationRule can be cast to a FileSystemAccessRule . With
ACEs of other resources, different .NET representations exist, such as
MutexAccessRule and PipeAccessRule . With the FileSystemAccessRule
class, the properties AccessControlType , FileSystemRights , and
IdentityReference return information about the ACE (code file
FileAccessControl/Program.cs ).
class Program
{
static void Main(string[] args)
{
string filename = null;
if (args.Length == 0) return;
filename = args[0];
using (FileStream stream = File.Open(filename,
FileMode.Open))
{
FileSecurity securityDescriptor =
stream.GetAccessControl();
AuthorizationRuleCollection rules =
securityDescriptor.GetAccessRules(true, true,
typeof(NTAccount));
foreach (AuthorizationRule rule in rules)
{
var fileRule = rule as FileSystemAccessRule;
Console.WriteLine($"Access type:
{fileRule.AccessControlType}");
Console.WriteLine($"Rights:
{fileRule.FileSystemRights}");
Console.WriteLine($"Identity:
{fileRule.IdentityReference.Value}");
Console.WriteLine();
}
}
}
}
By running the application and passing a filename, you can see the
ACL for the file. The following output lists full control to
Administrators and System, modification rights to authenticated
users, and read and execute rights to all users belonging to the group
Users:
Access type: Allow


Rights: FullControl
Identity: BUILTIN\Administrators
Access type: Allow
Rights: FullControl
Identity: NT AUTHORITY\SYSTEM
Access type: Allow
Rights: FullControl
Identity: BUILTIN\Administrators
Access type: Allow
Rights: FullControl
Identity: TheOtherSide\Christian
Setting access rights is very similar to reading access rights. To set
access rights, several resource classes that can be secured offer the
SetAccessControl and ModifyAccessControl methods. The following
code modifies the ACL of a file by invoking the SetAccessControl
method from the File class. To this method a FileSecurity object is
passed. The FileSecurity object is filled with FileSystemAccessRule
objects. The access rules listed here deny write access to the Sales
group, give read access to the Everyone group, and give full control to
the Developers group:
**NOTE**
This program runs on your system only if the Windows groups
Sales and Developers are defined. You can change the program to
use groups that are available in your environment.
private void WriteAcl(string filename)
{
var salesIdentity = new NTAccount("Sales");
var developersIdentity = new NTAccount("Developers");
var everyOneIdentity = new NTAccount("Everyone");
var salesAce = new FileSystemAccessRule(salesIdentity,
FileSystemRights.Write, AccessControlType.Deny);
var everyoneAce = new
FileSystemAccessRule(everyOneIdentity,
FileSystemRights.Read, AccessControlType.Allow);
var developersAce = new
FileSystemAccessRule(developersIdentity,
FileSystemRights.FullControl, AccessControlType.Allow);


var securityDescriptor = new FileSecurity();
securityDescriptor.SetAccessRule(everyoneAce);
securityDescriptor.SetAccessRule(developersAce);
securityDescriptor.SetAccessRule(salesAce);
File.SetAccessControl(filename, securityDescriptor);
}
**NOTE**
You can verify the access rules by opening the Properties window
and selecting a file in Windows Explorer. Select the Security tab to
see the ACL.
WEB SECURITY
Web applications have some specific security issues you need to be
aware of with applications that allow user input. User input cannot be
trusted. Verifying input data on the client using JavaScript or built-in
HTML5 features is only for the convenience of the user. Errors can be
shown without making an extra network request to the server.
However, the client cannot be trusted. HTTP requests can be
intercepted, and the user (a hacker) can make different requests that
bypass the HTML5 and JavaScript validation.
This section looks at common issues with web applications, and what
you need to be aware of avoiding the issues.
**NOTE**
This section makes use of ASP.NET Core and ASP.NET MVC. Read
Chapter 30 and Chapter 31, “ASP.NET Core MVC” for more
information on these technologies.
Encoding


Never trust user input. Writing user information to a database and
using this information to display on a website can be the cause of a
typical hack. For example, a community website was showing the
latest five new users on the home page. One of the new users managed
to add a script to the username, and the script did a redirect to a
malicious website. Because the user information was shown for every
user coming to this site, every user was redirected.
Let’s have a look at how easy it is to simulate and to avoid such a
behavior with the next example. In the following code snippet, the
/echo URL is mapped to an answer that returns the input from the
user assigned to the x parameter that sends the response using
context.Response.WriteAsync (code file
ASPNETCoreMVCSecurity/Startup.cs ):
app.Map("/echo", app1 =>
{
app1.Run(async context =>
{
string data = context.Request.Query["x"];
await context.Response.WriteAsync(data);
});
});
Now passing the request
http://localhost:24897/echo?x=I'm a nice user
The string I'm a nice user is returned to the browser. This is not that
bad, but users can’t play differently. For example, users can input
HTML code such as this:
http://localhost:24897/echo?x=<h1>Is this wanted?</h1>
The result shows the input string is formatted with the HTML H1 tag.
Users can do more bad things by entering JavaScript code:
localhost:24897/echo?x=<script>alert("this is bad");</script>
In most browsers, a pop-up window where the user entered text shows
up. In case you try this with Google Chrome, there’s a separate
measure to avoid this issue. This browser shows an error page, This


page isn't working with additional
ERR_BLOCKED_BY_XSS_AUDITOR .
information
If you try to avoid this issue by checking for <script> elements with
the input and not return a thing in that case, you’ll likely fail. Instead
of using the <script> element, users can also use Unicode numbers for
the angle brackets with the same result. Instead, let’s encode the user
input to not let it be interpreted by the browser.
You can use the HTMLEncoder class from the namespace
System.Text.Encodings.Web to encode user input:
app.Map("/echoenc", app1 =>
{
app1.Run(async context =>
{
string data = context.Request.Query["x"];
await
context.Response.WriteAsync(HtmlEncoder.Default.Encode(data));
});
});
When you use HtmlEncoder class, the user can enter <h1> elements with
the input http://localhost:24897/echoenc?x=<h1>this gets
converted</h1> . As result, <h1>this gets converted</h1> is shown in
the browser. The < character is encoded to &lt; , and thus displayed as
text. The complete encoded string is:
&lt;h1&gt;this gets converted&lt;/h1&gt;
Similarly, the script element is converted and doesn’t run as script in
the browser.
**NOTE**
You can use the HtmlEncoder class to allow specific inputs to go
through——for example, you might allow the user to add <b>
elements. You can create an encoder with accepted inputs using
the HtmlEncoder.Create method. Nowadays a preferred method is


to allow the user to make some formatting by using Markdown
and converting Markdown to HTML. You can read my blog
article about Markdown at
https://csharp.christiannagel.com/2016/07/03/markdown/ .
The sample code has so far made use of ASP.NET Core functionality.
When you directly return a string from an ASP.NET Core MVC
controller or inside a view, encoding happens by default. You need to
make extra investment to not encode the result here.
Just returning a string with an ASP.NET Core controller results in an
encoded string (code file
ASPNETCoreMVCSecurity/Controllers/HomeController.cs ):
public string Echo(string x) => x;
To send an unencoded string, the Content method of the Controller
base class can be used, and you specify that the content is returned as
text/html:
public IActionResult EchoUnencoded(string x) => Content(x,
"text/html");
Let’s go a step further on using Razor code in a view. Here, the
EchoWithView method passes the input data from the user using
ViewBag.SampleData to a view (code file
ASPNETCoreMVCSecurity/Controllers/HomeController.cs ):
public IActionResult EchoWithView(string x)
{
ViewBag.SampleData = x;
return View();
}
In the view, encoding happens by default. Passing the input data using
the Razor expression @data . data is a local variable where the passed
ViewBag information is assigned. For not making use of encoding, the
Html helper class with the method Raw can be used (code file
ASPNETCoreMVCSecurity/Views/Home/EchoWithView.cshtml ):
@{
string data = ViewBag.SampleData;


}
<div>
this is encoded
</div>
<div>@data</div>
<br />
<div>
This is not encoded
</div>
<div>
@Html.Raw(@data)
</div>
**NOTE**
When explicitly sending unencoded data to the client, you need to
make sure the input can be trusted——for example, HTML
converted from Markdown instead of directly returning user
input.
**NOTE**
You can use the UrlEncoder class when using user input for URL
strings similarly to how you use the HtmlEncoder class when using
user input as HTML content.
SQL Injection
Another common problem with web applications is SQL injection. As
with HTML encoding, the issue can easily be avoided by using built-in
functionality.
The following code snippet creates a SQL string that directly assigns
the input parameter in the SqlSample controller method. With this, the
user can enter ;SELECT * FROM Table Users , and all this information is


shown to the user:
public IActionResult SqlSample(string id)
{
string connectionString = GetConnectionString();
var sqlConnection = new SqlConnection(connectionString);
SqlCommand command = sqlConnection.CreateCommand();
// don't do this - string concatenation for SQL commands!
command.CommandText = "SELECT * FROM Customers WHERE City =
" + id;
sqlConnection.Open();
using (SqlDataReader reader =
command.ExecuteReader(System.Data.CommandBehavior.CloseConnection))
{
var sb = new StringBuilder();
while (reader.Read())
{
for (int i = 0; i < reader.FieldCount; i++)
{
sb.Append(reader[i]);
}
sb.AppendLine();
}
ViewBag.Data = sb.ToString();
}
return View(); }
You should never use string concatenation with SQL statements.
Instead, you can easily avoid this problem by using parameters or
implicitly using Entity Framework Core parameters.
**NOTE**
Using SQL commands is covered in Chapter 25, “ADO.NET and
Transactions.” Entity Framework Core is covered in Chapter 26,
“Entity Framework Core.”
Cross-Site Request Forgery


Cross-site request forgery (XSRF) is an attack in which a malicious
website tries to replay a user and enter data without the user knowing.
Let’s get into an example where the user enters book information in a
form. Book is a simple model class containing Title and Publisher
properties. Within the HomeController , the EditBook method returns a
view (code file
ASPNETCoreMVCSecurity/Controllers/HomeController.cs ):
public IActionResult EditBook() => View();
The view defines simple input data where the user can enter title and
publisher information, and pass this information to the server with a
HTTP POST request (code file
ASPNETCoreMVCSecurity/Views/EditBook.cshtml ):
@{
ViewData["Title"] = "EditBook";
}
<h2>Edit Book</h2>
<form asp-controller="Home" asp-action="EditBook"
method="post">
<label for="title">Title:</label>
<input type="text" id="title" name="title" />
<br />
<label for="publisher">Publisher:</label>
<input type="text" id="publisher" name="publisher" />
<br />
<input type="submit" value="Submit" />
</form>
With the HTTP POST request, the following EditBook method is
invoked to display a view with the entered user data (code file
ASPNETCoreMVCSecurity/Controllers/HomeController.cs ):
[HttpPost]
public IActionResult EditBook(Book book) =>
View("EditBookResult", book);
When you run the application while opening the URL
http://localhost:24897/Home/EditBook , book information can be
entered, the submit button clicked, the information is received from
the controller, and the book information is shown in the view result.


Meanwhile, a malicious website just needs to use the same link to post
the data in its own form. Check the following code snippet with the
form element referencing the same URL as before. This form is hosted
from a different website, http//localhost:9817/dothis.html . Here it’s
only a different port, but it could be a different domain name as well.
The user doesn’t need to enter anything with the form (the input
elements are hidden, thus not shown to the user). The user just needs
to click the submit button without knowing something different
happens behind the scenes (code file
HackingSite/wwwroot/dothis.html ):
<h1>Click this for a win!</h1>
<!-- form has a redirect to the website being hacked -->
<form action="http://localhost:24897/Home/EditBook"
method="post">
<input type="hidden" value="bad book title" name="title" />
<input type="hidden" value="bad publisher" name="publisher"
/>
<input type="submit" value="Click Now!" />
</form>
When you click this link, the malicious data is transmitted to the
website on behalf of the user. If the user is authenticated with the
Book website and didn’t sign out, the data is submitted on behalf of
the user, and probably some ordering happened with a different
delivery address.
To avoid this behavior, ASP.NET Core offers anti forgery tokens. Such
a token needs to be created from the form that should be used from
the user to enter valid data and is validated on receiving the data.
The edit book form is now changed to include this token with the
HTML helper method AntiForgeryToken (code file
ASPNETCoreMVCSecurity/Views/EditBook.cshtml ):
<form asp-controller="Home" asp-action="EditBook"
method="post">
@Html.AntiForgeryToken()
<label for="title">Title:</label>
<input type="text" id="title" name="title" />
<br />


<label for="publisher">Publisher:</label>
<input type="text" id="publisher" name="publisher" />
<br />
<input type="submit" value="Submit" />
</form>
When you run the application, you can see a hidden form field with
the automatically generated token. When the data is retrieved, the
token is validated using the ValidateAntiForgeryToken attribute (code
file ASPNETCoreMVCSecurity/Controllers/HomeController.cs ):
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult EditBook(Book book) =>
View("EditBookResult", book);
When you run the malicious website now, a response is returned
without accepting invalid data.
SUMMARY
This chapter covered several aspects of security with .NET
applications. Users are represented by identities and principals,
classes that implement the interface IIdentity and IPrincipal . You’ve
also seen how to access claims from identities.
A brief overview of cryptography demonstrated how the signing and
encrypting of data enable the exchange of keys in a secure way. .NET
offers both symmetric and asymmetric cryptography algorithms as
well as hashing and signing.
With access control lists you can read and modify access to operating
system resources such as files. You program ACLs similarly to the way
you program secure pipes, registry keys, Active Directory entries, and
many other operating system resources.
In many cases you can work with security from higher abstraction
levels. For example, using HTTPS to access a web server, keys for
encryption are exchanged behind the scenes. The File class offers an
Encrypt method (using the NTFS file system) to easily encrypt files.
Still it’s important to know what happens behind this functionality.


Regarding web applications, you’ve seen common issues on trusting
user input that results in various attacks, including cross-site request
forgery. You’ve seen how various issues can be avoided using encoding
and anti-forgery request tokens to avoid XSRF.
The next two chapters make use of data in the database, starting with
ADO.NET.