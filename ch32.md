

Web API
WHAT’S IN THIS CHAPTER?
Overview of the ASP.NET Web API
Creating Web API controllers
Using repositories with dependency injection
Creating .NET clients calling REST APIs
Using Entity Framework Core from services
Creating Metadata using Swagger
Using OData
Implementing Azure Functions
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory API .
The code for this chapter is divided into the following major
examples:
Book Service Sample


Book Service Async Sample
Book Service Client App
Book Service OData
Book Service Azure Functions
OVERVIEW
When Windows Communication Foundation (WCF) was announced
with .NET 3.0, it was the technology for communication and replaced
several other technologies in the .NET stack (a few mentioned here are
.NET Remoting and ASP.NET Web Services). The goal was to have one
communication technology that is very flexible and fulfills all needs.
However, WCF was initially based on SOAP (Simple Object Access
Protocol). Nowadays we have many scenarios where the powerful
SOAP enhancements are not needed. For simpler scenarios such as
HTTP requests returning JSON, WCF is too complex. That’s why
another technology was introduced in 2012: ASP.NET Web API. With
the release of ASP.NET Core, the third major version of a Web API
using an ASP.NET technology was released.
ASP.NET MVC and ASP.NET Web API previously had different types
and configurations (the previous versions were ASP.NET MVC 5 and
ASP.NET Web API 2), but the Web API from ASP.NET Core is the
same as the one from ASP.NET Core MVC.
The Web API offers a simple communication technology based on
Representational State Transfer (REST). REST is an architecture style
based on some constraints. Let’s compare a service that is based on the
REST architectural style with a service that makes use of SOAP to see
these constraints.
Both REST services and services making use of the SOAP protocol
make use of a client-server technology. SOAP services can be stateful
or stateless; REST services are always stateless. SOAP defines its own
message format with a header and body to select a method of the
service. With REST, HTTP verbs such as GET, POST, PUT, and
DELETE are used. GET is used to retrieve resources, POST to add new


resources, PUT to update resources, and DELETE to delete resources.
This chapter takes you through a journey that covers various
important aspects of the Web API using ASP.NET Core MVC—creating
a service, using different routing methods, creating a client, using
OData, securing the service, and using custom hosts. The chapter
shows you how you can take the same services created for hosting with
ASP.NET Core and use them from Microsoft Azure Functions, which is
another option to create a Web API with C# and .NET.
CREATING SERVICES
Let’s start with creating a service. Using .NET Core, you need to start
with an ASP.NET Core Web Application and select the Web API in the
following dialog (see Figure 32-1). This template adds folders and
references needed with the Web API. You can also use the template
Web Application (Model-View-Controller) in case you need both web
pages and services. With the sample code, this project is named
BooksServiceSampleHost in the solution BooksServiceSample .
NOTE
ASP.NET Core MVC is discussed in Chapter 31, “ASP.NET Core
MVC,” and the core technology that is the foundation of ASP.NET
Core MVC is covered in Chapter 30, “ASP.NET Core.”
The directory structure that is created with this template contains
folders that are needed for creating the services. The Controllers
directory contains the Web API controllers. You’ve seen such
controllers already in Chapter 31, and indeed, Web API and ASP.NET
Core MVC make use of the same infrastructure. This was not the case
with the .NET Framework version of ASP.NET. With the default
template, the ValuesController is created with a simple sample
implementation. In larger applications, it’s a good idea for separation
into multiple libraries. If you create a library containing services and
models, it’s an easy task to use the same types from different


technologies—for example, from Web API projects, as well as from
Azure Functions. The implementation of the Web API (the controller)
can also be in a library separate from the hosting application. From
the web application you can use controllers implemented in the
application’s own library. The libraries both for the services
( BookServices ) and the Web API ( APIBookServices ) are implemented
as .NET Standard 2.0 libraries. With the library APIBookServices , the
NuGet packages Microsoft.AspNetCore.Mvc.Core and
Microsoft.AspNetCore.Mvc.ViewFeatures need to be added to
implement the controller. Using the metadata package
Microsoft.AspNetCore.All , which you’ve used in previous chapters, is
not possible with a .NET Standard 2.0 library. This would need a .NET
Core 2.0 library.
FIGURE 32-1
Now, let’s start with the model. In the project BooksService , the Models
directory is for the data model. You can add your entity types to this
directory, as well as repositories that return model types.


The service that is created returns a list of book chapters and allows
adding and deleting chapters dynamically.
Defining a Model
First you need a type that represents the data to return and change.
The class defined in the Models directory has the name BookChapter
and includes simple properties to represent a chapter (code file
Sync/BookServices/Models/BookChapter.cs ):
public class BookChapter
{
public Guid Id { get; set; }
public int Number { get; set; }
public string Title { get; set; }
public int Pages { get; set; }
}
Creating a Service
Next, you create a service. The methods offered by the service are
defined with the interface IBookChaptersService —methods to retrieve,
add, and update book chapters (code file
Sync/BookServices/Services/IBookChaptersService.cs ):
public interface IBookChaptersService
{
void Add(BookChapter bookChapter);
void AddRange(IEnumerable<BookChapter> chapters);
IEnumerable<BookChapter> GetAll();
BookChapter Find(Guid id);
BookChapter Remove(Guid id);
void Update(BookChapter bookChapter);
}
The implementation of the service is defined by the class
BookChaptersService . The book chapters are kept in a collection class.
Because multiple tasks from different client requests can access the
collection concurrently, the type ConcurrentDictionary is used for the
book chapters. This class is thread safe. The Add , Remove , and Update
methods make use of the collection to add, remove, and update book
chapters (code file BookServices/Services/BookChaptersService.cs ):


public class BookChaptersService : IBookChaptersService
{
private readonly ConcurrentDictionary<Guid, BookChapter>
_chapters =
new ConcurrentDictionary<Guid, BookChapter>();
public void Add(BookChapter chapter)
{
chapter.Id = Guid.NewGuid();
_chapters[chapter.Id] = chapter;
}
public void AddRange(IEnumerable<BookChapter> chapters)
{
foreach (var chapter in chapters)
{
chapter.Id = Guid.NewGuid();
_chapters[chapter.Id] = chapter;
}
}
public BookChapter Find(Guid id)
{
_chapters.TryGetValue(id, out BookChapter chapter);
return chapter;
}
public IEnumerable<BookChapter> GetAll() =>
_chapters.Values;
public BookChapter Remove(Guid id)
{
BookChapter removed;
_chapters.TryRemove(id, out removed);
return removed;
}
public void Update(BookChapter chapter) =>
_chapters[chapter.Id] = chapter;
}
NOTE
With the sample code, the Remove method makes sure that the


passed with the id parameter is not in the dictionary.
If the dictionary already does not contain the book chapter, that’s
okay.
BookChapter
An alternative implementation of the Remove method can throw an
exception if the book chapter passed cannot be found. The
controller can change this error to return an HTTP not found
status code (404).
The Microsoft REST API guidelines
( https://github.com/Microsoft/api-
guidelines/blob/master/Guidelines.md )
specifies the DELETE
request to be idempotent, thus it should return the same result
with multiple requests.
NOTE
Concurrent collections are discussed in Chapter 11, “Special
Collections.”
So that some sample chapters are available when you first access of the
service, the class SampleChapters fills the book chapter service with
chapter information (code file
Sync/BookServices/Services/SampleChapter.cs ):
public class SampleChapters
{
private readonly IBookChaptersService _bookChaptersService;
public SampleChapters(IBookChaptersService
bookChapterService)
{
_bookChaptersService = bookChapterService;
}
private string[] sampleTitles = new[]
{
".NET Application Architectures",
"Core C#",
"Objects and Types",


"Object-Oriented Programming with C#",
"Generics",
"Operators and Casts",
"Arrays",
"Delegates, Lambdas, and Events",
"Windows Communication Foundation"
};
private int[] chapterNumbers = { 1, 2, 3, 4, 5, 6, 7, 8, 44
};
private int[] numberPages = { 35, 42, 33, 20, 24, 38, 20,
32, 44 };
public void CreateSampleChapters()
{
var chapters = new List<BookChapter>();
for (int i = 0; i < 8; i++)
{
chapters.Add(new BookChapter
{
Number = chapterNumbers[i],
Title = sampleTitles[i],
Pages = numberPages[i]
});
}
_bookChaptersService.AddRange(chapters);
}
}
In the hosting application, the libraries are referenced. To have the
services available, they need to be registered with the dependency
injection (DI) container. This is done in the Startup class.
With the startup, the BookChaptersService service and the
SampleChapters service are registered with the AddSingleton method of
the DI container to create just one instance for all clients requesting
the service. Because the BookChaptersService is registered as a
singleton, it can be accessed from multiple threads concurrently; that’s
why the ConcurrentDictionary is needed in its implementation (code
file Sync/BookServiceSampleHost/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddMvc();


//...
services.AddSingleton<IBookChaptersService,
BookChaptersService>();
services.AddSingleton<SampleChapters>();
}
The invocation to create the sample chapters is done in the Configure
method. Here, the SampleChapters object is injected, and within the
implementation of the method, sample chapters are created invoking
CreateSampleChapters (code file
Sync/BookServiceSampleHost/Startup.cs ):
public void Configure(IApplicationBuilder app,
IHostingEnvironment env,
SampleChapters sampleChapters)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
app.UseMvc();
sampleChapters.CreateSampleChapters();
}
Creating a Controller
The Web API controller uses the book chapter service. The controller
can be created from the Solution Explorer context menu Add New
Item ➪ Web API Controller Class. The controller class to manage book
chapters is named BookChaptersController . This class derives from the
base class Controller . The route to the controller is defined with the
Route attribute. The route starts with api followed by the name of the
controller—which is the name of the controller class without the
Controller postfix. The constructor of the BookChaptersController
requires an object implementing the interface IBookChaptersService .
This object is injected via DI (code file
Sync/APIBookServices/Controllers/BookChaptersController.cs ):
[Produces("application/json", "application/xml")]
[Route("api/[controller]")]
public class BookChaptersController : Controller
{


private readonly IBookChaptersService _bookChaptersService;
public BookChaptersController(IBookChaptersService
bookChaptersService)
{
_bookChaptersService = bookChaptersService;
}
The Get method that is created from the template is renamed and
modified to return the complete collection of type
IEnumerable<BookChapter> (code file
Sync/APIBookServices/Controllers/BookChaptersController.cs ):
// GET api/bookchapters
[HttpGet]
public IEnumerable<BookChapter> GetBookChapters() =>
_bookChaptersService.GetAll();
The Get method with a parameter is renamed to GetBookChapterById
and filters the dictionary of the repository with the Find method. The
parameter of the filter, id , is retrieved from the URL. The repository’s
Find method returns null if the chapter was not found. In this case,
NotFound is returned. NotFound returns a 404 (not found) response.
When the object is found, it is returned creating a new ObjectResult :
The ObjectResult returns a status code 200 with the book chapter in
the body (code file
Sync/APIBookServices/Controllers/BookChaptersController.cs ):
// GET api/bookchapters/guid
[HttpGet("{id}", Name = nameof(GetBookChapterById))]
public IActionResult GetBookChapterById(Guid id)
{
BookChapter chapter = _bookChaptersService.Find(id);
if (chapter == null)
{
return NotFound();
}
else
{
return new ObjectResult(chapter);
}
}


NOTE
Read Chapter 31 for information on defining routes.
On adding a new book chapter, the method PostBookChapter is added.
This method receives a BookChapter as part of the HTTP body that is
assigned to the method parameter after deserialization. In case the
parameter chapter is null, an BadRequest (HTTP error 400) is
returned. Adding the BookChapter , this method returns
CreatedAtRoute . CreatedAtRoute returns the HTTP status 201 (Created)
with the object serialized. The returned header information contains a
link to the resource—that is, a link to the GetBookChapterById with the
id set to the identifier of the newly created object (code file
Sync/APIBookServices/Controllers/BookChaptersController.cs ):
// POST api/bookchapters
[HttpPost]
public IActionResult PostBookChapter([FromBody]BookChapter
chapter)
{
if (chapter == null)
{
return BadRequest();
}
_bookChaptersService.Add(chapter);
return CreatedAtRoute(nameof(GetBookChapterById), new { id
= chapter.Id },
chapter);
}
Updating items is based on the HTTP PUT request. The
PutBookChapter method updates an existing item from the collection.
In case the object is not yet in the collection, NotFound is returned. If
the object is found, it is updated, and a success result 204—no content
with an empty body—is returned (code file
Sync/APIBookServices/Controllers/BookChaptersController.cs ):
// PUT api/bookchapters/guid
[HttpPut("{id}")]


public IActionResult PutBookChapter(Guid id,
[FromBody]BookChapter chapter)
{
if (chapter == null || id != chapter.Id)
{
return BadRequest();
}
if (_bookChaptersService.Find(id) == null)
{
return NotFound();
}
_bookChaptersService.Update(chapter);
return new NoContentResult();
}
With the HTTP DELETE request, book chapters are simply removed
from the dictionary (code file
Sync/APIBookServices/Controllers/BookChaptersController.cs ):
// DELETE api/bookchapters/5
[HttpDelete("{id}")]
public void Delete(Guid id) =>
_bookChaptersService.Remove(id);
With this controller in place, it is already possible to do first tests from
the browser. Opening the link (your port number might differ)
http://localhost:1079/api/BookChapters returns JSON as shown:
[{"id":"015b0fb6-1a0f-44ac-ba0d-
3d6d743bf4df","number":2,"title":"Objects and
Types","pages":33},{"id":"33cc122a-6be2-48b6-83b1-
e913fc10da77","number":0,"title":".NET Application
Architectures","pages":35},{"id":"47bcfa1e-085e-4d11-9a63-
ed2421cad912","number":6,"title":"Arrays","pages":20},
{"id":"069a1755-05da-40d7-96d4-
a1422eddfcd1","number":3,"title":"Object-Oriented Programming
with C#","pages":20},{"id":"a11cdc6b-087b-4c69-a4c7-
cc48f472c1b0","number":5,"title":"Operators and
Casts","pages":38},{"id":"1b638e90-f553-4635-8b54-
b6c5a938ad5d","number":1,"title":"Core C#","pages":42},
{"id":"3871a10e-ca1a-4d63-944e-
984d869b9416","number":7,"title":"Delegates, Lambdas, and
Events","pages":32},{"id":"311d1c72-844c-4b0b-a674-
6af7b24d7530","number":4,"title":"Generics","pages":24}]
Changing the Response Format


The .NET Framework version of the ASP.NET Web API returned
JSON or XML, depending on the requested format by the client. With
ASP.NET Core MVC, when returning an ObjectResult , by default
JSON is returned. In case you need to return XML as well, you can add
a call to AddXmlSerializerFormatters to the Startup class.
AddXmlSerializerFormatters is an extension method for the
IMvcBuilder interface and can be added using fluent API to the AddMvc
method (code file Sync/BooksServiceSampleHost/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddMvc().AddXmlSerializerFormatters();
services.AddSingleton<IBookChaptersService,
BookChaptersService>();
services.AddSingleton<SampleChapters>();
}
With the controllers, the allowed content type(s) and selectable result
can be specified with the Produces attribute
( Sync/APIBookServices/Controllers/BookChaptersController.cs ):
[Produces("application/json", "application/xml")]
[Route("api/[controller]")]
public class BookChaptersController: Controller
{
//...
}
NOTE
Later in this chapter, in the section “Receiving XML from the
Service,” you see how to receive XML-formatted responses.
REST Results and Status Codes
The following table summarizes the results a service returns based on
the HTTP methods:


HTTP
METHOD
GET
POST
PUT
DELETE
DESCRIPTION REQUEST
BODY
Returns a
Empty
resource
Adds a resource The resource to
add
Updates a
The resource to
resource
update
Deletes a
Empty
resource
RESPONSE
BODY
The resource
The resource
None
Empty
The following table shows important HTTP status codes as well as the
Controller method with the instantiated object that returns the status
code. To return any HTTP status code, you can return an
HttpStatusCodeResult object that can be initialized with the status
code you need:
HTTP STATUS
CODE
200 OK
201 Created
204 No Content
400 Bad Request
401 Unauthorized
404 Not Found
Any status code
CONTROLLER
METHOD TYPE
Ok OkResult
CreatedAtRoute CreatedAtRouteResult
NoContent NoContentResult
BadRequest BadRequestResult
Unauthorized UnauthorizedResult
NotFound NotFoundResult
StatusCodeResult
All success status codes start with 2; error status codes start with 4.
You can find a list of status codes in RFC 7231:
https://tools.ietf.org/html/rfc7231#section-6.3
CREATING AN ASYNC SERVICE
The previous sample code made use of a synchronous service. Using


Entity Framework Core (EF Core) with your repository, you can use
either synchronous or asynchronous methods. EF Core supports both.
However, many technologies, for example calling other services with
the HttpClient class, offer only asynchronous methods. This can lead
to an asynchronous service as shown in the project BooksServiceSample
in the Async folder.
With the asynchronous project, the IBookChaptersService has been
changed to an asynchronous version. This interface is defined to use it
with services accessing asynchronous methods, such as network or
database clients. All the methods return a Task (code file
Async/BooksServiceSample/Services/IBookChaptersService.cs ):
public interface IBookChaptersRepository
{
Task AddAsync(BookChapter chapter);
Task AddRangeAsync(IEnumerable<BookChapter> chapters);
Task<BookChapter> RemoveAsync(Guid id);
Task<IEnumerable<BookChapter>> GetAllAsync();
Task<BookChapter> FindAsync(Guid id);
Task UpdateAsync(BookChapter chapter);
}
The class BookChaptersService implements the asynchronous
methods. When reading and writing from the dictionary,
asynchronous functionality is not needed, so the Task to return is
created using the FromResult method (code file
Async/BooksServiceSample/Services/BookChaptersService.cs ):
public class BookChaptersService: IBookChaptersService
{
private readonly ConcurrentDictionary<string, BookChapter>
_chapters =
new ConcurrentDictionary<string, BookChapter>();
public Task AddAsync(BookChapter chapter)
{
chapter.Id = Guid.NewGuid();
_chapters[chapter.Id] = chapter;
return Task.CompletedTask;
}
public Task AddRangeAsync(IEnumerable<BookChapter>
chapters)


{
foreach (var chapter in chapters)
{
chapter.Id = Guid.NewGuid();
_chapters[chapter.Id] = chapter;
}
return Task.CompletedTask;
}
public Task<BookChapter> RemoveAsync(Guid id)
{
BookChapter removed;
_chapters.TryRemove(id, out removed);
return Task.FromResult(removed);
}
public Task<IEnumerable<BookChapter>> GetAllAsync() =>
Task.FromResult<IEnumerable<BookChapter>>
(_chapters.Values);
public Task<BookChapter> FindAsync(Guid id)
{
_chapters.TryGetValue(id, out BookChapter chapter);
return Task.FromResult(chapter);
}
public Task UpdateAsync(BookChapter chapter)
{
_chapters[chapter.Id] = chapter;
return Task.CompletedTask;
}
}
The API controller BookChaptersController just needs a few changes to
be implemented as asynchronous. The controller methods return a
Task as well. With this it is easy to invoke the asynchronous methods
of the repository (code file
Async/BooksServiceAsyncSample/Controllers/BookChaptersController.cs
[Produces("application/json", "application/xml")]
[Route("api/[controller]")]
public class BookChaptersController: Controller
{
private readonly IBookChaptersService _bookChaptersService;
public BookChaptersController(IBookChaptersService
bookChaptersService)


{
_bookChaptersService = bookChaptersService;
}
// GET: api/bookchapters
[HttpGet()]
public Task<IEnumerable<BookChapter>>
GetBookChaptersAsync() =>
_bookChaptersService.GetAllAsync();
// GET api/bookchapters/guid
[HttpGet("{id}", Name = nameof(GetBookChapterByIdAsync))]
public async Task<IActionResult>
GetBookChapterByIdAsync(Guid id)
{
BookChapter chapter = await _
bookChaptersService.FindAsync(id);
if (chapter == null)
{
return NotFound();
}
else
{
return new ObjectResult(chapter);
}
}
// POST api/bookchapters
[HttpPost]
public async Task<IActionResult> PostBookChapterAsync(
[FromBody]BookChapter chapter)
{
if (chapter == null)
{
return BadRequest();
}
await _ bookChaptersService.AddAsync(chapter);
return CreatedAtRoute(nameof(GetBookChapterByIdAsync),
new { id = chapter.Id }, chapter);
}
// PUT api/bookchapters/guid
[HttpPut("{id}")]
public async Task<IActionResult> PutBookChapterAsync(
Guid id, [FromBody]BookChapter chapter)
{
if (chapter == null || id != chapter.Id)
{


return BadRequest();
}
if (await _ bookChaptersService.FindAsync(id) == null)
{
return NotFound();
}
await _ bookChaptersService.UpdateAsync(chapter);
return new NoContentResult();
}
// DELETE api/bookchapters/guid
[HttpDelete("{id}")]
public async Task DeleteAsync(Guid id) =>
await _ bookChaptersService.RemoveAsync(id);
}
For the client, it doesn’t matter if the controller is implemented as
synchronous or asynchronous, the API calls are the same. The client
creates the same HTTP requests for both kinds.
CREATING A .NET CLIENT
Using the browser to call the service is a simple way to handle testing.
The clients more typically make use of JavaScript—this is where JSON
shines—and .NET clients. In this book, a Console App (.NET Core)
project is created to call the service.
The sample code for BookServiceClientApp makes use of the following
dependencies and namespaces:
Dependencies
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Logging.Console
Newtonsoft.Json
Namespaces
Microsoft.Extensions.Logging
Newtonsoft.Json
System


System.Collections.Generic
System.Linq
System.Net.Http
System.Net.Http.Headers
System.Runtime.CompilerServices
System.Text
System.Threading.Tasks
System.Xml.Linq
Sending GET Requests
For sending HTTP requests, you use the HttpClient class. This class is
introduced in Chapter 23, “Networking.” In this chapter, this class is
used to send different kinds of HTTP requests. To use the HttpClient
class, you need to add the NuGet package System.Net.Http and open
the namespace System.Net.Http . To convert JSON data to a .NET type,
the NuGet package Newtonsoft.Json is added.
NOTE
JSON serialization and using Json.NET is discussed in Bonus
Chapter 2, “XML and JSON,” which you can find online.
To have all the URLs needed in one place, the UrlService class defines
properties for the URLs needed (code file
Async/BookServiceClientApp/Services/UrlService.cs ):
public class UrlService
{
public string BaseAddress => "http://localhost:1079/";
public string BooksApi => "api/BookChapters/";
}


NOTE
You need to change the BaseAddress in the UrlService class to the
host and port number of your service. You can see the port
number in the browser when you start the service host.
With the sample project, the generic class HttpClientService is created
to have just one implementation for different data types. The
constructor expects the UrlService via DI and creates the HttpClient
using the base address retrieved from the UrlService (code file
Async/BookServiceClientApp/Services/HttpClientService.cs ):
public abstract class HttpClientService<T> : IDisposable
where T: class
{
private HttpClient _httpClient;
private readonly UrlService _urlService;
private readonly ILogger<HttpClientService<T>> _logger;
public HttpClientService(UrlService urlService,
ILogger<HttpClientService<T>> logger)
{
_urlService = urlService ??
throw new ArgumentNullException(nameof(urlService));
_logger = logger ?? throw new
ArgumentNullException(nameof(logger));
_httpClient = new HttpClient();
_httpClient.BaseAddress = new
Uri(_urlService.BaseAddress);
}
//...
}
NOTE
In the sample code, the ILogger interface is used to write log
information to the console. Logging is discussed in detail in
Chapter 29, “Tracing, Logging, and Analytics.”


The method GetInternalAsync makes a GET request to receive a list of
items. This method invokes the GetAsync method of the HttpClient to
send a GET request. The HttpResponseMessage contains the
information received. The status code of the response is written to the
console to show the result. In case the server returns an error, the
GetAsync method doesn’t throw an exception. An exception is thrown
from the method EnsureSuccessStatusCode that is invoked with the
HttpResponseMessage instance that is returned. This method throws an
exception in case the HTTP status code is of an error type. The body of
the response contains the JSON data returned. This JSON information
is read as string and returned (code file
Async/BookServiceClientApp/Services/HttpClientService.cs ):
private async Task<string> GetInternalAsync(string
requestUri)
{
if (requestUri == null) throw new
ArgumentNullException(nameof(requestUri));
if (_objectDisposed) throw new
ObjectDisposedException(nameof(_httpClient));
HttpResponseMessage resp = await
_httpClient.GetAsync(requestUri);
LogInformation($"status from GET {resp.StatusCode}");
resp.EnsureSuccessStatusCode();
return await resp.Content.ReadAsStringAsync();
}
private void LogInformation(string message,
[CallerMemberName] string callerName = null) =>
_logger.LogInformation(
$"{nameof(HttpClientService<T>)}.{callerName}:
{message}");
The server controller defines two methods with GET requests: one
method that returns all chapters and the other one returns just a single
chapter but requires the chapter’s identifier with the URI. The method
GetAllAsync invokes the GetInternalAsync method to convert the
returned JSON information to a collection, while the method GetAsync
converts the result to a single item. These methods are declared virtual
to allow overriding them from a derived class (code file


Async/BookServiceClientApp/Services/HttpClientService.cs ):
public async virtual Task<T> GetAsync(string requestUri)
{
if (requestUri == null) throw new
ArgumentNullException(nameof(requestUri));
string json = await GetInternalAsync(requestUri);
return JsonConvert.DeserializeObject<T>(json);
}
public async virtual Task<IEnumerable<T>> GetAllAsync(string
requestUri)
{
if (requestUri == null) throw new
ArgumentNullException(nameof(requestUri));
string json = await GetInternalAsync(requestUri);
return JsonConvert.DeserializeObject<IEnumerable<T>>(json);
}
Instead of using the generic HttpClientService class from the client
code, a specialization is done with the BookChapterClientService class.
This class derives from HttpClientService passing a BookChapter for
the generic parameter. This class also overrides the GetAllAsync
method from the base class to have the returned chapters sorted by the
chapter number (code file
Async/BookServiceClientApp/Services/BookChapterClientService.cs ):
public class BookChapterClientService :
HttpClientService<BookChapter>
{
public BookChapterClientService(UrlService urlService,
ILogger<BookChapterClientService> logger)
: base(urlService, logger) { }
public override async Task<IEnumerable<BookChapter>>
GetAllAsync(
string requestUri)
{
IEnumerable<BookChapter> chapters = await
base.GetAllAsync(requestUri);
return chapters.OrderBy(c => c.Number);
}
}


The BookChapter class contains the properties that are received with
the JSON content (code file
Async/BookServiceClientApp/Models/BookChapter.cs ):
public class BookChapter
{
public Guid Id { get; set; }
public int Number { get; set; }
public string Title { get; set; }
public int Pages { get; set; }
}
The Main method of the client application invokes the different
methods to show GET, POST, PUT, and DELETE requests that use
methods from the SampleRequest class. Before that, services to be used
for DI are registered by calling the ConfigureServices method (code
file Async/BookServiceClientApp/Program.cs ):
static async Task Main()
{
Console.WriteLine("Client app, wait for service");
Console.ReadLine();
ConfigureServices();
var test =
ApplicationServices.GetRequiredService<SampleRequest>();
await test.ReadChaptersAsync();
await test.ReadChapterAsync();
await test.ReadNotExistingChapterAsync();
await test.ReadXmlAsync();
await test.AddChapterAsync();
await test.UpdateChapterAsync();
await test.RemoveChapterAsync();
Console.ReadLine();
}
The method ConfigureServices registers the needed services in the
Microsoft.Extensions.DependencyInjection container and configures
logging to write to the console (code file
Async/BookServiceClientApp/Program.cs ):
public static void ConfigureServices()
{
var services = new ServiceCollection();
services.AddSingleton<UrlService>();


services.AddSingleton<BookChapterClientService>();
services.AddTransient<SampleRequest>();
services.AddLogging(logger =>
{
logger.AddConsole();
});
ApplicationServices = services.BuildServiceProvider();
}
public static IServiceProvider ApplicationServices { get;
private set; }
The class SampleRequest implements all the sample methods to invoke
the methods of the BookChapterClientService . In the constructor, the
UrlService and the BookChapterClientService are injected (code file
Async/BookServiceClientApp/SampleRequest.cs ):
public class SampleRequest
{
private readonly UrlService _urlService;
private readonly BookChapterClientService _client;
public SampleRequest(UrlService urlService,
BookChapterClientService client)
{
_urlService = urlService ??
throw new ArgumentNullException(nameof(urlService));
_client = client ?? throw new
ArgumentNullException(nameof(client));
}
//...
}
The method ReadChaptersAsync invokes the GetAllAsync method from
the BookChapterClient to retrieve all chapters and shows the titles of
the chapters on the console (code file
Async/BookServiceClientApp/SampleRequest.cs ):
public async Task ReadChaptersAsync()
{
Console.WriteLine(nameof(ReadChaptersAsync));
IEnumerable<BookChapter> chapters =
await _client.GetAllAsync(_urlService.BooksApi);
foreach (BookChapter chapter in chapters)
{
Console.WriteLine(chapter.Title);


}
Console.WriteLine();
}
When you run the application (starting both the service and the client
app), the ReadChaptersAsync method shows the OK status code and the
titles from the chapters:
ReadChaptersAsync
info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.GetInternalAsync: status from GET OK
.NET Application Architectures
Core C#
Objects and Types
Object-Oriented Programming with C#
Generics
Operators and Casts
Arrays
Delegates, Lambdas, and Events
The method ReadChapterAsync shows the GET request to retrieve a
single chapter. With this, the identifier of a chapter is added to the
URI string (code file Async/BookServiceClientApp/SampleRequest.cs ):
public async Task ReadChapterAsync()
{
Console.WriteLine(nameof(ReadChapterAsync));
var chapters = await
_client.GetAllAsync(_urlService.BooksApi);
Guid id = chapters.First().Id;
BookChapter chapter = await
_client.GetAsync(Addresses.BooksApi + id);
Console.WriteLine($" {chapter.Number} {chapter.Title}");
Console.WriteLine();
}
The result of the ReadChapterAsync method is shown here. It shows the
OK status two times because the first time this method retrieves all the
chapters before sending a request for a single chapter:
ReadChapterAsync
info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.GetInternalAsync: status from GET OK
Info 0 .NET Application Architectures


: BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.GetInternalAsync: status from GET OK
What if a GET request is sent with a nonexistent chapter identifier?
How to deal with this is shown in the method
ReadNotExistingChapterAsync . Calling the GetAsync method is like the
previous code snippet, but an identifier that does not exist is added to
the URI. Remember from the implementation of the HttpClientHelper
class, the GetAsync method of the HttpClient class does not throw an
exception. However, the EnsureSuccessStatusCode does. This exception
is caught with a catch to the HttpRequestException type. Here, an
exception filter is also used to only handle exception code 404 (not
found) (code file Async/BookServiceClientApp/SampleRequest.cs ):
private async Task ReadNotExistingChapterAsync()
{
Console.WriteLine(nameof(ReadNotExistingChapterAsync));
string requestedIdentifier = Guid.NewGuid().ToString();
try
{
BookChapter chapter = await _client.GetAsync(
Addresses.BooksApi + requestedIdentifier.ToString());
Console.WriteLine($" {chapter.Number} {chapter.Title}");
}
catch (HttpRequestException ex) when
(ex.Message.Contains("404"))
{
Console.WriteLine($"book chapter with the identifier " +
$"{requestedIdentifier} not found");
}
Console.WriteLine();
}
NOTE
Handling exceptions and using exception filters is discussed in
Chapter 14, “Errors and Exceptions.”
The result of the method shows the NotFound result from the service:
ReadNotExistingChapterAsync


info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.GetInternalAsync: status from GET
NotFound
book chapter with the identifier a0f629f4-8c46-4d66-8543-
74592dba5d5b not found
Receiving XML from the Service
In the section “Changing the Response Format,” the XML format was
added to the service. With a service that is enabled to return XML
beside JSON, XML content can be explicitly requested by adding the
accept header value to accept application/xml content.
How this can be done is shown in the following code snippet. Here, the
MediaTypeWithQualityHeaderValue specifying application/xml is added
to the Accept headers collection. Then, the result is parsed as XML
using the XElement class (code file
BookServiceClientApp/Services/HttpClientService.cs ):
public async Task<XElement> GetAllXmlAsync(string requestUri)
{
if (requestUri is null) throw new
ArgumentNullException(nameof(requestUri));
using (var client = new HttpClient())
{
client.BaseAddress = _baseAddress;
client.DefaultRequestHeaders.Accept.Add(
new
MediaTypeWithQualityHeaderValue("application/xml"));
HttpResponseMessage resp = await
client.GetAsync(requestUri);
Console.WriteLine($"status from GET {resp.StatusCode}");
resp.EnsureSuccessStatusCode();
string xml = await resp.Content.ReadAsStringAsync();
XElement chapters = XElement.Parse(xml);
return chapters;
}
}
NOTE


The XElement class and XML serialization are discussed in Bonus
Chapter 2.
From the SampleRequest class, the GetAllXmlAsync method is invoked
to directly write the XML result to the console (code file
Async/BookServiceClientApp/SampleRequest.cs ):
private static async Task ReadXmlAsync()
{
Console.WriteLine(nameof(ReadXmlAsync));
XElement chapters = await
_client.GetAllXmlAsync(_urlService.BooksApi);
Console.WriteLine(chapters);
Console.WriteLine();
}
When you run this method, you can see that now XML is returned
from the service:
ReadXmlAsync
info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.GetAllXmlAsync: status from GET OK
<ArrayOfBookChapter
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<BookChapter>
<Id>015b0fb6-1a0f-44ac-ba0d-3d6d743bf4df</Id>
<Number>2</Number>
<Title>Objects and Types</Title>
<Pages>33</Pages>
</BookChapter>
<BookChapter>
<Id>33cc122a-6be2-48b6-83b1-e913fc10da77</Id>
<Number>0</Number>
<Title>.NET Application Architectures</Title>
<Pages>35</Pages>
</BookChapter>
<BookChapter>
<Id>47bcfa1e-085e-4d11-9a63-ed2421cad912</Id>
<Number>6</Number>
<Title>Arrays</Title>
<Pages>20</Pages>
</BookChapter>
<!—... more chapters ...—>


</ArrayOfBookChapter>
Sending POST Requests
Let’s send new objects to the service using the HTTP POST request.
The HTTP POST request works similarly to the GET request. This
request creates a new object server side. The PostAsync method of the
HttpClient class requires the object that is added with the second
parameter. You use Json.NET’s JsonConvert class to serialize the
object to JSON. With a successful return, the Headers.Location
property contains a link where the object can be retrieved again from
the service. The response also contains a body with the object
returned. When the object changed from the service, the Id property
was filled in the service code on creating the object. This new
information is returned by the PostAsync method after deserialization
of the JSON code (code file
Async/BookServiceClientApp/Services/HttpClientService.cs ):
public async Task<T> PostAsync(string requestUri, T item)
{
if (requestUri is null) throw new
ArgumentNullException(nameof(requestUri));
if (item is null) throw new
ArgumentNullException(nameof(item));
if (_objectDisposed) throw new
ObjectDisposedException(nameof(_httpClient));
string json = JsonConvert.SerializeObject(item);
HttpContent content = new StringContent(json,
Encoding.UTF8,
"application/json");
HttpResponseMessage resp = await
_httpClient.PostAsync(requestUri, content);
LogInformation($"status from POST {resp.StatusCode}");
resp.EnsureSuccessStatusCode();
LogInformation($"added resource at
{resp.Headers.Location}");
json = await resp.Content.ReadAsStringAsync();
return JsonConvert.DeserializeObject<T>(json);
}
With the SampleRequest class, you can see the chapter that is added to
the service. After invoking the PostAsync method of the


BookChapterClient , the returned Chapter contains the new identifier
(code file Async/BookServiceClientApp/SampleRequest.cs ):
private static async Task AddChapterAsync()
{
Console.WriteLine(nameof(AddChapterAsync));
var client = new BookChapterClient(Addresses.BaseAddress);
BookChapter chapter = new BookChapter
{
Number = 34,
Title = "ASP.NET Core Web API",
Pages = 35
};
chapter = await client.PostAsync(Addresses.BooksApi,
chapter);
Console.WriteLine($"added chapter {chapter.Title} with id
{chapter.Id}");
Console.WriteLine();
}
The result of the AddChapterAsync method shows a successful run to
create the object:
AddChapterAsync
info added chapter ASP.NET Web API with id b490c5c3-ff30-
4ad4-8ca4-7436edfb04c0
: BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.PostAsync: status from POST Created
info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.PostAsync: added resource at
http://localhost:1079/api/BookChapters/b490c5c3-ff30-
4ad4-8ca4-7436edfb04c0
Sending PUT Requests
The HTTP PUT request—used for updating a record—is sent with the
help of the HttpClient method PutAsync . PutAsync requires the updated
content with the second parameter, and the URL to the service
including the identifier in the first (code file
Async/BookServiceClientApp/Services/HttpClientService.cs ):
public async Task PutAsync(string requestUri, T item)
{


if (requestUri is null) throw new
ArgumentNullException(nameof(requestUri));
if (item is null) throw new
ArgumentNullException(nameof(item));
if (_objectDisposed) throw new
ObjectDisposedException(nameof(_httpClient));
string json = JsonConvert.SerializeObject(item);
HttpContent content = new StringContent(json,
Encoding.UTF8,
"application/json");
HttpResponseMessage resp = await
_httpClient.PutAsync(requestUri, content);
LogInformation($"status from PUT {resp.StatusCode}");
resp.EnsureSuccessStatusCode();
}
In the SampleRequest class, the chapter .NET Application Architectures
is updated to a different title .NET Applications and Tools (code file
Async/BookServiceClientApp/SampleRequest.cs ):
public async Task UpdateChapterAsync()
{
Console.WriteLine(nameof(UpdateChapterAsync));
var chapters = await
_client.GetAllAsync(_urlService.BooksApi);
var chapter = chapters.SingleOrDefault(
c => c.Title == ".NET Application Architectures");
if (chapter != null)
{
chapter.Title = ".NET Applications and Tools";
await _client.PutAsync(_urlService.BooksApi + chapter.Id,
chapter);
Console.WriteLine($"updated chapter {chapter.Title}");
}
Console.WriteLine();
}
The console output of the UpdateChapterAsync method shows an HTTP
NoContent result and the updated chapter title:
UpdateChapterAsync
info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.GetInternalAsync: status from GET OK
info:
BookServiceClientApp.Services.BookChapterClientService[0]


HttpClientService.PutAsync: status from PUT NoContent
updated chapter .NET Applications and Tools
Sending DELETE Requests
The last request shown with the sample client is the HTTP DELETE
request. After invoking GetAsync , PostAsync , and PutAsync of the
HttpClient class, it should be obvious that the format is DeleteAsync .
What’s shown in this code snippet is that the DeleteAsync method just
needs a URI parameter to identify the object to delete (code file
Async/BookServiceClientApp/Services/HttpClientService.cs ):
public async Task DeleteAsync(string requestUri)
{
if (requestUri is null) throw new
ArgumentNullException(nameof(requestUri));
if (_objectDisposed) throw new
ObjectDisposedException(nameof(_httpClient));
HttpResponseMessage resp = await
_httpClient.DeleteAsync(requestUri);
LogInformation($"status from DELETE {resp.StatusCode}");
resp.EnsureSuccessStatusCode();
}
The SampleRequest class defines the RemoveChapterAsync method (code
file Async/BookServiceClientApp/SampleRequest.cs ):
public async Task RemoveChapterAsync()
{
Console.WriteLine(nameof(RemoveChapterAsync));
var chapters = await
_client.GetAllAsync(_urlService.BooksApi);
var chapter = chapters.SingleOrDefault(
c => c.Title == "Windows Communication Foundation");
if (chapter != null)
{
await _client.DeleteAsync(_urlService.BooksApi +
chapter.Id);
Console.WriteLine($"removed chapter {chapter.Title}");
}
Console.WriteLine();
}
When you run the application, the RemoveChapterAsync method first


shows the status of the HTTP GET method as a GET request is done
first to retrieve all chapters, and then the successful DELETE request
on deleting the Windows Communication Foundation chapter:
RemoveChapterAsync
info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.GetInternalAsync: status from GET OK
info:
BookServiceClientApp.Services.BookChapterClientService[0]
HttpClientService.DeleteAsync: status from DELETE OK
removed chapter Windows Communication Foundation
WRITING TO THE DATABASE
Chapter 26, “Entity Framework Core,” introduced you to mapping
objects to relations with Entity Framework Core (EF Core). A Web API
controller can easily use a DbContext . In the sample app, you don’t
need to change the controller at all; you just need to create and
register a different repository for using EF Core. All the steps needed
are described in this section.
Using EF Core
Let’s start with the code accessing the database. For using EF Core
with SQL Server, the NuGet package
Microsoft.EntityFrameworkCore.SqlServer need to be added to the
library project that contains the services.
The BookChapter class was already defined earlier. This class stays
unchanged for filling instances from the database. Mapping to
properties is defined in the BooksContext class. With this class, the
OnModelCreating method is overridden to map the BookChapter type to
the Chapters table and to define a unique identifier for the Id column
with a default unique identifier created from the database. The Title
column is restricted to a maximum of 120 characters (code file
Async/BookServiceSample/Models/BooksContext.cs ):
public class BooksContext: DbContext
{
public BooksContext(DbContextOptions<BooksContext> options)


: base(options) { }
public DbSet<BookChapter> Chapters { get; set; }
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
modelBuilder.Entity<BookChapter>()
.ToTable("Chapters")
.HasKey(c => c.Id);
modelBuilder.Entity<BookChapter>()
.Property(c => c.Id)
.HasColumnType("UniqueIdentifier")
.HasDefaultValueSql("newid()");
modelBuilder.Entity<BookChapter>()
.Property(c => c.Title)
.HasMaxLength(120);
}
}
With the DI container, EF Core and SQL Server need to be added to
invoke the extension methods AddEntityFramework and AddSqlServer .
The just-created BooksContext needs to be registered as well. The
BooksContext is added with the method AddDbContext . With the options
of this method, the connection string is passed (code file
Async/BookServiceSampleHost/Startup.cs ):
public async void ConfigureServices(IServiceCollection
services)
{
services.AddMvc().AddXmlSerializerFormatters();
//...
services.AddDbContext<BooksContext>(optons =>
options.UseSqlServer(
Configuration.GetConnectionString("BooksConnection")));
//...
}
The connection string itself is defined with the application settings in
the host application project (configuration file
Async/BookServiceSampleHost/appsettings.json ):
"ConnectionStrings": {
"BooksConnection": "server=
(localdb)\\mssqllocaldb;database=APIBooksSample;


trusted_connection=true;MultipleActiveResultSets=true"
}
With the sample application, the database will be automatically
created from the C# code. This is done by injecting the BooksContext
with the Configure method of the Startup class and invoking the
EnsureCreated method of the Database property. EnsureCreated creates
the database if it doesn’t exist. If the database was created, the
CreateSampleChaptersAsync method is invoked to feed sample chapters
into the database. SampleChapters is the same service that was used
previously with the in-memory chapter list (code file
Async/BooksServiceSampleHost/Startup.cs ):
public async void Configure(IApplicationBuilder app,
IHostingEnvironment env,
SampleChapters sampleChapters, BooksContext booksContext)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
app.UseMvc();
//...
bool created = booksContext.Database.EnsureCreated();
if (created)
{
await sampleChapters.CreateSampleChaptersAsync();
}
}
NOTE
EF Core also allows creating databases using Migration. Read
Chapter 26 for information about how to implement Migration in
the application.
Creating the Data Access Service


For using the BooksContext , you need to create a service implementing
the interface IBookChaptersService . The class DBBookChaptersService
makes use of the BooksContext instead of using an in-memory
dictionary as was done with the BookChaptersService (code file
Async/BookServiceSample/Models/DBBookChaptersService.cs ):
public class DBBookChaptersService, IBookChaptersService
{
Private readonly BooksContext _booksContext;
public BookChaptersRepository(BooksContext booksContext)
{
_booksContext = booksContext;
}
public async Task AddAsync(BookChapter chapter)
{
await_booksContext.Chapters.AddAsync(chapter);
await _booksContext.SaveChangesAsync();
}
public Task<BookChapter> FindAsync(Guid id) =>
_booksContext.Chapters.FindAsyncDefaultAsync(c => c.Id ==
id);
public async Task<IEnumerable<BookChapter>> GetAllAsync()
=>
await _booksContext.Chapters.ToListAsync();
public async Task<BookChapter> RemoveAsync(Guid id)
{
BookChapter chapter = await _booksContext.Chapters
.SingleOrDefaultAsync(c => c.Id == id);
if (chapter == null) return null;
_booksContext.Chapters.Remove(chapter);
await _booksContext.SaveChangesAsync();
return chapter;
}
public async Task UpdateAsync(BookChapter chapter)
{
_booksContext.Chapters.Update(chapter);
await _booksContext.SaveChangesAsync();
}
}


If you are wondering about the use of the context, read Chapter 26,
which covers more information about the EF Core.
To use this service, you have to remove the BookChaptersService from
the registration in the container (or comment it out), and add the
DBBookChaptersService to let the DI container create an instance of
this class when asked for the interface IBookChaptersService (code file
Async/BookServiceSampleHost/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddMvc().AddXmlSerializerFormatters();
// services.AddScoped<IBookChaptersService,
BookChaptersService>();
services.AddScoped<IBookChaptersService,
DBBookChaptersService>();
services.AddScoped<SampleChapters>();
services.AddDbContext<BooksContext>(options =>
options.UseSqlServer(
Configuration.GetConnectionString("BooksConnection")));
//...
}
Now—without changing the controller or the client—you can run the
service and client again. Depending on the data you enter initially in
the database, you see results for the GET/POST/PUT/DELETE
requests.
CREATING METADATA WITH THE OPENAPI OR
SWAGGER
Creating metadata for a service allows getting a description on the
service, and also allows you to create the client by using this metadata.
With web services using SOAP, metadata have been around since the
early days of SOAP—with the Web Services Description Language
(WSDL). Nowadays, metadata for REST services is here as well.
Currently it’s not a standard as with WSDL, but the most popular
framework for describing APIs is Swagger ( http://www.swagger.io ). As
of January 2016, the Swagger specification has been renamed to
OpenAPI, and the standard is already available in version 3.0 as of this


writing ( http://www.openapis.org ). The specification is available as a
GitHub repository at https://github.com/OAI/OpenAPI-
Specification/blob/OpenAPI.next/versions/3.0.0.md .
To add Swagger or OpenAPI to an ASP.NET Web API service, you can
use Swashbuckle. The NuGet package Swashbuckle.AspNetCore is the
library for ASP.NET Core.
After you add the NuGet package, you need to add Swagger to the DI
container. AddSwaggerGen is an extension method to add swagger
services to the collection. To configure Swagger, you invoke the
method SwaggerDoc . Passing an Info object, you can define title,
description, contact information, and more (code file
Async/BooksServiceSampleHost/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddMvc().AddXmlSerializerFormatters();
// services.AddScoped<IBookChaptersService,
BookChaptersService>();
services.AddScoped<IBookChaptersService,
DBBookChaptersService>();
services.AddScoped<SampleChapters>();
services.AddDbContext<BooksContext>(options =>
options.UseSqlServer(
Configuration.GetConnectionString("BooksConnection")));
services.AddSwaggerGen(options =>
{
options.SwaggerDoc("v2", new Info
{
Title = "Books Service API",
Version = "v2",
Description = "Sample service for Professional C# 7",
Contact = new Contact { Name = "Christian Nagel",
Url = "https://csharp.christiannagel.com" },
License = new License { Name = "MIT License" }
});
});
}
What’s left is the Swagger configuration in the Configure method of
the Startup class. The extension method UseSwagger adds Swagger


middleware and specifies that a JSON schema file should be
generated.
The default URI that you can configure with UseSwagger is
/swagger/{version}/swagger.json . With the document configured in
the previous code snippet, the URL is /swagger/v1/swagger.json . The
method UseSwaggerUi enables the graphical user interface for Swagger
and defines the URL (code file
Async/BooksServiceSampleHost/Startup.cs ):
public async void Configure(IApplicationBuilder app,
IHostingEnvironment env,
SampleChapters sampleChapters, BooksContext booksContext)
{
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
app.UseMvc();
app.UseSwagger();
app.UseSwaggerUI(options =>
options.SwaggerEndpoint("/swagger/v2/swagger.json",
"Book Chapter Services"));
//...
}
When you run the application with Swagger configured, you can see
nice information about the APIs offered by the service. Figure 32-2
shows the APIs offered by the BooksServiceSample , the template
generated by Values service, and the BooksService sample. You can
also see the title and description as configured with the Swagger
document.


FIGURE 32-2
Figure 32-3 shows some details of the GET request of the BookChapters
service with the UI to test the API call. You can see details of every API
including the model.
Swagger allows for easy customization of the output by using .NET
features. Adding annotations to the model types, such as Required and
DefaultValue , makes it into the JSON metadata definition, and is
shown in the help pages (code file
Async/BooksServiceSample/Models/BookChapter.cs ):
public class BookChapter
{
public Guid Id { get; set; }
[Required]
public int Number { get; set; }


[Required]
[MaxLength(40)]
public string Title { get; set; }
[DefaultValue(0)]
public int Pages { get; set; }
}
FIGURE 32-3
With the action methods of the controllers, you can specify the
different options for the response types, and the model information
that is returned in specific cases with the ProducesResponseType
attribute (code file


Async/BooksServiceSample/Controllers/BookChaptersController.cs ):
[HttpPost]
[ProducesResponseType(typeof(BookChapter), 201)]
[ProducesResponseType(400)]
public async Task<IActionResult> PostBookChapterAsync(
[FromBody]BookChapter chapter)
{
//...
}
You can also write XML comments to the action methods of the
controllers, and this will show up with the help pages. Of special
interest is the response element that is used by Swagger to give more
information about the possible outcome of the method (code file
Async/BooksServiceSample/Controllers/BookChaptersController.cs ):
/// <summary>
/// Creates a BookChapter
/// </summary>
/// <remarks>
/// Sample request:
///
POST api/bookchapters
///
{
///
Number: 42,
///
Title: "Sample Title",
///
Pages: 98
///
}
/// </remarks>
/// <param name="chapter"></param>
/// <returns>A newly created book chapter</returns>
/// <response code="201">Returns the newly created book
chapter</response>
/// <response code="400">If the chapter is null</response>
[HttpPost]
[ProducesResponseType(typeof(BookChapter), 201)]
[ProducesResponseType(400)]
public async Task<IActionResult> PostBookChapterAsync(
[FromBody]BookChapter chapter)
{
//...
}
To generate XML documentation from the XML comments, you need
to enable the Build configuration of the Project Settings and select the


XML Documentation File check box as shown in Figure 32-4. This
setting specifies the DocumentationFile setting in the project
configuration file (project file
Async/BooksServiceSample/BooksServiceSample.csproj ):
<PropertyGroup>
<DocumentationFile>..\docs\BooksServiceSample.xml</DocumentationFile>
</PropertyGroup>
Swagger now also needs to be configured to use this generated XML
documentation file when invoking the AddSwaggerGen method (code file
Async/BooksServiceSampleHost/Startup.cs ):
services.AddSwaggerGen(options =>
{
options.IncludeXmlComments("../docs/BooksServiceSample.xml");
options.SwaggerDoc("v2", new Info
{
Title = "Books Service API",
Version = "v2",
Description = "Sample service for Professional C# 7",
Contact = new Contact { Name = "Christian Nagel",
Url = "https://csharp.christiannagel.com" },
License = new License { Name = "MIT License" }
});
});
//...
With all this information added, Swagger shows the model containing
annotations, the information from the XML documentation, and
special information for the response codes, as shown in Figure 32-5.


FIGURE 32-4


FIGURE 32-5
CREATING AND USING ODATA SERVICES
ASP.NET Core offers support for the Open Data Protocol (OData) with
version 2.1. At the time of this writing, a Beta version of Web API
OData exists. Please check the book’s GitHub page for late updates.
OData offers CRUD access to a data source via the HTTP protocol.
Sending a GET request retrieves a collection of entity data; a POST
request creates a new entity; a PUT request updates existing entities;
and a DELETE request removes an entity. In this chapter you’ve
already seen the HTTP methods mapped to action methods in the
controller. OData is built on JSON and AtomPub (an XML format) for
the data serialization. You’ve seen direct support of JSON and XML
with the ASP.NET Core as well. What OData offers more of is that


every resource can be accessed with simple URI queries. For having a
look into that, and how this is solved with ASP.NET Web API, let’s get
into a sample and start with a database.
With the service application BooksODataService , for offering OData,
the NuGet package Microsoft.AspNetCore.OData needs to be added.
The sample service enables you to query Book and BookChapter objects
and the relation between.
Creating a Data Model
The sample service defines the Book and BookChapter classes for the
model. The Book class defines simple properties and a one-to-many
relationship with the BookChapter type (code file
BooksODataService/Models/Book.cs ):
public class Book
{
public Book()
{
Chapters = new List<BookChapter>();
}
public int Id { get; set; }
public string Isbn { get; set; }
public string Title { get; set; }
public string Publisher { get; set; }
public List<BookChapter> Chapters { get; set; }
}
The BookChapter class defines simple properties and a many-to-one
relation to the Book type (code file
BooksODataService/Models/BookChapter.cs ):
public class BookChapter
{
public int Id { get; set; }
public int BookId { get; set; }
public Book Book { get; set; }
public string Title { get; set; }
public int Number { get; set; }
}
The BooksContext class defines the Books and Chapters properties as


well as the definition of the SQL database relations (code file
BooksODataService/Models/BooksContext.cs ):
public class BooksContext: DbContext
{
public DbSet<Book> Books { get; set; }
public DbSet<BookChapter> Chapters { get; set; }
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
base.OnModelCreating(modelBuilder);
var bookBuilder = modelBuilder.Entity<Book>();
bookBuilder.HasMany(b => b.Chapters)
.WithOne(c => c.Book)
.HasForeignKey(c => c.BookId);
bookBuilder.Property(b => b.Title)
.HasMaxLength(120)
.IsRequired();
bookBuilder.Property(b => b.Publisher)
.HasMaxLength(40)
.IsRequired(false);
bookBuilder.Property(b => b.Isbn)
.HasMaxLength(20)
.IsRequired(false);
var chapterBuilder = modelBuilder.Entity<Chapter>();
chapterBuilder.Property(c => c.Title)
.HasMaxLength(120);
chaptersBuilder.HasOne(c => c.Book)
.WithMany(b => b.Chapters)
.HasForeignKey(c => c.BookId);
}
}
Creating the Database
To create the database on the fly with sample data, with the class
CreateBooksService a BooksContext is injected, and the database is
created if it doesn’t exist yet. The EnsureCreated method on the
DatabaseFacade class returned from the Database property of the
BooksContext makes sure the database exists. The EnsureCreated
method returns true if the database was created, and then the
database is filled with some books by invoking the CreateSampleBooks
method (code file
BooksODataService/Services/CreateBooksService.cs ):


public class CreateBooksService
{
private readonly BooksContext _booksContext;
public SampleBooks(BooksContext booksContext)
{
_booksContext = booksContext;
}
public void CreateDatabase()
{
bool created = _booksContext.Database.EnsureCreated();
if (created)
{
CreateSampleBooks();
}
}
//...
}
Sample data for the books and chapters is defined in the fields
_bookTitles , _bookIsbns , and _chapterTitles (code file
BooksODataService/Services/CreateBooksService.cs ):
private string[] _bookTitles = new[]
{
"Professional C# 7 and .NET Core 2",
"Professional C# 6 and .NET Core 1.0",
"Professional C# 5 and .NET 4.5.1"
};
private string[] _bookIsbns = new[]
{
"978-1-119-44927-0",
"978-1-119-09660-3",
"978-1-118-83303-2"
};
private string[][] chapterTitles = new[]
{
new []
{
".NET Applications and Tools",
"Core C#",
"Objects and Types",
"Object-Oriented Programming with C#",
"Generics",
//...


}
}
The CreateSampleBooks method uses the data defined with the private
fields to write this information to the database (code file
BooksODataService/Services/CreateBooksService.cs ):
private void CreateSampleBooks()
{
for (int i = 0; i < _bookTitles.Length; i++)
{
var b = new Book
{
Title = _bookTitles[i],
Isbn = _bookIsbns[i],
Publisher = "Wrox Press"
};
var chapters = GetChapters(i, b);
_booksContext.Chapters.AddRange(chapters);
_booksContext.Books.Add(b);
}
int recordsChanged = _booksContext.SaveChanges();
}
OData Startup Code
With ASP.NET Core, you can easily add OData Services. Services need
to be added to the dependency injection container, and middleware
needs to be added, as you’ve already seen in the previous ASP.NET
Core chapters.
In the ConfigureServices method of the Startup class, the
CreateBooksService class is registered with the DI container, which
allows for creating the database. When you use the AddDbContext
method, the EF Core context is registered with the DI container, and
it’s configured to use SQL Server. For OData, the extension method
AddOData method is invoked. This extension method registers multiple
services needed by OData (code file BooksODataService/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddMvc();
services.AddTransient<CreateBooksService>();
services.AddDbContext(options =>


{
options.UseSqlServer(Configuration.GetConnectionString("BooksConnection"
});
services.AddOData();
}
The middleware is configured with the Configure method. The
parameters of this method are changed to inject the
CreateBooksService . The first line in the implementation creates the
database if it doesn’t exist yet. The OData relevant code follows with
the creation of the ODataConventionModelBuilder . The
ODataConventionModelBuilder maps .NET classes to an Entity Data
Model (EDM). EDM models are used by OData to define what data is
exposed by the service. The OData routes are configured by passing a
routeBuilder parameter to the UseMvc extension method. The OData
route is specified by invoking the MapODataServiceRoute extension
method. The first parameter of this method specifies the name of the
route; the second parameter specifies the route prefix, and the third
parameter specifies the IEdmModel that is returned after creating the
model using the previously created ODataConventionModelBuilder
(code file BooksODataService/Startup.cs ):
public void Configure(IApplicationBuilder app,
IHostingEnvironment env,
CreateBooksService sampleBooks)
{
sampleBooks.CreateDatabase();
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
var builder = new
ODataConventionModelBuilder(app.ApplicationServices);
builder.EntitySet<Book>("Books");
builder.EntitySet<BookChapter>("BookChapters");
app.UseMvc(routeBuilder =>
routeBuilder.MapODataServiceRoute("ODataRoute", "odata",
builder.GetEdmModel()));
}


Creating the OData Controller
The BooksController class needs to derive from the base class
ODataController . In the following code snippet, the Get method
returns a list of Book objects including the contained BookChapter
objects. Instead of returning the IEnumerable interface, IQueryable is
returned to enable OData queries. This interface is implemented by
the DbSet class from EF Core. Returning a List<T> from in-memory
data, you can convert this to IQueryable using the AsQueryable
extension method. Returning a single result, for using OData
functionality, you need to return a result of type SingleResult . The
method SingleResult.Create creates a SingleResult , but needs
IQueryable as parameter (code file
BooksODataService/Controllers/BooksController.cs ):
public class BooksController: ODataController
{
private readonly BooksContext _booksContext;
public BooksController(BooksContext booksContext)
{
_booksContext = booksContext;
}
public IQueryable<Book> Get() =>
_booksContext.Books.Include(b => b.Chapters);
[EnableQuery()]
public SingleResult<Book> Get([FromODataUri] int id) =>
SingleResult.Create(_booksContext.Books.Where(b => b.Id
== key);
}
The ChaptersController is implemented similarly—returning a list of
BookChapter objects and a single BookChapter (code file
BooksODataService/Controllers/ChaptersController.cs ):
public class ChaptersController : ODataController
{
private readonly BooksContext _booksContext;
public ChaptersController(BooksContext booksContext)
{
_booksContext = booksContext;
}


public IQueryable<BookChapter> Get() =>
_booksContext.Chapters.Include(c => c.Book);
[EnableQuery]
public SingleResult<BookChapter> Get([FromODataUri] int
key) =>
SingleResult.Create(_booksContext.Chapters.Where(c =>
c.Id == key));
}
Other than the change with the EnableQuery attribute, no other special
actions are needed for the controller.
OData Query
Now it’s an easy task to get all the books from the database using this
URL (the port number might differ on your system) with the odata
route prefix as specified by the OData route in the Startup class and
the name of the controller using conventions:
http://localhost:50000/odata/Books
The data returned consists of JSON data with the Book objects:
{"@odata.context":"http://localhost:6614/odata/$metadata#Books",
"value":
[{"Id":1,"Isbn":"978-1-119-44927-0",
"Title":"Professional C# 7 and .NET Core 2"},
"Publisher":"Wrox Press"}
{"Id":2,"Isbn":"978-1-119-09660-3",
"Title":"Professional C# 6 and .NET Core 1.0"},
"Publisher":"Wrox Press"}
{"Id":3,"Isbn":"978-1-118-83303-2",
"Title":"Professional C# 5 and .NET 4.5.1"},
"Publisher":"Wrox Press"}]}
Similarly, the BookChapter objects are returned with this URL:
http://localhost:50000/odata/Chapters
For getting just a single book, the identifier of the book can be passed
with the URL. This request calls the Get action method passing the key
that returns a single result:


http://localhost:50000/odata/Books(2)
You can access generated EDM information passing the $metadata
string following the odata prefix:
http://localhost:50000/odata/$metadata
This returns EDM information generated from the model using the
ODataConventionModelBuilder:
<?xml version="1.0" encoding="UTF-8"?>
<edmx:Edmx xmlns:edmx="http://docs.oasis-
open.org/odata/ns/edmx" Version="4.0">
<edmx:DataServices>
<Schema xmlns="http://docs.oasis-open.org/odata/ns/edm"
Namespace="BooksODataService.Models">
<EntityType Name="Book">
<Key>
<PropertyRef Name="Id"/>
</Key>
<Property Name="Id" Nullable="false"
Type="Edm.Int32"/>
<Property Name="Isbn" Type="Edm.String"/>
<Property Name="Title" Type="Edm.String"/>
<NavigationProperty Name="Chapters"
Type="Collection(BooksODataService.Models.BookChapter)"/>
</EntityType>
<EntityType Name="BookChapter">
<Key>
<PropertyRef Name="Id"/>
</Key>
<Property Name="Id" Nullable="false"
Type="Edm.Int32"/>
<Property Name="BookId" Type="Edm.Int32"/>
<Property Name="Title" Type="Edm.String"/>
<Property Name="Number" Nullable="false"
Type="Edm.Int32"/>
<NavigationProperty Name="Book"
Type="BooksODataService.Models.Book">
<ReferentialConstraint ReferencedProperty="Id"
Property="BookId"/>
</NavigationProperty>
</EntityType>
</Schema>
<Schema xmlns="http://docs.oasis-open.org/odata/ns/edm"
Namespace="Default">


<EntityContainer Name="Container">
<EntitySet Name="Books"
EntityType="BooksODataService.Models.Book">
<NavigationPropertyBinding Target="Chapters"
Path="Chapters"/>
</EntitySet>
<EntitySet Name="Chapters"
EntityType="BooksODataService.Models.BookChapter">
<NavigationPropertyBinding Target="Books"
Path="Book"/>
</EntitySet>
</EntityContainer>
</Schema>
</edmx:DataServices>
</edmx:Edmx>
OData offers powerful query options that are supported by ASP.NET
Core Web API. The OData specification allows passing parameters to
the server for paging, filtering, and sorting. Let’s get into these.
Each book has multiple results. With a URL query, it’s also possible to
just get the Title of the book:
http://localhost:50000/odata/Books(1)/Title
You can also use a relation to retrieve the book chapters:
http://localhost:50000/odata/Books(1)/Chapters
To return the number of book chapters in the database, you can use
the $count function:
http://localhost:50000/odata/Chapters/$count
To return only a limited number of entities to the client, the client can
limit the count using the $top parameter. This also allows paging by
using $skip ; for example, you can skip 3 and take 3:
http://localhost:50000/odata/Books?$top=3&$skip=3
There are many more named parameters for the Queryable attribute to
restrict the query—for example, the maximum skip and top values, the
maximum expansion depth, and restrictions for sorting.
To filter the requests based on properties of the Book type, the $filter


option can be applied to properties of the Book . To filter only the books
that are from the publisher Wrox Press, you can use the eq operator
(equals) with $filter :
http://localhost:50000/odata/Books?$filter=Publisher eq 'Wrox
Press'
You can use lt (less than) and gt (greater than) logical operators with
$filter as well. This request returns only chapters with an id larger
than 40:
http://localhost:50000/odata/Chapters?$filter=Id gt 40
To request a sorted result, the $orderby option defines the sorting
order. Adding the desc keyword makes the sorting in descending
order:
http://localhost:50000/odata/Book(2)/Chapters?$orderby=Title
desc
All these query functions need to be explicitly enabled. You can enable
OData functions and limits by applying the EnableQuery attribute on
an action method, or globally by using IRouteBuilder extension
methods. With the following code snippet, the EnableQuery attribute is
applied to an action method. Here, the AllowedQueryOptions property
is set to the enum value AllowedQueryOptions.All . You can also define
a parameter of type ODataQueryOptions that you can check for the
query options sent via the URL request and validate it
programmatically:
[EnableQuery(AllowedQueryOptions = AllowedQueryOptions.All)]
public IQueryable<Book> Get(ODataQueryOptions options)
{
ODataValidationSettings settings = new
ODataValidationSettings()
{
MaxExpansionDepth = 4
};
options.Validate(settings);
var books = _booksContext.Books.Include(b => b.Chapters);
return books;
}


The EnableQuery attribute allows you to specify the maximum number
of nodes returned, the maximum top and skip values, the maximum
page size, whether ordering is allowed based on which properties, as
well as allowed logical and arithmetic operators, allowed functions,
and allowed query options.
To configure the options globally with the Startup class, you can use
the SetDefaultQuerySettings method to set the default values, and the
GetDefaultQuerySettings method to retrieve the default values.
USING AZURE FUNCTIONS
When you create a Web API with ASP.NET Core, you can host it either
with your own Windows server running IIS, a Linux server running
Apache, or even the Kestrel server without another web server front
end. You can use a Platform as a Service (PaaS) offering like Azure
App Services to host your Web APIs. When you use Azure App
Services, you pay for a server instance based on the number of CPU
cores, the size of the RAM, and the storage size. These resources are
reserved for your web apps (you can run multiple Web Apps in one
App Service instance).
Based on your loads, there’s another option for hosting a Web API:
Consumption plan or an App Service plan. With the App Service plan,
you can run the Azure Function in the same App Service you might
already have. The other variant, the Consumption plan, is also known
as serverless or Function as a Service (FaaS). With this option you pay
for the number of requests and the memory needed for the seconds the
Azure Function runs. Depending on the resources needed, this option
can be a lot cheaper than using App Services, but it also can be more
expensive. You also can run Azure Functions within an App Service
instance, which changes this to the same payment plan as App
Services.
When you use Azure Functions serverless, there’s still a server behind
it. The technology of Azure Functions is always based on App Services.
However, when you use it serverless, you don’t have control on this
server, and you don’t have CPU and memory reserved. That’s why the
pricing is different. For more information on the pricing model for


Microsoft Azure, see https://azure.microsoft.com/pricing/ .
Hosting the Azure Functions with FaaS, some limits apply. An Azure
Function can run for a maximum of 10 minutes. The default timeout is
5 minutes, but this can be extended to 10 minutes. In case your
Function needs to run for a longer time, you should host the Azure
Function within an App Service plan.
Azure Functions are implemented with static methods. Static state is
shared between multiple invocations. However, your Azure Function
will be unloaded when it’s not needed, and it’s freshly loaded and
instantiated when the HTTP request arrives again. A first request
might need a longer time to return the result. An option like “always
on” as with App Services is not available with the Consumption plan.
Based on the load, additional machines can automatically be started
with Azure Functions, which is another feature of the Consumption
plan. Just make sure to not share state between invocations in static
class members. State sharing can be done using external storage
features, such as Azure Storage or SQL database.
Creating Azure Functions
If you created your Web API using services that are used via DI, and
the services are defined in a .NET Standard library, you can easily use
the same services from Azure Functions. When you use Visual Studio
2017, you can create an Azure Functions project by selecting the Cloud
category in Add New Project and select the Azure Functions template.
The Visual Studio Extension “Azure Functions and Web Jobs Tools”
need to be installed for having this option available. After selecting
this option, you can see the first configuration options shown in Figure
32-6.


FIGURE 32-6
With these options, you can select the type of the trigger when the
Function should be invoked. Many different triggers are available.
Examples for these triggers are when some data is written to Azure
Cosmos DB, a WebHook is activated, events happen on Microsoft
Graph, an SMS arrives, events arrive at Event Hubs, events occur in
Blob Storage, and many more. The most commonly used triggers show
up in this dialog; these are HTTP requests, items in the Azure Storage
Queue, and timing events. With Storage queues, a Function can start
when a message arrives in a queue. With the Timer trigger, you can
specify a time interval, or start the Function at specific times, such as
every Saturday or on every 1st Monday of a month. Azure Functions
are a good practice to run background functionality needed on a time
interval—for example, a stored procedure to clean up or analyze data.
As this chapter is about Web APIs, here the HTTP trigger will be used
—a trigger that fires on receiving HTTP requests.
Other options to select are the version of Azure Functions. With Azure
Functions 1.0, a .NET Framework library is created. Azure Functions
2.0 makes use of .NET Standard 2.0, which is typically the best option.
You just need to pay attention to what triggers are available with


which version you select. At the time of this writing, Webhooks are not
available for Azure Functions 2.0, but they are available with Azure
Functions 1.0.
You also need a Storage Account with Azure Functions. To create and
test Azure Functions on your local system, a Storage Emulator is
available. The Storage Account is needed to write log information from
Azure Functions.
With Access rights you specify for whom the functions should be
available. You can choose to invoke the Function to be accessible only
from other Functions but not from the public. Here we select
Anonymous for the access rights to access the Azure Function from the
outside.
When you create the project, a .NET Standard 2.0 library that
references the NuGet package Microsoft.NET.Sdk.Functions is created.
The library contains the source file Function1.cs with a simple Hello,
name implementation for a GET request. This will be changed in the
next section to invoke the BookChapterService on GET, POST, and PUT
requests.
Using a Dependency Injection Container
Although the BookChaptersService can be easily instantiated via a
default constructor, this is not possible with many other services, such
as with the DbBookChaptersService that requires a BooksContext in the
constructor. That’s why it’s useful to add the DI container
Microsoft.Extensions.DependencyInjection NuGet package.
The static constructor of the BookFunction class—the class that hosts
the Azure Function—invokes the ConfigureServices method where the
services are registered in the DI container, the FeedSampleChapters
method where sample chapters are added using the SampleChapters
class, and the GetRequiredService method where services are retrieved
that are used later by all the features from the Azure Function (code
file Sync/BookFunctionApp/BookFunction.cs ):
public static class BookFunction
{
static BookFunction()


{
ConfigureServices();
FeedSampleChapters();
GetRequiredServices();
}
//...
}
The ConfigureServices method configures services into the DI
container, which is functionality you’ve already seen several times as
you’ve used ASP.NET Core:
private static void ConfigureServices()
{
var services = new ServiceCollection();
services.AddSingleton<IBookChaptersService,
BookChaptersService>();
services.AddSingleton<SampleChapters>();
ApplicationServices = services.BuildServiceProvider();
}
public static IServiceProvider ApplicationServices { get;
private set; }
To have some sample chapters available without needing to create a
database, the CreateSampleChapters method creates some in-memory
chapters using the BookChaptersService . Remember to not share state
in memory when using Azure Functions in production. I’m using it
here, though, because it’s easier to demonstrate for the example. For a
short time, this data survives, but when the function is idle for a long
enough time, or because of a higher load multiple instances are
created simultaneously, you might get unexpected results. To use the
database for a stable outcome, you just need to change the service
registration from the BookChaptersService to the
DbBookChaptersService and add the EF Core context as well:
private static void FeedSampleChapters()
{
var sampleChapters =
ApplicationServices.GetRequiredService<SampleChapters>();
sampleChapters.CreateSampleChapters();
}
The IBookChaptersService is needed from GET, POST, and PUT


requests to the Azure Function; that’s why this service is retrieved and
stored within a static variable. When you use the static constructor to
invoke GetRequiredServices , this method is invoked every time the
host is started again:
private static void GetRequiredServices()
{
s_bookChaptersService =
ApplicationServices.GetRequiredService<IBookChaptersService>
();
}
private static IBookChaptersService s_bookChaptersService;
After the setup of the Azure Function is complete, you can step into
implementing the main functionality in the next section.
Implementing GET, POST, and PUT Requests
The heart of an Azure Function is defined with the static Run method.
The name of the function is defined by the FunctionName attribute. The
parameters differ on the trigger type. The sample code specifies a
trigger on an HTTP request using the HttpTrigger attribute. Because of
this attribute, the first parameter of the Run method is of type
HttpRequest . This type contains information on the HTTP request and
allows sending an HTTP response. The HttpTrigger attribute specifies
the AuthorizationLevel that you specified when creating the
application and follows it with a variable parameter list of the HTTP
verbs when the Azure Function should be activated. You also can
specify route information to this Azure Function with parameters.
Parameters you define with the route can also be added as parameters
to the Run method. The last parameter of the Run method is the
TraceWriter . This writer is used to log information into the Azure
Storage account that was specified when you created the application.
With the implementation of the Run method, a switch is done to invoke
DoGet , DoPost , and DoPut methods based on the HTTP method received
(code file Sync/BookFunctionApp/BookFunction.cs ):
[FunctionName("BookFunction")]
public static IActionResult


Run([HttpTrigger(AuthorizationLevel.Anonymous,
"get", "post", "put", Route = "null")]HttpRequest req,
TraceWriter log)
{
log.Info("C# HTTP trigger function processed a request.");
IActionResult result = null;
switch (req.Method)
{
case "GET":
result = DoGet(req);
break;
case "POST":
result = DoPost(req);
break;
case "PUT":
result = DoPut(req);
break;
default:
result = new BadRequestResult();
break;
}
return result;
}
With a GET request, the client can retrieve all book chapters or just a
single one. If the HTTP URL contains a query with Id ( /?Id=Guid ), the
identifier is parsed, and the Find method of the IBookChaptersService
is invoked. Based on the result of the Find method, either a
NotFoundResult is returned or an OkObjectResult that includes the
book chapter in the HTTP body is returned. If Id is not part of the
query, all book chapters are retrieved using the GetAll method, and
the result list is put into the constructor of the OkObjectResult (code
file Sync/BookFunctionApp/BookFunction.cs ):
private static IActionResult DoGet(HttpRequest req)
{
string id = req.Query["Id"];
if (id != null)
{
Guid guid = Guid.Parse(id);
var chapter = s_bookChaptersService.Find(guid);
if (chapter == null)
{
return new NotFoundResult();


}
return new OkObjectResult(chapter);
}
else
{
var chapters = s_bookChaptersService.GetAll();
return new OkObjectResult(chapters);
}
}
With a HTTP POST request, the DoPost method is invoked. A POST
request includes the new book chapter in the HTTP body of the
request. The HTTP body can be retrieved by accessing the Body
property of the HttpRequest . The Body property is of type Stream , which
can be put into the constructor of the StreamReader class. With the
StreamReader , the complete JSON string is retrieved by invoking
ReadToEnd . This JSON string is then converted to a BookChapter with
the help of Newtonsoft.Json . This converted BookChapter is then passed
to the Add method of the IBookChaptersService (code file
Sync/BookFunctionApp/BookFunction.cs ):
private static IActionResult DoPost(HttpRequest req)
{
string json = new StreamReader(req.Body).ReadToEnd();
BookChapter chapter =
JsonConvert.DeserializeObject<BookChapter>(json);
s_bookChaptersService.Add(chapter);
return new OkResult();
}
NOTE
Streams are covered in detail in Chapter 22, “Files and Streams.”
The HTTP PUT request to update a BookChapter object is very similar
to the previous HTTP POST request. This time just the Update method
of the IBookChaptersService is invoked (code file
Sync/BookFunctionApp/BookFunction.cs ):
private static IActionResult DoPut(HttpRequest req)


{
string json = new StreamReader(req.Body).ReadToEnd();
BookChapter chapter =
JsonConvert.DeserializeObject<BookChapter>(json);
s_bookChaptersService.Update(chapter);
return new OkResult();
}
With this in place, it’s possible to use all the functionality you’ve
already implemented when offering the service using ASP.NET Core.
Using a small façade to the services, the services didn’t require any
changes. Let’s run and publish the Azure Function next.
Running the Azure Function
When you run the application from Visual Studio, a console window
shows the Azure Function logo (see Figure 32-7) and shows the output
of the listener with the URL to access the HTTP service. Now you can
use a browser to do GET requests and test the Azure Function. For
testing POST and PUT requests, you can adapt the previously created
client to invoke the Azure Function, or you can use a tool such as
Postman ( https://www.getpostman.com ) to create POST and PUT
requests. This is also a great tool for creating integration and running
integration tests.


FIGURE 32-7
When you run the application, you’ll find the file function.json in the
bin/Debug/netstandard2.0/BookFunction directory. This file describes
the Azure Function as it is deployed when you publish on Microsoft
Azure. When you use the .NET Standard library, the information for
function.json comes from the annotations you specify with the Run
method; as you can see it lists the type of the trigger, configuration of
the trigger, such as the HTTP methods, and the entry-point of the
Azure Function:
{
"generatedBy": "Microsoft.NET.Sdk.Functions.Generator-
1.0.6",
"configurationSource": "attributes",
"bindings": [
{
"type": "httpTrigger",
"methods": [
"GET",
"POST",
"PUT"
],
"authLevel": "anonymous",


"name": "req"
}
],
"disabled": false,
"scriptFile": "../bin/BookFunctionApp.dll",
"entryPoint": "BookFunctionApp.BookFunction.Run"
}
When you successfully run the application locally, you can publish it to
Microsoft Azure either in a Consumption or an App Service plan.
SUMMARY
This chapter described the features of the Web API using ASP.NET
Core. This technology offers an easy way to create services that can be
called from any client—be it JavaScript or a .NET client—with the help
of the HttpClient class. Either JSON or XML can be returned, but
nowadays JSON is the preferred format.
Dependency injection was already used in several chapters of this
book, particularly in Chapter 20, “Dependency Injection.” In this
chapter you’ve seen how easy it is to replace a memory-based
repository using a dictionary with a repository by making use of EF
Core.
This chapter also introduced you to OData, with which it’s easy to
reference data in a tree using resource identifiers.
Besides using ASP.NET Core to host the Web API, you’ve also used the
same services created earlier with Azure Functions. Services have been
implemented independent of a hosting technology, and thus it was an
easy task to create a small façade and host the services from Azure
Functions, which offer a different cost model when hosting a Web API
on Microsoft Azure.
The next chapter is the start of Part IV of the book and is the first
chapter of several that cover how to use XAML to create Windows
apps.