

Testing
WHAT’S IN THIS CHAPTER?
Unit tests with MSTest and xUnit
Unit tests with xUnit with .NET Core
Unit tests with EF Core
Coded UI testing
Web testing
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory tests .
The code for this chapter is divided into the following major
examples:
Unit Testing Sample
Mocking Sample
EF Core Sample
Windows App Sample


ASPNETCore Integration Test Sample
Web Application Load Test Sample
NOTE
Unit testing is available with all editions of Visual Studio. All
other testing features—such as Live Unit Testing, Web Load &
Performance Testing, Coded UI Testing, Code Coverage,
Microsoft Fakes, and IntelliTest—require Visual Studio Enterprise
2017.
OVERVIEW
Application development is becoming agile. When using waterfall
process models to analyze the requirements, it’s not unusual that you
design the application architecture, do the implementation, and then
find out two or three years later that you built an application that is
not needed by the user. Instead, software development becomes agile
with faster release cycles, and early participation of the end users. Just
have a look at Windows 10: With millions of Windows insiders who
give feedback to early builds, updates happen every few months or
even weeks. There was one special week during the Beta program of
Windows 10 when Windows insiders received three builds of Windows
10 within one week. Windows 10 is a huge program, but Microsoft
managed to change development in a big way. Also, if you participate
in the open-source project of .NET Core, you can get nightly builds of
NuGet packages. If you’re adventurous, you might even write a book
about an upcoming technology.
With such fast and continuous changes—and nightly builds that you
are creating—you can’t wait for insiders or end users to find all the
issues. Windows 10 insiders wouldn’t have been happy with Windows
10 crashing every few minutes. How often have you done a change in
the implementation of a method to find out something that doesn’t
seem related is not working anymore? You might have tried to avoid


such issues by not changing the method and creating a new one by
copying the code and doing the necessary changes there, which in turn
creates a maintenance nightmare. It happens too easily that you fix a
method in one place but miss the other ones with code duplicates.
You can avoid issues like these. Create tests for your methods, and let
the tests run automatically on checking in the source code or during
nightly builds. Creating tests from the start increases the cost for the
project from the beginning, but as the project processes and during
maintenance, creating tests has advantages and reduces the overall
project cost.
This chapter explains different kinds of tests, starting with unit tests,
which are tests for small functionality. These tests should verify the
functionality of the smallest testable parts of an application—for
example, methods. When you pass different input values, a unit test
should check all possible paths through a method.
MSTest is a testing framework from Microsoft for creating unit tests.
When .NET Core was built, MSTest did not support creating tests for
.NET Core libraries and applications. That’s why Microsoft itself is
using xUnit to create unit tests for .NET Core. Now, you can use both
MSTest and XUnit to create unit tests for .NET Core. This chapter
covers both Microsoft’s test framework MSTest and xUnit.
With web testing you can test web applications, send HTTP requests,
and simulate a load of users. Creating these kinds of tests enables you
to simulate different user loads and allow stress testing. You can use
test controllers to create higher loads to simulate thousands of users
and thus also know what infrastructure you need and whether your
application is scalable.
The final testing feature covered in this chapter is UI testing. You can
create automated tests of your XAML-based applications. Of course, it
is a lot easier to create unit tests for your view models and the view
components with ASP.NET Core, but it’s not possible to cover every
aspect of testing in this chapter. You can automate UI testing. Just
imagine the hundreds of different Android mobile devices that are
available. Would you buy one of every model to test your app manually
on every device? It’s better to use a cloud service and send the app to


be tested where the app is indeed installed on hundreds of devices.
Don’t assume humans will start the app in the cloud on hundreds of
devices and click through the possible interactions of the app. This
needs to be automated using UI tests.
First, let’s start creating unit tests.
UNIT TESTING WITH MSTEST
Writing unit tests helps with code maintenance. For example, when
you’re performing a code update, you want to be confident that the
update isn’t going to break something else. Having automatic unit
tests in place helps to ensure that all functionality is retained after
code changes are made. Visual Studio 2017 offers a unit testing
framework, and you can also use other testing frameworks from within
Visual Studio.
Creating Unit Tests with MSTest
The following example tests a very simple method in a class library
named UnitTestingSamples . This is a .NET Standard 2.0 class library.
Of course, you can create any other MSBuild-based project. The class
DeepThought contains the
TheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything
method, which returns 42 as a result (code file
UnitTestingSamples/DeepThought.cs ):
public class DeepThought
{
public int
TheAnswerOfTheUltimateQuestionOfLifeTheUniverseAndEverything()
=>
42;
}
To ensure that nobody changes the method to return a wrong result
(maybe someone who didn’t read The Hitchhiker’s Guide to the
Galaxy), a unit test is created. To create a unit test, you can use the
dotnet command
> dotnet new mstest


or you can add the project template Unit Test Project (.NET Core)
from Visual Studio.
Before creating the first tests, it’s a good idea to think about naming
tests and test projects. Of course, you can use names as you like, but
you can find a good guideline from the .NET Core team at
https://github.com/aspnet/Home/wiki/Engineering-
guidelines#unit-tests-and-functional-tests
Here’s a summary of the guidelines:
A test project has the name Tests appended to the name of the
project—for example, for the project UnitTestingSamples , the test
project has the name UnitTestingSamples.Tests .
Test class names have the same class name as the class under being
tested, and the word Test is appended to the name—for example,
the test class for UnitTestingSamples.DeepThought is
UnitTestingSamples.DeepThoughtTest .
Unit test method names have a descriptive name—for example the
name AddOrUpdateBookAsync_ThrowsForNull indicates a unit test to
invoke the AddOrUpdateBookAsync method to check if it throws an
exception passing null .
The MSTest project contains references to the NuGet packages
Microsoft.NET.Test.Sdk , MSTest.TestAdapter , and
MSTest.TestFramework (project file
UnitTestingSamples.MSTests/UnitTestingSamples.MSTests.csproj ):
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<TargetFramework>netcoreapp2.0</TargetFramework>
<IsPackable>false</IsPackable>
</PropertyGroup>
<ItemGroup>
<PackageReference Include="Microsoft.NET.Test.Sdk"
Version="15.5.0" />
<PackageReference Include="MSTest.TestAdapter"
Version="1.2.0" />
<PackageReference Include="MSTest.TestFramework"
Version="1.2.0" />


</ItemGroup>
<ItemGroup>
<ProjectReference
Include="..\UnitTestingSamples\UnitTestingSamples.csproj" />
</ItemGroup>
</Project>
A unit test class is marked with the TestClass attribute, and a test
method is marked with the TestMethod attribute. The implementation
creates an instance of DeepThought and invokes the method that is to be
tested:
TheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything . The
return value is compared with the value 42 using Assert.AreEqual . In
case Assert.AreEqual fails, the test fails (code file
UnitTestingSamples.MSTests/DeepThoughtTest.cs ):
[TestClass]
public class TestProgram
{
[TestMethod]
public void
ResultOfTheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything()
{
// arrange
int expected = 42;
var dt = new DeepThought();
// act
int actual =
dt.TheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything();
// assert
Assert.AreEqual(expected, actual);
}
}
Unit tests are defined by three A’s: arrange, act, and assert. First,
everything is arranged for the unit test to start. In the first test, with
the arrange phase, a variable expected is assigned the value that is


expected from calling the method to test, and an instance of the
DeepThought class is invoked. Now everything is ready to test the
functionality. This happens with the act phase—the method is
invoked. After completing the act phase, you need to verify whether
the result is as expected. This is done in the assert phase using a
method of the Assert class.
The Assert class is part of the MSTest framework in the
Microsoft.VisualStudio.TestTools.UnitTesting namespace. This class
offers several static methods that you can use with unit tests. The
Assert.Fail method can be used to mark a unit test to give the
information that the test is not yet implemented. Some of the other
methods are AreNotEqual , which verifies whether two objects are not
the same; IsFalse and IsTrue , which verify Boolean results; IsNull and
IsNotNull , which verify null results; and IsInstanceOfType and
IsNotInstanceOfType , which verify the passed type.
Running Unit Tests
Using the Test Explorer (which you open via Test ⇨ Windows ⇨ Test
Explorer), you can run the tests from the solution (see Figure 28-1).
FIGURE 28-1
Figure 28-2 shows a failed test, which includes all details about the
failure.


FIGURE 28-2
To run the test from the command line, you can invoke dotnet test :
> dotnet test
With the sample application, this results in this successful output:
Build started, please wait...
Build completed.
Test run for
C:\procsharp\Tests\UnitTestingSamples\UnitTestingSamples.MSTests\bin\Deb
netcoreapp2.0\UnitTestingSamples.MSTests.dll(.NETCoreApp,Version=v2.0)
Microsoft (R) Test Execution Command Line Tool Version 15.5.0
Copyright (c) Microsoft Corporation. All rights reserved.
Starting test execution, please wait...
Total tests: 1. Passed: 1. Failed: 0. Skipped: 0.
Test Run Successful.
Test execution time: 1.2312 Seconds
Of course, this was a very simple scenario; the tests are not usually
that simple. For example, methods can throw exceptions; they can
have different routes for returning other values; and they can make
use of other code (for example, database access code, or services that
are invoked) that shouldn’t be tested with the single unit. Now let’s
look at a more involved scenario for unit testing.
The following class, StringSample , defines a constructor with a string
parameter, the method GetStringDemo , and a field. The method
GetStringDemo uses different paths depending on the first and second
parameters and returns a string that results from these parameters
(code file UnitTestingSamples/StringSample.cs ):
public class StringSample
{
public StringSample(string init)
{
if (init is null)
throw new ArgumentNullException(nameof(init));


_init = init;
}
private string _init;
public string GetStringDemo(string first, string second)
{
if (first is null)
{
throw new ArgumentNullException(nameof(first));
}
if (string.IsNullOrEmpty(first))
{
throw new ArgumentException("empty string is not
allowed", first);
}
if (second is null)
{
throw new ArgumentNullException(nameof(second));
}
if (second.Length > first.Length)
{
throw new ArgumentOutOfRangeException(nameof(second),
"must be shorter than first");
}
int startIndex = first.IndexOf(second);
if (startIndex < 0)
{
return $"{second} not found in {first}";
}
else if (startIndex < 5)
{
string result = first.Remove(startIndex,
second.Length);
return $"removed {second} from {first}: {result}";
}
else
{
return _init.ToUpperInvariant();
}
}
}
NOTE


When you’re writing unit tests for complex methods, the unit test
also sometimes gets complex. Here it is helpful to debug into the
unit test to find out what’s going on. Debugging unit tests is
straightforward: Just add breakpoints to the unit test code, and
from the context menu of the Test Explorer select Debug Selected
Tests (see Figure 28-3).
FIGURE 28-3
Every possible execution route and check for exceptions should be
covered by unit tests, as discussed next.
Expecting Exceptions with MSTest
When invoking the constructor of the StringSample class and calling
the method GetStringDemo with null, an ArgumentNullException is
expected. You can easily check exceptions with testing code: apply the
ExpectedException attribute to the test method as shown in the
following example. This way, the test method succeeds with the
exception (code file
UnitTestingSamples.MSTests/StringSampleTest.cs ):
[TestMethod]
[ExpectedException(typeof(ArgumentNullException))]
public void ConstructorShouldThrowOnNull()
{
var sample = new StringSample(null);
}


You can deal with the exception thrown by the GetStringDemo method
in a similar way.
Testing All Code Paths
To test all code paths, you can create multiple tests, with each one
taking a different route. The following test sample passes the strings a
and b to the GetStringDemo method. Because the second string is not
contained within the first string, the first path of the if statement
applies. The result is checked accordingly (code file
UnitTestingSamples.MSTests/StringSampleTest.cs ):
[TestMethod]
public void GetStringDemoBNotInA()
{
string expected = "b not found in a";
var sample = new StringSample(String.Empty);
string actual = sample.GetStringDemo("a", "b");
Assert.AreEqual(expected, actual);
}
The next test method verifies another path of the GetStringDemo
method. Here, the second string is found in the first one, and the index
is lower than 5; therefore, it results in the second code block of the if
statement:
[TestMethod]
public void GetStringDemoRemoveBCFromABCD()
{
string expected = "removed bc from abcd: ad";
var sample = new StringSample(String.Empty);
string actual = sample.GetStringDemo("abcd", "bc");
Assert.AreEqual(expected, actual);
}
All other code paths can be tested similarly. To see what code is
covered by unit tests, and what code is still missing, you can start Code
Coverage in Visual Studio and use the --collect option of the dotnet
test command. In the Visual Studio 2017 Code Coverage Results
window (Test ⇨ Windows ⇨ Code Coverage Results), you can see the
percentage of code covered by unit tests.


External Dependencies
Many methods are dependent on some functionality outside the
application’s control, for example, calling a web service or accessing a
database. Maybe the service or database is not available during some
test runs, which tests the availability of these external resources. Or
worse, maybe the database or service returns different data over time,
and it’s hard to compare this with expected data. Such functionality
outside the scope of what should be tested must be excluded from the
unit test.
The following example is dependent on some outside functionality.
The method ChampionsByCountry accesses an XML file from a web
server that contains a list of Formula-1 world champions with
Firstname , Lastname , Wins , and Country elements. This list is filtered by
country, and it’s numerically ordered using the value from the Wins
element. The returned data is an XElement that contains converted
XML code:
public XElement ChampionsByCountry(string country)
{
XElement champions = XElement.Load(F1Addresses.RacersUrl);
var q = from r in champions.Elements("Racer")
where r.Element("Country").Value == country
orderby int.Parse(r.Element("Wins").Value)
descending
select new XElement("Racer",
new XAttribute("Name",
r.Element("Firstname").Value + " " +
r.Element("Lastname").Value),
new XAttribute("Country",
r.Element("Country").Value),
new XAttribute("Wins", r.Element("Wins").Value));
return new XElement("Racers", q.ToArray());
}
NOTE
For more information on LINQ to XML, read Bonus Chapter 2,
“XML and JSON,” which you can find online.”


The link to the XML file is defined by the F1Addresses class (code file
UnitTestingSamples/F1Addresses.cs ):
public class F1Addresses
{
public const string RacersUrl =
"http://www.cninnovation.com/downloads/Racers.xml";
}
For the method ChampionsByCountry , you should do a unit test. The test
should not be dependent on the source from the server. Server
unavailability is one issue, but it can also be expected that the data on
the server changes over time to return new champions, and other
values. The current test should ensure that filtering is done as
expected, returning a correctly filtered list, and in the correct order.
One way to create a unit test that is independent of the data source is
to refactor the implementation of the ChampionsByCountry method by
using the dependency injection pattern. Here, a factory that returns an
XElement is created to replace the XElement.Load method. The interface
IChampionsLoader is the only outside requirement used from the
ChampionsByCountry method. The interface IChampionsLoader defines
the method LoadChampions that can replace the aforementioned
method (code file UnitTestingSamples/IChampionsLoader.cs ):
public interface IChampionsLoader
{
XElement LoadChampions();
}
The class ChampionsLoader implements the interface IChampionsLoader
by using the XElement.Load method—the method that was used
beforehand by the ChampionsByCountry method (code file
UnitTestingSamples/ChampionsLoader.cs ):
public class ChampionsLoader: IChampionsLoader
{
public XElement LoadChampions() =>
XElement.Load(F1Addresses.RacersUrl);
}


NOTE
The dependency injection pattern is explained with more detail in
Chapter 20, “Dependency Injection.”
Now it’s possible to change the implementation of the
ChampionsByCountry method by using an interface to load the
champions instead of directly using XElement.Load . The
IChampionsLoader is passed with the constructor of the class Formula1 ,
and this loader is then used by ChampionsByCountry : (code file
UnitTestingSamples/Formula1.cs ):
public class Formula1
{
private IChampionsLoader _loader;
public Formula1(IChampionsLoader loader)
{
_loader = loader;
}
public XElement ChampionsByCountry(string country)
{
var q = from r in
_loader.LoadChampions().Elements("Racer")
where r.Element("Country").Value == country
orderby int.Parse(r.Element("Wins").Value)
descending
select new XElement("Racer",
new XAttribute("Name",
r.Element("Firstname").Value + " " +
r.Element("Lastname").Value),
new XAttribute("Country",
r.Element("Country").Value),
new XAttribute("Wins",
r.Element("Wins").Value));
return new XElement("Racers", q.ToArray());
}
}
With a typical implementation, a ChampionsLoader instance would be
passed to the Formula1 constructor to retrieve the racers from the


server.
When you’re creating the unit test, you can implement a custom
method that returns sample Formula-1 champions, as shown in the
method Formula1SampleData (code file
UnitTestingSamples.MSTests/Formula1Test.cs ):
internal static string Formula1SampleData()
{
return @"
<Racers>
<Racer>
<Firstname>Nelson</Firstname>
<Lastname>Piquet</Lastname>
<Country>Brazil</Country>
<Starts>204</Starts>
<Wins>23</Wins>
</Racer>
<Racer>
<Firstname>Ayrton</Firstname>
<Lastname>Senna</Lastname>
<Country>Brazil</Country>
<Starts>161</Starts>
<Wins>41</Wins>
</Racer>
<Racer>
<Firstname>Nigel</Firstname>
<Lastname>Mansell</Lastname>
<Country>England</Country>
<Starts>187</Starts>
<Wins>31</Wins>
</Racer>
//... more sample data
The method Formula1VerificationData returns sample test data that
matches the expected result (code file
UnitTestingSamples.MSTests/Formula1Test.cs ):
internal static XElement Formula1VerificationData()
{
return XElement.Parse(@"
<Racers>
<Racer Name=""Mika Hakkinen"" Country=""Finland""
Wins=""20"" />
<Racer Name=""Kimi Raikkonen"" Country=""Finland""
Wins=""18"" />


</Racers>");
}
The loader of the test data implements the same interface
— IChampionsLoader —as the ChampionsLoader class. This loader makes
use of the sample data; it doesn’t access the web server (code file
UnitTestingSamples.MSTests/Formula1Test.cs ):
public class F1TestLoader: IChampionsLoader
{
public XElement LoadChampions() =>
XElement.Parse(Formula1SampleData());
}
Now it’s easy to create a unit test that makes use of the sample data
(code file UnitTestingSamples.MSTests/Formula1Test.cs ):
[TestMethod]
public void ChampionsByCountryFilterFinland()
{
Formula1 f1 = new Formula1(new F1TestLoader());
XElement actual = f1.ChampionsByCountry("Finland");
Assert.AreEqual(Formula1VerificationData().ToString(),
actual.ToString());
}
Of course, a real test should do more than cover a case that passes
Finland as a string and two champions are returned with the test data.
You should write other tests to pass a string with no matching result,
to return more than two champions, and to result in a number sort
order that is different from the alphanumeric sort order.
NOTE
To test methods that don’t use dependency injection, to replace the
internally used dependencies with test classes, you can use the
Fakes Framework. This is available only for .NET Framework
projects with Visual Studio Enterprise.


UNIT TESTING WITH XUNIT
When .NET Core was implemented, xUnit was available to create unit
tests, and the .NET Core team used this product. xUnit is an open-
source implementation from the same developer who created NUnit
2.0. Nowadays, both MSTest and xUnit are supported by the .NET
Core command-line interface.
TIP
See https://xunit.github.io/ for documentation on xUnit.
With the Visual Studio Test environment, several testing frameworks
can be used. Test adapters such as NUnit, xUnit, Boost (for C++),
Chutzpah (for JavaScript), and Jasmine (for JavaScript) are available
via Extensions and Updates; these test adapters integrate with the
Visual Studio Test Explorer.
Because xUnit is a great testing framework for .NET Core, and it’s also
used by Microsoft with the open-source code of .NET Core and
ASP.NET Core, xUnit is the focus of this section.
Using xUnit with .NET Core
You can create xUnit tests in a similar manner to MSTest tests with
.NET Core applications. From the command line, you can use
> dotnet new xunit
to create an xUnit test project. With Visual Studio 2017, you can select
the project type xUnit Test Project (.NET Core).
With this sample project, the same .NET Standard library as before
— UnitTestingSamples —is tested. This library includes the same types
for testing that were shown earlier: DeepThought and StringSample . The
test project has the name UnitTestingSamples.xUnit.Tests .
This project needs references to xunit (for the unit tests,


xunit.runner.visualstudio [to run the tests within Visual Studio]) and
to the UnitTestingSamples project (the code that should be tested). For
integration with the .NET Core command line, the
DotNetCliToolReference for dotnet-xunit is added (project file
UnitTestingSamples.xUnit.Tests/UnitTestingSamples.xUnit.Tests.csproj
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<TargetFramework>netcoreapp2.0</TargetFramework>
<IsPackable>false</IsPackable>
</PropertyGroup>
<ItemGroup>
<PackageReference Include="Microsoft.NET.Test.Sdk"
Version="15.5.0" />
<PackageReference Include="xunit" Version="2.3.1" />
<PackageReference Include="xunit.runner.visualstudio"
Version="2.3.1" />
<DotNetCliToolReference Include="dotnet-xunit"
Version="2.3.1" />
</ItemGroup>
<ItemGroup>
<ProjectReference
Include="..\UnitTestingSamples\UnitTestingSamples.csproj" />
</ItemGroup>
</Project>
Creating Facts
The way you create the test is very similar to what you did before. With
MSTest you had to add an attribute to the testing class. This is not
necessary with xUnit because all public classes are searched for test
methods. The differences on testing the method
TheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything
between MSTest and xUnit are just the annotated test method with the
Fact attribute and the different Assert.Equa l method (code file
UnitTestingSamples.xUnit.Tests/DeepThoughtTest.cs ):
public class DeepThoughtTest
{
[Fact]


public void
ResultOfTheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverythingTest
{
int expected = 42;
var dt = new DeepThought();
int actual =
dt.TheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything();
Assert.Equal(expected, actual);
}
}
The Assert class used now is defined in the XUnit namespace. This
class defines a lot more methods for validation compared to the Assert
method from MSTest. For example, instead of adding an attribute to
specify an expected exception, use the Assert.Throws method, which
allows multiple checks for exceptions within a single test method (code
file UnitTestingSamples.xUnit.Tests/StringSampleTest.cs ):
[Fact]
public void GetStringDemoExceptions()
{
var sample = new StringSample(string.Empty);
Assert.Throws<ArgumentNullException>(() =>
sample.GetStringDemo(null, "a"));
Assert.Throws<ArgumentNullException>(() =>
sample.GetStringDemo("a", null));
Assert.Throws<ArgumentException>(() =>
sample.GetStringDemo(string.Empty, "a"));
}
Creating Theories
xUnit defines the Fact attribute for test methods that don’t require
parameters. With xUnit you can also invoke unit test methods that
require parameters; you use the Theory attribute and supply data to
add an attribute that derives from Data . This makes it possible to
define multiple unit tests by a single method.
In the following code snippet, the Theory attribute is applied to the
GetStringDemoInlineData unit test method. The method


defines different paths that depend on the
input data. The first path is reached if the string passed with the
second parameter is not contained within the first parameter. The
second path is reached if the second string is contained within the first
five characters of the first string. The third path is reached with the
else clause. To reach all the different paths, three InlineData
attributes are applied to the testing method. Every one of these
attributes defines four parameters that are directly sent to the
invocation of the unit testing method, in the same order. The
attributes also define the values that should be returned by the method
under test (code file
UnitTestingSamples.xUnit.Tests/StringSampleTest.cs ):
StringSample.GetStringDemo
[Theory]
[InlineData("", "longer string", "nger",
"removed nger from longer string: lo string")]
[InlineData("init", "longer string", "string", "INIT")]
public void GetStringDemoInlineData(string init, string a,
string b,
string expected)
{
var sample = new StringSample(init);
string actual = sample.GetStringDemo(a, b);
Assert.Equal(expected, actual);
}
The attribute InlineData derives from the attribute Data . Instead of
directly supplying the values for the test method with the attribute, the
values can also come from a property, method, or a class. The
following example defines a static method that returns the same values
with an IEnumerable<object> object (code file
UnitTestingSamples.xUnit.Tests/StringSampleTest.cs ):
public static IEnumerable<object[]> GetStringSampleData() =>
new[]
{
new object[] { "", "a", "b", "b not found in a" },
new object[] { "", "longer string", "nger",
"removed nger from longer string: lo string" },
new object[] { "init", "longer string", "string", "INIT"
}
};


The unit test method is now changed with the MemberData attribute.
This attribute allows using static properties or methods that return
IEnumerable<object> to fill in the parameters of the unit test method
(code file UnitTestingSamples.xUnit.Tests/StringSampleTest.cs ):
[Theory]
[MemberData("GetStringSampleData")]
public void GetStringDemoMemberData(string init, string a,
string b,
string expected)
{
var sample = new StringSample(init);
string actual = sample.GetStringDemo(a, b);
Assert.Equal(expected, actual);
}
Using a Mocking Library
Let’s get into a more complex example: creating a unit test for a client-
side service library from an app using the MVVM pattern. Read
Chapter 34, “Patterns with XAML Apps,” for a complete picture from
this app. The sample code for this chapter only includes a library used
by this app. This service uses dependency injection to inject the
repository defined by the interface IBooksRepository . The unit tests for
testing the method AddOrUpdateBookAsync shouldn’t test the repository;
they test only the functionality within the method. For the repository,
another unit test should be done: The following code snippet shows
the implementation of the BooksService class (code file
MockingSamples/BooksLib/Services/BooksService.cs ):
public class BooksService: IBooksService
{
private ObservableCollection<Book> _books = new
ObservableCollection<Book>();
private IBooksRepository _booksRepository;
public BooksService(IBooksRepository repository)
{
_booksRepository = repository;
}
public async Task LoadBooksAsync()
{
if (_books.Count > 0) return;


IEnumerable<Book> books = await
_booksRepository.GetItemsAsync();
_books.Clear();
foreach (var b in books)
{
_books.Add(b);
}
}
public Book GetBook(int bookId) =>
_books.Where(b => b.BookId == bookId).SingleOrDefault();
public async Task<Book> AddOrUpdateBookAsync(Book book)
{
if (book == null) throw new
ArgumentNullException(nameof(book));
Book updated = null;
if (book.BookId == 0)
{
updated = await _booksRepository.AddAsync(book);
if (updated == null) throw new
InvalidOperationException();
_books.Add(updated);
}
else
{
updated = await _booksRepository.UpdateAsync(book);
if (updated == null) throw new
InvalidOperationException();
Book old = _books.Where(b => b.BookId ==
updated.BookId).Single();
int ix = _books.IndexOf(old);
_books.RemoveAt(ix);
_books.Insert(ix, updated);
}
return updated;
}
public IEnumerable<Book> Books => _books;
}
Because the unit test for AddOrUpdateBookAsync shouldn’t test the
repository used for IBooksRepository , you need to implement a
repository used for testing. To make this easy, you can use a mocking


library that automatically fills in the blanks. A commonly used
mocking library is Moq. With the unit testing project, the NuGet
package Moq is added.
NOTE
Instead of using the Moq framework, you also can implement an
in-memory repository with sample data. You probably do this
anyway to have sample data for the app during design time of the
user interface.
When you use xUnit, a new instance of the test class is created for
every test run. In case you need common functionality for multiple
tests, you can move this functionality to the constructor. In case
resources need to be released after each test run, you can implement
the interface IDisposable .
Within the constructor of the BooksServiceTest class, a Mock object is
instantiated with the generic parameter IBooksRepository . The Mock
constructor creates an implementation for the interface. Because you
need some results from the repository other than null to create useful
tests, the Setup method defines which parameters can be passed, and
the ReturnsAsync method defines the result that’s returned from the
method stub. You access the mock object by using the Object property
of the Mock class, and it is passed on to create an instance of the
BooksService class. With these settings in place, you can implement
the unit tests (code file
MockingSamples/BooksLib.Tests/Services/BooksServiceTest.cs ):
public class BooksServiceTest : IDisposable
{
private const string TestTitle = "Test Title";
private const string UpdatedTestTitle = "Updated Test
Title";
public const string APublisher = "A Publisher";
private BooksService _booksService;
private Book _newBook = new Book
{


BookId = 0,
Title = TestTitle,
Publisher = APublisher
};
private Book _expectedBook = new Book
{
BookId = 1,
Title = TestTitle,
Publisher = APublisher
};
private Book _notInRepositoryBook = new Book
{
BookId = 42,
Title = TestTitle,
Publisher = APublisher
};
private Book _updatedBook = new Book
{
BookId = 1,
Title = UpdatedTestTitle,
Publisher = APublisher
};
public BooksServiceTest()
{
var mock = new Mock<IBooksRepository>();
mock.Setup(repository =>
repository.AddAsync(_newBook)).ReturnsAsync(_expectedBook);
mock.Setup(repository =>
repository.UpdateAsync(_notInRepositoryBook)).ReturnsAsync(null
as Book);
mock.Setup(repository =>
repository.UpdateAsync(_updatedBook)).ReturnsAsync(_updatedBook);
_booksService = new BooksService(mock.Object);
}
//...
NOTE


The IDisposable interface is explained in detail in Chapter 17,
“Managed and Unmanaged Memory.”
The first unit test implemented— AddOrUpdateBookAsync_ThrowsForNull
—verifies that an ArgumentNullException is thrown in case null is
passed to the AddOrUpdateBookAsync method. The implementation just
needs the _booksService member variable that is instantiated within
the constructor, but it doesn’t need the mocking setup. This code
sample also shows that unit test methods can be implemented as
asynchronous methods that return a Task (code file
MockingSamples/BooksLib.Tests/Services/BooksServiceTest.cs ):
[Fact]
public async Task AddOrUpdateBookAsync_ThrowsForNull()
{
// arrange
Book nullBook = null;
// act and assert
await Assert.ThrowsAsync<ArgumentNullException>(() =>
_booksService.AddOrUpdateBookAsync(nullBook));
}
The unit test method
AddOrUpdateBook_AddedBookReturnsFromRepository adds a new book
(variable _newBook ) to the service and expects the book _expectedBook
to be returned. Within the implementation of the
AddOrUpdateBookAsync method, the AddAsync method of the
IBooksRepository is invoked; thus, the previously defined mock setup
for this method applies. The result of this method should be that the
Book returned is equal to the _expectedBook , and the _ expectedBook
also needs to be added to the books collection of the BooksService
(code file
MockingSamples/BooksLib.Tests/Services/BooksServiceTest.cs ):
[Fact]
public async Task
AddOrUpdateBook_AddedBookReturnsFromRepository()
{
// arrange in constructor
// act
Book actualAdded = await


_booksService.AddOrUpdateBookAsync(_newBook);
// assert
Assert.Equal(_expectedBook, actualAdded);
Assert.Contains(_expectedBook, _booksService.Books);
}
The unit test AddOrUpdateBook_UpdateNotExistingBookThrows verifies
that trying to update a book that does not exist in the service needs to
result in an InvalidOperationException (code file
MockingSamples/BooksLib.Tests/Services/BooksServiceTest.cs ):
[Fact]
public async Task
AddOrUpdateBook_UpdateNotExistingBookThrows()
{
// arrange in constructor
// act and assert
await Assert.ThrowsAsync<InvalidOperationException>(() =>
_booksService.AddOrUpdateBookAsync(_notInRepositoryBook));
}
The usual case to update a book is dealt with the unit test
AddOrUpdateBook_UpdateBook . Here, extra preparation is needed to first
add the book to the service before updating it (code file
MockingSamples/BooksLib.Tests/Services/BooksServiceTest.cs ):
[Fact]
public async Task AddOrUpdateBook_UpdateBook()
{
// arrange
await _booksService.AddOrUpdateBookAsync(_newBook);
// act
Book updatedBook = await
_booksService.AddOrUpdateBookAsync(_updatedBook);
// assert
Assert.Equal(_updatedBook, updatedBook);
Assert.Contains(_updatedBook, _booksService.Books);
}
When you use the MVVM pattern with XAML-based applications and
the MVC pattern with web-based applications, you reduce the


complexity of the user interface and reduce the need for complex UI
testing. However, there are still some scenarios that should be tested
with the UI—for example, navigating through pages, drag and drop of
elements, and more. This is where Visual Studio’s functionality of UI
testing comes into place.
Testing user interfaces is covered in the section “UI Testing.” Testing
web applications is covered in the section “Web Integration, Load, and
Performance Testing.”
LIVE UNIT TESTING
A great feature for unit testing is available with the Enterprise edition
of Visual Studio 2017: Live Unit Testing. It’s best to see errors as early
as possible, and the first place you can see them is in the Visual Studio
editor. From the Test menu, you can start Live Unit Testing. With Live
Unit Testing turned on, you can directly see in the editor what code
lines are covered by tests and where the test runs successful (see
Figure 28-4).


FIGURE 28-4
In case you introduce some error in the code editor, you can see the
issue immediately—even without saving the file. If the compiler runs
successfully while you’re editing, the unit tests associated with the
method you just edited runs, and you can see the results (as shown in
Figure 28-5) and can react accordingly.


FIGURE 28-5
All tests running while editing should run fast. You shouldn’t run
integration tests with Live Unit Testing. In the Solution Explorer, you
can select test projects and test classes to be excluded or included from
Live Unit Testing.
You also can exclude specific test methods using annotations—with
xUnit using the Trait attribute:
[Trait("Category", "SkipWhenLiveUnitTesting")]
and with MSTest using the TestCategory attribute:
[TestCategory("SkipWhenLiveUnitTesting")]
Live Unit Tests also don’t run when the battery is less than 30 percent.
You can configure this setting and other Live Unit Test settings with
Visual Studio by selecting Tools ⇨ Options.


UNIT TESTING WITH EF CORE
When you create unit tests, you need to replace dependencies with test
classes that offer test data. What about dependencies on the Entity
Framework Core (EF Core) context? Usually there’s not an interface
that is implemented by the context, but the context (for example, the
BooksContext ) is injected itself. EF Core offers a solution with a
memory-based provider that can be used as a mocking class instead of
using the EF Core SQL Server provider.
NOTE
EF Core is discussed in detail in Chapter 26, “Entity Framework
Core.”
Let’s start with a simple Book type, a BooksContext , and a BooksService .
The BooksService class should be tested from unit tests.
The Book class is a simple class that keeps a few properties (code file
EFCoreSample/EFCoreSample/Book.cs ):
public class Book
{
public int BookId { get; set; }
public string Title { get; set; }
public string Publisher { get; set; }
}
The class BooksContext manages the connection to the database and
maps the Book type to the Books table (code file
EFCoreSample/EFCoreSample/BooksContext.cs ):
public class BooksContext : DbContext
{
public BooksContext(DbContextOptions<BooksContext> options)
: base(options) { }
public DbSet<Book> Books { get; set; }
}


And finally, the class BooksService uses the BooksContext via
dependency injection and defines the method GetTopBooksByPublisher .
This method should be tested to only return 10 books (code file
EFCoreSample/EFCoreSample/BooksService.cs ):
public class BooksService
{
private readonly BooksContext _booksContext;
public BooksService(BooksContext booksContext)
{
_booksContext = booksContext;
}
public IEnumerable<Book> GetTopBooksByPublisher(string
publisher)
{
if (publisher == null) throw new
ArgumentNullException(nameof(publisher));
return _booksContext.Books
.Where(b => b.Publisher == publisher)
.Take(10)
.ToList();
}
}
For unit testing, an xUnit project is created. For using the EF Core in-
memory provider, the NuGet package
Microsoft.EntityFrameworkCore.InMemory is added in addition to the
EFCoreSample project.
Now, you can use the DbContextOptionsBuilder to create the options
with the in-memory database. UseInMemoryDatabase is an extension
method from the package Microsoft.EntityFrameworkCore.InMemory to
add the EF Core in-memory provider. In the InitContext method,
1000 book objects are created and saved into the object list of the
context to be ready to be used by the unit test (code file
EFCoreSample/EFCoreSample.Tests/BooksServiceTest.cs ):
public class BooksServiceTest : IDisposable
{
private BooksContext _booksContext;
private const string PublisherName = "A Publisher";


public BooksServiceTest()
{
InitContext();
}
private void InitContext()
{
var builder = new DbContextOptionsBuilder<BooksContext>()
.UseInMemoryDatabase("BooksDB");
_booksContext = new BooksContext(builder.Options);
// init with 1000 books
var books = Enumerable.Range(1, 1000)
.Select(i =>
new Book
{
BookId = i,
Title = $"Sample {i}",
Publisher = PublisherName })
.ToList();
_booksContext.Books.AddRange(books);
_booksContext.SaveChanges();
}
//...
public void Dispose()
{
_booksContext?.Dispose();
}
}
NOTE
The Enumerable class and the Range method are discussed in
Chapter 12, “Language Integrated Query.”
The unit test method GetTopBooksByPublisherCount now instantiates
the BooksService in the arrange section, invokes the
GetTopBooksByPublisher method in the act section, and finally checks
the number of books returned in the assert section (code file
EFCoreSample/EFCoreSample.Tests/BooksServiceTest.cs ):


[Fact]
public void GetTopBooksByPublisherCount()
{
// arrange
var booksService = new BooksService(_booksContext);
// act
var topbooks =
booksService.GetTopBooksByPublisher(PublisherName);
// assert
Assert.Equal(10, topbooks.Count());
}
UI TESTING WITH WINDOWS APPS
For testing the user interface, Visual Studio offers Coded UI Test
Project templates for Universal Windows apps, WPF applications, and
Windows Forms. When you create a new project, you can find the
project template for WPF and Windows Forms in the Test group.
However, this template doesn’t work for Windows apps. The project
template for Universal Windows apps is in the Windows Universal
group. Be aware that automatic recording is not supported for
Windows apps.
NOTE
Read chapters 33 to 36 for more detailed information on creating
Windows Apps.
In this chapter you create a UI test for a simple Windows app. This
application is part of the downloadable files for this chapter, so you
can use it for testing. The app just contains a TextBox control to enter
some text, a Button control, and a TextBlock control where the text
entered should show up when the user clicks the button as shown in
Figure 28-6.


FIGURE 28-6
When you create a new Coded UI Test Project (Universal Windows),
you see the dialog shown in Figure 28-7. When you select the Edit UI
Map or Add Assertions option, you can select controls from a running
app that adds automation peers of the controls to a map, so you can
easily access it programmatically.
FIGURE 28-7


After you click OK to create a new project, the Coded UI Test Builder
opens (see Figure 28-8). Recording of actions is not supported for
Windows apps, so this option is grayed out, but you can add controls
to the UI map by dragging the crosshair over controls of the running
app.
FIGURE 28-8
As you select controls, the list of them shows up in the left part of the
tool, and the right part shows the properties of the selected controls
(see Figure 28-9). You need to click the leftmost button (Add Control
to UI Control Map) to finally add the control to the map.
FIGURE 28-9
As the last step you need to click the Generate button (Figure 28-10) in
the UIMap - Coded UI Test Builder window. A dialog with a method
name shows up, but as with Windows apps only controls are
generated, a method name is not needed, and you just need to click the
Generate button.


FIGURE 28-10
You can find the generated code in a partial class in the file
UIMap.Designer.cs . You can extend this class in the file UIMap.cs . The
designer-generated file will be overwritten if you start the Coded UI
Test Builder again.
The designer-generated code defines the UIMap class that contains a
property for the UIWindowsAppWindow . This class represents the window
with the contained controls (code file
WindowsApp/WindowsApp.UITest/UIMap.Designer.cs ):
[GeneratedCode("Coded UITest Builder", "15.0.26621.2")]
public partial class UIMap
{
public UIWindowsAppWindow UIWindowsAppWindow
{
get
{
if ((this.mUIWindowsAppWindow == null))
{
this.mUIWindowsAppWindow = new UIWindowsAppWindow();
}
return this.mUIWindowsAppWindow;
}
}
private UIWindowsAppWindow mUIWindowsAppWindow;
}
The class UIWindowsAppWindow derives from the base class XamlWindow
and defines SearchProperties that are used when the app is launched.


If the app is already running, you can find the app by using the name
of the window. With the sample app it is set to WindowsApp and the
class name Windows.UI.Core.CoreWindow (code file
WindowsApp/WindowsApp.UITest/UIMap.Designer.cs ):
[GeneratedCode("Coded UITest Builder", "15.0.26621.2")]
public class UIWindowsAppWindow : XamlWindow
{
public UIWindowsAppWindow()
{
this.SearchProperties[XamlControl.PropertyNames.Name] =
"WindowsApp";
this.SearchProperties[XamlControl.PropertyNames.ClassName] =
"Windows.UI.Core.CoreWindow";
this.WindowTitles.Add("WindowsApp");
}
//...
For every control that is selected using the Coded UI Test Builder, a
field and a property are created. In the following code snippet, you can
see the generated code for the TextBox control. Every UWP control has
an automation peer. For the TextBox control it is the XamlEdit class. To
map the UITextInEdit property to the corresponding TextBox control,
you use an AutomationId . The AutomationId can be set with the control
definition using the attached property
AutomationProperties.AutomationId . The sample code of the Windows
app defines this attached property in the XAML code in the file
MainPage.xaml . In case the AutomationId is not directly set, it is
generated with the same name as the Name property of the control. The
get accessor of the property implements the creation of the XamlEdit
control the first time the property is accessed. After the initial creation,
the value of the field is returned (code file
WindowsApp/WindowsApp.UITest/UIMap.Designer.cs ):
public XamlEdit UITextInEdit
{
get
{
if ((this.mUITextInEdit == null))
{
this.mUITextInEdit = new XamlEdit(this);
this.mUITextInEdit


.SearchProperties[XamlEdit.PropertyNames.AutomationId] =
"textIn";
this.mUITextInEdit.WindowTitles.Add("WindowsApp");
}
return this.mUITextInEdit;
}
}
private XamlEdit mUITextInEdit;
NOTE
Attached properties are covered in Chapter 33, “Windows Apps.”
The test class MainPageTest is annotated with the attribute
CodedUITest . This attribute derives from the base class
TestClassExtensionAttribute and identifies the kind of the UI test. To
start the application, you need the automation ID of the application.
You can get this ID either by using the crosshair from the Coded UI
Test Builder and selecting the tile of the application, or by opening the
Packaging tab in the Package.appxmanifest editor. In the Packaging tab
(see Figure 28-11), you can copy the package family name and add
!App as postfix. To access the generated UIMap, the test class defines a
property (code file WindowsApp/WindowsApp.UITest/MainPageTest.cs ):
[CodedUITest(CodedUITestType.WindowsStore)]
public class MainPageTest
{
private string TileAutomationId =
"0e07ecab-af0f-4129-965b-eed7a5beef75_p2wxv0ry6mv8g!App";
//...
public TestContext TestContext
{
get => testContextInstance;
set => testContextInstance = value;
}
private TestContext testContextInstance;
public UIMap UIMap


{
get
{
if (this.map == null)
{
this.map = new UIMap();
}
return this.map;
}
}
private UIMap map;
}
FIGURE 28-11
The test is defined in the test method EnterTextAndButtonClick . First,
you launch the application using the previously defined automation ID
of the app. Next, the Text property of the TextBox control is filled by
setting the Text property of the automation peer XamlEdit control.
Gestures such as button clicks are done with the Gesture class.
Gesture.Tap taps or clicks into a control; with the code snippet the
control that is clicked into is selected by using the UIClickMeButton ,
which is the associated XamlButton peer control. Finally, the text is
read from the TextBlock associated XamlText control (code file
WindowsApp/WindowsApp.UITest/MainPageTest.cs ):
[TestMethod]


public void EnterTextAndButtonClick()
{
string inText = "Hello, Windows!";
XamlWindow xamlWindow =
XamlWindow.Launch(TileAutomationId);
UIMap.UIWindowsAppWindow.UITextInEdit.Text = inText;
Gesture.Tap(UIMap.UIWindowsAppWindow.UIClickMeButton);
string outText =
UIMap.UIWindowsAppWindow.UITextOutText.DisplayText;
xamlWindow.Close();
Assert.AreEqual(inText, outText);
}
Now you can run the UI test in the same way you run the unit tests, as
shown earlier in this chapter.
WEB INTEGRATION, LOAD, AND PERFORMANCE
TESTING
To test web applications, you can create unit tests that invoke methods
of the controllers, repository, and utility classes. Tag helpers are
simple methods in which the test can be covered by unit tests. Unit
tests are used to test the functionality of the algorithms of the methods
—in other words, the logic inside the methods. With web applications,
it is also a good practice to create integration, performance, and load
tests. Does everything work together? Does the application scale? How
many users can the application support with one server? How many
servers are needed to support a specific number of users? Which
bottleneck is not that easy to scale? To answer these questions, Web
tests can help.
ASP.NET Core offers a hosting class to create integration tests. Visual
Studio Enterprise 2017 offers the Web Load and Performance Tests
with a recorder to record HTTP requests. The recorder needs an add-
in within Internet Explorer.
ASP.NET Core Integration Tests
With integration tests, you test everything about the web app from the
HTTP request to the back end. You should have a lot more unit tests
than integration tests. You probably have thousands of unit tests, but


only a few integration tests. If the same functionality could be covered
either by unit or integration tests, you should choose unit tests. The
Visual Studio feature Live Unit Testing is useful to run with unit tests,
but you shouldn’t use this with integration tests. Integration tests are
needed to have the complete picture, to see how everything runs from
the front end to the back end.
To create an ASP.NET Core integration test, create an ASP.NET Core
Web Application named ASPNETCoreSample with the Empty template.
Running the application from the generated code returns the string
“ Hello World! ”, and this will be tested from an integration test using
xUnit.
NOTE
ASP.NET Core is covered in detail in the Chapters 30 to 32 and
Bonus Chapter 3, which you can find online.
The xUnit project ASPNETCoreSample.IntegrationTest needs a package
reference to Microsoft.AspNetCore.TestHost . This package contains
the TestServer class to host and start the web application and to send
requests. A reference to the web project ASPNETCoreSample is needed as
well.
A common arrangement of the integration tests is handled in the
constructor. Here the TestServer is instantiated, passing an
IWebHostBuilder to the constructor of the TestServer class. You need to
do a similar setup as in your Program.cs file from the ASP.NET Core
web application to enable the same configuration files, and the same
middleware (code file
ASPNETCoreSample/ASPNETCoreSample.IntegrationTest/AspNetCoreSampleTest.cs
public class ASPNETCoreSampleTest : IDisposable
{
private TestServer _testServer;
public ASPNETCoreSampleTest()
{


_testServer = new TestServer(
WebHost.CreateDefaultBuilder().UseStartup<Startup>());
}
public void Dispose() => _testServer?.Dispose();
//...
}
In the integration test, using the _testServer variable you can create a
request to the Home page, and invoke the GetAsync method of the
returned RequestBuilder . The returned HttpResponseMessage is
checked for a successful status code before the content is read using
ReadAsStringAsync from the Content property. In the assert section, the
result is compared with the expected string (code file
ASPNETCoreSample/ASPNETCoreSample.IntegrationTest/AspNetCoreSampleTest.cs
[Fact]
public async Task ReturnHelloWorld()
{
// act
RequestBuilder requestBuilder =
_testServer.CreateRequest("/");
HttpResponseMessage response = await
requestBuilder.GetAsync();
response.EnsureSuccessStatusCode();
var responseString = await
response.Content.ReadAsStringAsync();
// assert
Assert.Equal("Hello World!", responseString);
}
With the RequestBuilder class you can create HTTP GET, POST, PUT...
requests, and add HTTP header information. The result of the
GetAsync method looks like the results from the HttpClient class in
Chapter 23, “Networking.” Indeed, you can directly access the
HttpClient class from the TestServer by invoking the CreateClient
method. The method CreateWebSocketClient returns a
WebSocketClient instance, thus you can also create WebSocket
requests. WebSockets are covered in Bonus Chapter 3, “WebHooks
and SignalR,” which you can find online.


Creating the Web Test
Now that you’ve created an integration test for ASP.NET Core, let’s
move into a feature of Visual Studio Enterprise 2017, Web
Performance and Load Tests.
For creating a web test, you can create a new ASP.NET Core Web
Application by selecting Web Application (Model-View-Controller),
and making sure Authentication is set to Individual User Accounts.
This template has functionality built in that allows for creating tests.
Before creating the web tests, start the application and register a user
with the application.
To create web tests, you add a Web Performance and Load Test Project
named WebAndLoadTest to the solution. Click the generated file
WebTest1.webtest file to open the Web Test Editor. Then start a web
recording by clicking the Add Recording button. For this recording,
you must have the Web Test Recorder add-in with Internet Explorer
that’s installed with the installation of Visual Studio. The recorder
records all HTTP requests sent to the server. Click some links on the
WebApplicationSample web application such as About and Contact and
register a new user. Then click the Stop button to stop the recording.
After the recording is finished, you can edit the recording with the
Web Test Editor. A recording is shown in Figure 28-12. With all the
requests, you can see header information as well as form POST data
that you can influence and change.


FIGURE 28-12
Delete the recordings you don’t need, and then click the Generate
Code button with the test name NavigateAndRegisterTest to generate
source code to send all the requests programmatically. With web tests,
the test class derives from the base class WebTest and overrides the
GetRequestEnumerator method. This method returns one request after
the other (code file
WebApplicationSample/WebAndLoadTest/NavigateAndRegisterTest.cs ):
public class NavigateAndRegisterTest: WebTest
{
public NavigateAndRegister()
{
this.PreAuthenticate = true;
this.Proxy = "default";
}
public override IEnumerator<WebTestRequest>
GetRequestEnumerator()
{
//...
}
}
The method GetRequestEnumerator defines requests to the website—for


example, a request to the About page. With this request, an HTTP
header is added to define that the request originates from the home
page:
public override IEnumerator<WebTestRequest>
GetRequestEnumerator()
{
//...
WebTestRequest request2 =
new WebTestRequest("http://localhost:44336/Home/About");
request2.ThinkTime = 1;
request2.Headers.Add(new WebTestRequestHeader("Referer",
"http://localhost:44336/"));
yield return request2;
request2 = null;
//...
}
And this is the request to send an HTTP POST request to the Register
page that is passing form data:
WebTestRequest request6 =
new
WebTestRequest("http://localhost:44336/Account/Register");
request6.Method = "POST";
request6.ExpectedResponseUrl = "http://localhost:44336/";
request6.Headers.Add(new WebTestRequestHeader("Referer",
"http://localhost:44336/Account/Register"));
FormPostHttpBody request6Body = new FormPostHttpBody();
request6Body.FormPostParameters.Add("Email",
"sample1@test.com");
request6Body.FormPostParameters.Add("Password",
"Pa$$w0rd");
request6Body.FormPostParameters.Add("ConfirmPassword",
"Pa$$w0rd");
request6Body.FormPostParameters.Add("__RequestVerificationToken",
this.Context["$HIDDEN1.__RequestVerificationToken"].ToString());
request6.Body = request6Body;
yield return request6;
request6 = null;
With some data you enter in forms, it can be a good idea to add


flexibility by taking the data from a data source. Using the Web Test
Editor, you can add a database, CSV file, or XML file as a data source
(see Figure 28-13). With this dialog box, you can change form
parameters to take data from a data source.
FIGURE 28-13
Adding a data source modifies the testing code. With a data source, the
test class is annotated with the DeploymentItem attribute (if a CSV or
XML file is used), and with DataSource and DataBinding attributes:
[DeploymentItem("webandloadtestproject\\EmailTests.csv",
"webandloadtestproject")]
[DataSource("EmailDataSource",
"Microsoft.VisualStudio.TestTools.DataSource.CSV",


"|DataDirectory|\\webandloadtestproject\\EmailTests.csv",
Microsoft.VisualStudio.TestTools.WebTesting.DataBindingAccessMethod
.Sequential,
Microsoft.VisualStudio.TestTools.WebTesting.DataBindingSelectColumns
.SelectOnlyBoundColumns, "EmailTests#csv")]
[DataBinding("EmailDataSource", "EmailTests#csv",
"sample1@test#com",
"EmailDataSource.EmailTests#csv.sample1@test#com")]
public class NavigateAndRegister1: WebTest
{
//...
}
Now, in the code the data source can be accessed using the Context
property of the WebTest that returns a WebTestContext to access the
required data source via an index:
request6Body.FormPostParameters.Add("Email",
this.Context["EmailDataSource.EmailTests#csv.sample1@test#com"].ToString
Running the Web Test
With the tests in place, the testing can start. You can run—and debug—
the test directly from the Web Test Editor. Remember to start the web
application before you start the test. When you run the test from the
Web Test Editor, you can see the resulting web pages as well as the
detail information about requests and responses, as shown in Figure
28-14.


FIGURE 28-14
Using Web Load Tests, you can simulate a high load on the web
application. Clicking on the solution item Local.testsettings , you can
select to run the tests on Visual Studio Team Services for running the
tests on multiple servers (see Figure 28-15). For the sample, we’ll stay
on the local machine.


FIGURE 28-15
In the Web Test dialog, you can influence the test runs by specifying a
browser type, simulating think times, and running the test multiple
times (see Figure 28-16).


FIGURE 28-16
NOTE
Load testing of web apps with Visual Studio requires the
Enterprise edition of Visual Studio. If you don’t have the
Enterprise edition, you can check an alternative: Selenium
— http://www.seleniumhq.org/ .
SUMMARY
In this chapter, you’ve seen the most important aspects about testing
applications: creating unit tests, coded UI tests, and Web tests.
Visual Studio offers a Test Explorer to run unit tests, no matter
whether they have been created using MSTest or xUnit. This chapter


also showed you triple A in action: Arrange, Act, and Assert.
With coded UI tests, you’ve seen how to create recordings and adapt
the recordings to modify the UI testing code as needed.
With ASP.NET Core Web applications, you’ve seen how the TestHost
class can be used for integration tests, and this chapter gave you an
introduction to the web load and performance tests from Visual
Studio.
Although testing helps with fixing issues with applications before they
are deployed, Chapter 29, “Tracing, Logging, and Analytics,” helps you
fix applications that are running.