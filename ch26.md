
# Entity Framework Core
WHAT’S IN THIS CHAPTER?
- Introducing Entity Framework Core
- Using dependency injection with Entity Framework
- Conventions, annotations, and the fluent API
- Using queries, compiled queries, global query filters
- Defining relationships with conventions, annotations, and the fluent API
- Using table per hierarchy, table splitting, and owned entities
- Object tracking
- Updating objects and object trees
- Conflict handling with updates
- Using transactions
- Using migrations with the .NET CLI tools

WROX.COM CODE DOWNLOADS FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory EFCore . The code for this chapter is divided into the
following major examples:
- Intro
- Books Sample
- UsingDependencyInjection
- Menus Sample
- Menus with Data Annotations
- Relations with Annotations/Conventions/FluentAPI
- Table per Hierarchy
- Conflict Handling Sample
- Transactions Sample

## HISTORY OF ENTITY FRAMEWORK
Entity Framework and Entity Framework Core (EF Core) are
frameworks offering mapping of entities to relationships. With these,
you can create types that map to database tables, create database
queries using LINQ, create and update objects, and write them to the
database.

After many years of changes to Entity Framework, EF Core is a
complete rewrite. Let’s have a look at the history of Entity Framework
to see the reasons for the rewrite.

- Entity Framework 1——The first version of Entity Framework was
not ready with .NET 3.5, but it was soon available with .NET 3.5
SP1. Another product offering somewhat similar functionality that
was already available with .NET 3.5 was LINQ to SQL. Both LINQ
to SQL and Entity Framework offered similar features from a wide
view. However, LINQ to SQL was simpler to use but was only
available for accessing SQL Server. Entity Framework was
provider-based and offered access to several different relational
databases. It included more features, such as many-to-many
mapping without the need for mapping objects, and n-to-n
mapping was possible. One disadvantage of Entity Framework was
that it required model types to derive from the EntityObject base
class. Mapping the objects to relations was done using an EDMX
file that contains XML. The XML contained is defined by three
schemas: The Conceptual Schema Definition (CSD) defines the
object types with their properties and associations; the Storage
Schema Definition (SSD) defines the database tables, columns, and
relations; and the Mapping Schema Language (MSL) defines how
the CSD and SSD map to each other.

- Entity Framework 4——Entity Framework 4 was available with
.NET 4 and received major improvements, many coming from
LINQ to SQL ideas. Because of the big changes, versions 2 and 3
have been skipped. With this edition, lazy loading was added to
fetch relations on accessing a property. Creating a database was
possible after designing a model using SQL Data Definition
Language (DDL). The two models using Entity Framework were
now Database First or Model First. Possibly the most important
feature added was the support for Plain Old CLR Objects (POCO),
so it was no longer necessary to derive from the base class
EntityObject .

With later updates (such as Entity Framework 4.1, 4.2), additional
features have been added with NuGet packages. This allowed adding
features faster. Entity Framework 4.1 offers the Code First model
where the EDMX file to define the mappings is no longer used.
Instead, all the mapping is defined using C# code——either using
attributes or with a fluent API to define the mapping using code.

Entity Framework 4.3 added support for Migrations. With this, it is
possible to define updates to the database schemas using C# code. The
database update can be automatically applied from the application
using the database.

- Entity Framework 5——The NuGet package for Entity Framework
5 supported both .NET Framework 4.5 and .NET Framework 4.0
applications. However, many of the features of Entity Framework 5
only have been available with .NET Framework 4.5. Entity
Framework was still based on types that are installed on the system
with .NET Framework 4.5. New with this release were performance
improvements as well as supporting new SQL Server features, such
as spatial data types, and many of these features have not been
available when using it with .NET Framework 4.0 applications.

- Entity Framework 6——Entity Framework 6 solved some issues
with Entity Framework 5, which was partly a part of the framework
installed on the system and partly available via NuGet extensions.
Now the complete code of Entity Framework has moved to NuGet
packages. For not creating conflicts, a new namespace was used.
When porting apps to the new version, the namespace had to be
changed.

- Entity Framework Core (EF Core)——This version of Entity
Framework got a new name and was a complete rewrite of Entity
Framework. EF Core is available not only on Windows but also on
Linux and Mac. It supports both relational databases and NoSQL
data stores.
This book covers Entity Framework Core 2.0. This version no longer
supports the XML file mapping with CSDL, SSDL, and MSL. Only
Code First is supported now——the model that was added with Entity
Framework 4.1. Code First doesn’t mean that the database can’t exist
first. You can either create the database first or define the database
purely from code; both options are possible.

**NOTE**
The name `Code` First is somewhat misleading. With Code First,
either the code or the database can be created first. Originally
with the beta version of Code First, the name was Code Only.
Because the other model options had First in their names, the
name Code Only was changed as well.

Entity Framework Core 1.0 did not support all the features that were
offered by Entity Framework 6. Entity Framework Core 2.0 catches up
but still doesn’t support all the features of Entity Framework 6.
However, it also has some new features Entity Framework 6 doesn’t
have.

You just need to pay attention to what version of Entity Framework
you are using. There are many valid reasons to stay with Entity
Framework 6, but using ASP.NET Core on non-Windows platforms,
using Entity Framework with the Universal Windows Platform, using
Xamarin, and using nonrelational data stores all require the use of EF
Core.

This chapter introduces you to EF Core. It starts with a simple model
reading and writing information from SQL Server. Later, relations are
added, and you will be introduced to the change tracker and conflict
handling when writing to the database. Creating and modifying
database schemas using migrations is another important part of this
chapter.

**NOTE**
This chapter uses the Books database. This database is included
with the download of the code samples at www.wrox.com . Other
databases used with the samples are created from the code.

## INTRODUCING EF CORE
The first example uses a single Book type and maps this type to the
Books table in a SQL Server database. You write records to the
database and then read, update, and delete them.

With the first example, you can create the database first or let the
database be created from the application. To create the database first,
you can use the SQL Server Object Explorer that is part of Visual
Studio 2017. Select the database instance (localdb)\MSSQLLocalDB .
This database is installed with the installation of Visual Studio). Click
the Databases node in the tree view and select Add New Database. The
sample database WroxBooks has only a single table named Books .

You can create the table Books by selecting the Tables node within the
WroxBooks database and then selecting Add New Table. Using the
designer shown in Figure 26-1, or by entering the SQL DDL statement
in the T-SQL editor, you can create the table Books . The following code
snippet shows the T-SQL code for creating the table. When you click
the Update button, you can submit the changes to the database.
```sql
CREATE TABLE [dbo].[Books]
(
[BookId] INT IDENTITY(1, 1) NOT NULL,
[Title] NVARCHAR(50) NOT NULL,
[Publisher] NVARCHAR(25) NULL,
CONSTRAINT [PK_Books] PRIMARY KEY CLUSTERED ([BookId] ASC)
)
```
FIGURE 26-1
The sample applications used in this chapter are all .NET Core console
applications and make use of the following NuGet dependencies and
namespaces:

Dependencies
Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.SqlServer
Microsoft.EntityFramework.Design
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Logging.Console
Namespaces
Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.ChangeTracking
Microsoft.EntityFrameworkCore.Diagnostics
Microsoft.EntityFrameworkCore.Infrastructure
Microsoft.EntityFrameworkCore.Metadata.Builders
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Logging
System
System.Collections.Generic
System.ComponentModel.DataAnnotations
System.ComponentModel.DataAnnotations.Schema
System.Linq
System.Threading.Tasks

### Creating a Model
The sample application BookSample for accessing the Books database is
a .NET Core console app. With this application, the class Book is a
simple entity type that defines three properties. The BookId property
maps to the primary key of the table, the Title property to the Title
column, and the Publisher property to the Publisher column. With the
property, the Required attribute is applied because the mapping
column has a NOT NULL definition in the database. Lengths for the
Title and Publisher properties are applied using the StringLength
attribute. This also maps with the columns in the database. To map the
type to the Books table, the Table attribute is applied to the type (code
file Intro/Book.cs ):
```c#
Title
[Table("Books")]
public class Book
{
public int BookId { get; set; }
[Required]
[StringLength(50)]
public string Title { get; set; }
[StringLength(30)]
public string Publisher { get; set; }
}
```

### Conventions, Annotations, and Fluent API
EF Core is using three concepts to define the model: conventions,
annotations, and the fluent API. With conventions, some things
happen automatically. For example, naming a property of type int or
Guid with an Id postfix maps the property to a primary key.

Conventions can be overridden using annotations——specifying
attributes. The previous example used the Table attribute to map the
Book type to the Books table. There’s also a convention for mapping to
the table; this is using a property name of a context. Creating contexts
is shown in the next section. Conventions do not exist for every
annotation. Required and StringLength attributes have been used as
well. Annotations are more powerful than conventions; you can do
more.

Instead of using annotations, you can also use a fluent API, which
means configuration is done via code rather than using attributes.
With a fluent API, the return value of a method can be used to invoke
the next method. The fluent API for EF Core is more powerful than the
annotations are; you can do more. The fluent API is shown later in this
chapter in the section “Creating a Model.”

### Creating a Context
The association of the Book table with the database is done creating the
BooksContext class. This class derives from the base class DbContext .
The BooksContext class defines the Books property that is of type
DbSet<Book> . This type allows creating queries and adding Book
instances for storing it in the database. To define the connection
string, the OnConfiguring method of the DbContext can be overridden.
Here, the UseSqlServer extension method maps the context to a SQL
Server database (code file BooksSample/BooksContext.cs ):
```c#
public class BooksContext: DbContext
{
private const string ConnectionString =
@"server=(localdb)\MSSQLLocalDb;database=WroxBooks;" +
@"trusted_connection=true";
public DbSet<Book> Books { get; set; }
protected override void
OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
base.OnConfiguring(optionsBuilder);
optionsBuilder.UseSqlServer(ConnectionString);
}
}
```

**NOTE**
Another way to define the connection string is by using
dependency injection, which is shown later in this chapter in the
section “Using Dependency Injection.”

### Creating the Database
The model and the context classes are defined. Now it’s also possible
to create the database programmatically. First, the BooksContext object
is instantiated. The using statement makes sure that the database
connection is closed at the end of the using scope.

When you use the Database property of the DbContext , a
DatabaseFacade is returned. You can use this to create and delete
databases, and to directly send SQL statements. Invoking the method
EnsureCreatedAsync makes sure that the database is created. If the
database already exists, this method returns false. If the database does
not exist, the database is created according to the definition of the
context and the model, and true is returned (code file
Intro/Program.cs ):
```c#
private async Task CreateTheDatabaseAsync()
{
using (var context = new BooksContext())
{
bool created = await
context.Database.EnsureCreatedAsync();
string creationInfo = created ? "created" : "exists";
Console.WriteLine($"database {creationInfo}");
}
}
```
When you run the program, if you already created the database earlier,
the string database exists is written to the console. In case you didn’t
create the database earlier, the database is created, followed by the
string database created .
**NOTE**
Many of the code samples make use of the asynchronous methods
of EF Core, such as EnsureCreatedAsync and SaveChangesAsync . If
you don’t need async functionality——for example, in your console
applications or probably web applications——you can use the
synchronous variant of these methods. Although async has some
overhead, the synchronous versions of these APIs block the calling
thread. EnsureCreated and SaveChanges are the synchronous APIs
while EnsureCreatedAsync and SaveChangesAsync are the
asynchronous APIs. Read more about the asynchronous methods
in Chapter 15, “Asynchronous Programming,” and Chapter 21,
“Tasks and Parallel Programming.”


**NOTE**
Using the Async variants of the context methods allows starting
the operation in the background. However, you cannot start
multiple operations on the same context parallel. You need to
await for an operation to complete before starting the next
operation.
Deleting the Database
Deleting the database is programmatically very similar to its creation.
You just need to invoke the method EnsureDeletedAsync of the
DatabaseFacade :
private async Task DeleteDatabaseAsync()
{
Console.Write("Delete the database? ");
string input = Console.ReadLine();
if (input.ToLower() == "y")
{
using (var context = new BooksContext())
{
bool deleted = await
context.Database.EnsureDeletedAsync();
string deletionInfo = deleted ? "deleted" : "not
deleted";
Console.WriteLine($"database {deletionInfo}");
}
}
}
Just make sure you don’t delete a database that should not be deleted.
Pay attention to the connection string you use.
Writing to the Database
After the database and the Books table are created, you can fill the table
with data. The AddBookAsync method is created to add a Book object to
the database. AddBookAsync just adds the Book object to the context, it


doesn’t write it to the database. The object is written on invoking the
method SaveChangesAsync (code file Intro/Program.cs ):
private async Task AddBookAsync(string title, string
publisher)
{
using (var context = new BooksContext())
{
var book = new Book
{
Title = title,
Publisher = publisher
};
await context.Books.AddAsync(book);
int records = await context.SaveChangesAsync();
Console.WriteLine($"{records} record added");
}
Console.WriteLine();
}
For adding a list of books, you can use the AddRange method:
private async Task AddBooksAsync()
{
using (var context = new BooksContext())
{
var b1 = new Book
{
Title = "Professional C# 6 and .NET Core 1.0",
Publisher = "Wrox Press"
};
var b2 = new Book
{
Title = "Professional C# 5 and .NET 4.5.1",
Publisher = "Wrox Press"
};
var b3 = new Book
{
Title = "JavaScript for Kids",
Publisher = "Wrox Press"
};
var b4 = new Book
{
Title = "Web Design with HTML and CSS",
Publisher = "For Dummies"
};
await context.AddRangeAsync(b1, b2, b3, b4);
int records = await context.SaveChangesAsync();
Console.WriteLine($"{records} records added");


}
Console.WriteLine();
}
When you run the application and invoke these methods, you can see
the data written to the database using the SQL Server Object Explorer.
Reading from the Database
To read the data from C# code, you just need to invoke the
BooksContext and access the Books property. Accessing this property
creates a SQL statement to retrieve all books from the database (code
file Intro/Program.cs ):
private async Task ReadBooksAsync()
{
using (var context = new BooksContext())
{
List<Book> books = await context.Books.ToListAsync();
foreach (var b in books)
{
Console.WriteLine($"{b.Title} {b.Publisher}");
}
}
Console.WriteLine();
}
When you open the IntelliTrace Events window during debugging, you
can see the SQL statement that is sent to the database (this requires
Visual Studio Enterprise edition):
SELECT [b].[BookId], [b].[Publisher], [b].[Title]
FROM [Books] AS [b]
Entity Framework offers a LINQ provider. With that, you can create
LINQ queries to access the database. You can either use the method
syntax as shown here:
private async Task QueryBooksAsync()
{
using (var context = new BooksContext())
{
List<Book> wroxBooks = context.Books
.Where(b => b.Publisher == "Wrox Press")


.ToListAsync();
foreach (var b in wroxBooks)
{
Console.WriteLine($"{b.Title} {b.Publisher}");
}
}
Console.WriteLine();
}
or use the declarative LINQ query syntax:
var wroxBooks = await (from b in context.Books
where b.Publisher == "Wrox Press"
select b).ToListAsync();
With both syntax variants, this SQL statement is sent to the database:
SELECT [b].[BookId], [b].[Publisher], [b].[Title]
FROM [Books] AS [b]
WHERE [b].[Publisher] = 'Wrox Press'
**NOTE**
LINQ is discussed in detail in Chapter 12, “Language Integrated
Query.”
Updating Records
Updating records can be easily achieved just by changing objects that
have been loaded with the context, and invoking SaveChangesAsync
(code file Intro/Program.cs ):
private async Task UpdateBookAsync()
{
using (var context = new BooksContext())
{
int records = 0;
Book book = await context.Books
.Where(b => b.Title == "Professional C# 7")
.FirstOrDefaultAsync();


if (book != null)
{
book.Title = "Professional C# 7 and .NET Core 2.0";
records = await context.SaveChangesAsync();
}
Console.WriteLine($"{records} record updated");
}
Console.WriteLine();
}
Deleting Records
Finally, let’s clean up the database and delete all records. You do this
by retrieving all records and invoking the Remove or RemoveRange
method to set the state of the objects in the context to deleted.
Invoking the SaveChangesAsync method now deletes the records from
the database and invokes SQL Delete statements for every object (code
file Intro/Program.cs ):
private async Task DeleteBooksAsync()
{
using (var context = new BooksContext())
{
var books = context.Books;
context.Books.RemoveRange(books);
int records = await context.SaveChangesAsync();
Console.WriteLine($"{records} records deleted");
}
Console.WriteLine();
}
**NOTE**
An object-relational mapping tool such as EF Core is not useful
with all scenarios. Deleting all objects was not done efficiently
with the sample code. Instead of sending a DELETE statement to the
database for every record to delete, you can delete all records
using a single SQL statement. How this can be done is explained
in Chapter 25, “ADO.NET.” EF Core is not that bad in such
scenarios, as multiple statements can be combined into a batch


statement, as shown later in the chapter in the section “Batching.”
Now that you’ve seen how to add, query, update, and delete records,
this chapter steps into features behind the scenes and gets into
advanced scenarios using Entity Framework.
Logging
To see the SQL statements sent to the database, you can open the
profiler with SQL Server, open the Intellitrace Events in Visual Studio
(Debug ⇨ Windows ⇨ Intellitrace Events), which requires the
Enterprise edition of Visual Studio, or just enable logging. With
logging, you can write trace information where you like to.
EF Core internally uses a dependency injection container (using
Microsoft.Extensions.DependencyInjection ) that has the interface
ILoggerFactory registered. You can access this interface and register
your own logger provider.
The following code snippet uses BooksContext to register a new logger.
First, the IServiceProvider of the context is retrieved using the
GetInfrastructure extension method. This extension method is
defined in the namespace
Microsoft.EntityFrameworkCore.Infrastructure . Using the
IServiceProvider , services registered with the container can be
retrieved, such as the interface ILoggerFactory . This interface is used
from the EF Core infrastructure to write log information. With this
interface, you can add log providers such as the Console log provider.
This log provider is defined in the NuGet package
Microsoft.Extensions.Logging.Console . The provider defines the
AddConsole extension method to the ILoggerFactory , which makes it
easy to add it as a log provider. Here, the log provider is configured to
write informational logs (code file Intro/Program.cs ):
private void AddLogging()
{
using (var context = new BooksContext())
{
IServiceProvider provider =
context.GetInfrastructure<IServiceProvider>();


ILoggerFactory loggerFactory =
provider.GetService<ILoggerFactory>();
loggerFactory.AddConsole(LogLevel.Information);
}
}
You need to make this configuration with only one context. The
registration is done in the infrastructure of EF Core, thus as soon as
this is configured for the application, logging is done with every
context instantiated. For example, the QueryBooksAsync method
implemented earlier now shows this logging information on the
console:
info: Microsoft.EntityFrameworkCore.Database.Command[200101]
Executed DbCommand (131ms) [Parameters=[],
CommandType='Text',
CommandTimeout='30']
SELECT [b].[BookId], [b].[Publisher], [b].[Title]
FROM [Books] AS [b]
WHERE [b].[Publisher] = N'Wrox Press'
**NOTE**
Dependency injection and
is covered in detail in
Chapter 20, “Dependency Injection.” Read more information
about logging and diagnostics in Chapter 29, “Tracing, Logging,
and Analytics.”
Microsoft.Extensions.DependencyInjection
USING DEPENDENCY INJECTION
EF Core has built-in support for dependency injection, and there’s also
great support for using EF Core with a dependency injection
container. Instead of defining the connection and the use of SQL
Server with the DbContext derived class, the connection and SQL
Server selection can be injected by using a dependency injection
framework.


To see this in action, the previous sample has been modified with the
BooksSampleWithDI sample project.
The BooksContext class now looks a lot simpler in just defining the
Books property (code file UsingDependencyInjection/BooksContext.cs ):
public class BooksContext : DbContext
{
public BooksContext(DbContextOptions<BooksContext> options)
: base(options) { }
public DbSet<Book> Books { get; set; }
}
The BooksService is the new class that makes use of the BooksContext .
Here, the BooksContext is injected via constructor injection. The
methods AddBooksAsync and ReadBooks are very similar to these
methods from the previous sample, but they use the context member
of the BooksService class instead of creating a new one (code file
UsingDependencyInjection/BooksService.cs ):
public class BooksService
{
private readonly BooksContext _booksContext;
public BooksService(BooksContext context) => _booksContext
= context;
public async Task AddBooksAsync()
{
var b1 = new Book
{
Title = "Professional C# 6 and .NET Core 1.0",
Publisher = "Wrox Press"
};
var b2 = new Book
{
Title = "Professional C# 5.0 and .NET 4.5.1",
Publisher = "Wrox Press"
};
var b3 = new Book
{
Title = "JavaScript for Kids",
Publisher = "Wrox Press"
};
var b4 = new Book
{


Title = "Web Design with HTML and CSS",
Publisher = "For Dummies"
};
_booksContext.AddRange(b1, b2, b3, b4);
int records = await _booksContext.SaveChangesAsync();
Console.WriteLine($"{records} records added");
}
public async Task ReadBooksAsync()
{
List<Book> books = await
_booksContext.Books.ToListAsync();
foreach (var b in books)
{
Console.WriteLine($"{b.Title} {b.Publisher}");
}
Console.WriteLine();
}
}
The container of the dependency injection framework is initialized in
the InitializeServices method. Here, a ServiceCollection instance is
created, and the BooksService class is added to this collection with a
transient lifetime management. With this, the BooksService is
instantiated every time this service is requested. For registering Entity
Framework and SQL Server, the extension methods
AddEntityFrameworkSqlServer , and AddDbContext are available. The
AddDbContext method requires an Action delegate as parameter where
a DbContextOptionsBuilder parameter is received. With this options
parameter, the context can be configured using the UseSqlServer
extension method. This is the similar functionality to register SQL
Server with Entity Framework in the previous sample (code file
UsingDependencyInjection/Program.cs ):
private void InitializeServices()
{
const string ConnectionString =
@"server=
(localdb)\MSSQLLocalDb;database=Books;trusted_connection=true";
var services = new ServiceCollection();
services.AddTransient<BooksService>()
.AddEntityFrameworkSqlServer()


.AddDbContext<BooksContext>(options =>
options.UseSqlServer(ConnectionString));
//...
Container = services.BuildServiceProvider();
}
public ServiceProvider Container { get; private set; }
The initialization of the services as well as the use of the BooksService
is done from the Main method. The BooksService is retrieved invoking
the GetService method of the IServiceProvider (code file
UsingDependencyInjection/Program.cs ):
static async Task Main()
{
var p = new Program();
p.InitializeServices();
p.ConfigureLogging();
var service = p.Container.GetService<BooksService>();
await service.AddBooksAsync();
service.ReadBooks();
}
When you run the application, you can see that records are added and
read from the Books database.
To configure logging with this application setup, you can add the
ILoggerFactory interface with the help of the AddLogging extension
method to the DI container:
private void InitializeServices()
{
const string ConnectionString =
@"server=
(localdb)\MSSQLLocalDb;database=Books;trusted_connection=true";
var services = new ServiceCollection();
services.AddTransient<BooksService>()
.AddEntityFrameworkSqlServer()
.AddDbContext<BooksContext>(options =>
options.UseSqlServer(ConnectionString));
services.AddLogging();
Container = services.BuildServiceProvider();
}


Next, you configure logging. With the implementation of the
ConfigureLogging method, the ILoggerFactory is retrieved from the DI
container. Using this factory, the console is added to write information
logs:
private void ConfigureLogging()
{
ILoggerFactory loggerFactory =
Container.GetService<ILoggerFactory>();
loggerFactory.AddConsole(LogLevel.Information);
}
EF Core itself uses the ILoggerFactory interface by injecting the
service, and thus EF Core logging is now written to the console like the
previous sample.
CREATING A MODEL
The first examples of this chapter mapped a single table. Now, let’s get
into a more complex example with a relationship between tables. The
new database will be created programmatically, but of course you also
can create a database first and use the code to access the existing
database.
Creating a Relation
Let’s start creating a model. The sample project defines a one-to-many
relation using the MenuCard and Menu types. The MenuCard contains a list
of Menu objects. This relation is simply defined by the Menu property of
type List<Menu> (code file MenusSample/MenuCard.cs ):
public class MenuCard
{
public int MenuCardId { get; set; }
public string Title { get; set; }
public List<Menu> Menus { get; } = new List<Menu>();
public override string ToString() => Title;
}
The relation can also be accessed in the other direction; a Menu can
access the MenuCard using the MenuCard property. The MenuCardId


property is specified to define a foreign key relationship (code file
MenusSample/Menu.cs ):
public class Menu
{
public int MenuId { get; set; }
public string Text { get; set; }
public decimal Price { get; set; }
public int MenuCardId { get; set; }
public MenuCard MenuCard { get; set; }
public override string ToString() => Text;
}
The mapping to the database is done by the MenusContext class. This
class is defined similarly to the previous context type; it just contains
two properties to map the two object types: the properties Menus and
MenuCards (code file MenusSamples/MenusContext.cs ):
public class MenusContext: DbContext
{
private const string ConnectionString = @"server=
(localdb)\MSSQLLocalDb;" +
"Database=MenuCards;Trusted_Connection=True";
public DbSet<Menu> Menus { get; set; }
public DbSet<MenuCard> MenuCards { get; set; }
protected override void
OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
base.OnConfiguring(optionsBuilder);
optionsBuilder.UseSqlServer(ConnectionString);
}
}
There are some parts in the creation code that would be useful to
change. For example, the size of the Text and Title column could be
reduced in size from NVARCHAR(MAX) . In addition to that, SQL Server
defines a Money type that could be used for the Price column, and the
schema name could be changed from dbo . Entity Framework gives you
two options to make these changes from code: data annotations and
the Fluent API, which are both discussed next.
Data Annotations


One way to influence the generated database is to add data
annotations to the entity types. By default, the name of the table
comes from the property of the context. Thus, to map the Menu class,
the Menus table is used because the DbSet property mapping Menu has
the name Menus . With data annotations, the tables can be changed by
using the Table attribute. To change the schema name, the Table
attribute defines the Schema property. To specify a different length for a
string type, you can apply the MaxLength attribute (code file
MenusWithDataAnnotations/MenuCard.cs ):
[Table("MenuCards", Schema = "mc")]
public class MenuCard
{
public int MenuCardId { get; set; }
[MaxLength(120)]
public string Title { get; set; }
public List<Menu> Menus { get; } = new List<Menu>();
}
**NOTE**
Using the property name in the context to map it to the table is
different from Entity Framework. Entity Framework used a
dictionary to find plural and singular names.
With the Menu class, the Table and MaxLength attributes are applied as
well. To change the SQL type, the Column attribute can be used (code
file MenusWithDataAnnotations/Menu.cs ):
[Table("Menus", Schema = "mc")]
public class Menu
{
public int MenuId { get; set; }
[MaxLength(50)]
public string Text { get; set; }
[Column(TypeName ="Money")]
public decimal Price { get; set; }
public int MenuCardId { get; set; }
public MenuCard MenuCard { get; set; }


}
After applying the migrations and creating the database, you can see
the new names of the tables with the schema name, as well as the
changed data types on the Title , Text , and Price columns:
CREATE TABLE [mc].[MenuCards] (
[MenuCardId] INT IDENTITY (1, 1) NOT NULL,
[Title] NVARCHAR (120) NULL,
CONSTRAINT [PK_MenuCard] PRIMARY KEY CLUSTERED
([MenuCardId] ASC)
);
CREATE TABLE [mc].[Menus] (
[MenuId] INT IDENTITY (1, 1) NOT NULL,
[MenuCardId] INT NOT NULL,
[Price] MONEY NOT NULL,
[Text] NVARCHAR (50) NULL,
CONSTRAINT [PK_Menu] PRIMARY KEY CLUSTERED ([MenuId] ASC),
CONSTRAINT [FK_Menu_MenuCard_MenuCardId] FOREIGN KEY
([MenuCardId])
REFERENCES [mc].[MenuCards] ([MenuCardId]) ON DELETE
CASCADE
);
Fluent API
Another way to influence the tables created is to use the Fluent API
with the OnModelCreating method of the DbContext derived class. Using
this has the advantage that you can keep the entity types simple
without adding any attributes, and the fluent API also gives you more
options than you have with applying attributes.
The following code snippet shows the override of the OnModelCreating
method of the BooksContext class. The ModelBuilder class that is
received as parameter offers a few methods, and several extension
methods are defined. The HasDefaultSchema is an extension method
that applies a default schema to the model that is now used with all
types. The Entity method returns an EntityTypeBuilder that enables
you to customize the entity, such as mapping it to a specific table name
and defining keys and indexes:
protected override void OnModelCreating(ModelBuilder


modelBuilder)
{
base.OnModelCreating(modelBuilder);
modelBuilder.HasDefaultSchema("mc");
modelBuilder.Entity<MenuCard>()
.ToTable("MenuCards")
.HasKey(c => c.MenuCardId);
//...
modelBuilder.Entity<Menu>()
.ToTable("Menus")
.HasKey(m => m.MenuId);
//...
}
The EntityTypeBuilder defines a Property method to configure a
property. The Property method returns a PropertyBuilder that in turn
enables you to configure the property with max length values, required
settings, and SQL types and to specify whether values should be
automatically generated (such as identity columns):
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
//...
modelBuilder.Entity<MenuCard>()
.Property(c => c.MenuCardId)
.ValueGeneratedOnAdd();
modelBuilder.Entity<MenuCard>()
.Property(c => c.Title)
.HasMaxLength(50);
//...
modelBuilder.Entity<Menu>()
.Property(m => m.MenuId)
.ValueGeneratedOnAdd();
modelBuilder.Entity<Menu>()
.Property(m => m.Text)
.HasMaxLength(120);
modelBuilder.Entity<Menu>()
.Property(m => m.Price)
.HasColumnType("Money");
//...
}


To define one-to-many mappings, the EntityTypeBuilder defines
mapping methods. The method HasMany combined with WithOne
defines a mapping of many menus with one menu card. HasMany needs
to be chained with WithOne . The method HasOne needs a chain with
WithMany or WithOne . Chaining HasOne with WithMany defines a one-to-
many relationship; chaining HasOne with WithOne defines a one-to-one
relationship:
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
//...
modelBuilder.Entity<MenuCard>()
.HasMany(c => c.Menus)
.WithOne(m => m.MenuCard);
modelBuilder.Entity<Menu>()
.HasOne(m => m.MenuCard)
.WithMany(c => c.Menus)
.HasForeignKey(m => m.MenuCardId);
}
Self-Contained Type Configuration
Having a more complex DbContext , the OnModelCreating method can
become quite long. EF Core 2.0 gives a new option to define
configuration classes for every type. To create a configuration class,
the class needs to implement the interface IEntityTypeConfiguration
with the method Configure . Creating MenuCardConfiguration for the
MenuCard type, the configuration can be simplified as shown in the
following code snippet (code file
MenusSample/MenuCardConfiguration.cs ):
public class MenuCardConfiguration :
IEntityTypeConfiguration<MenuCard>
{
public void Configure(EntityTypeBuilder<MenuCard> builder)
{
builder.ToTable("MenuCards")
.HasKey(c => c.MenuCardId);
builder.Property(c => c.MenuCardId)
.ValueGeneratedOnAdd();
builder.Property(c => c.Title)


.HasMaxLength(50);
builder.HasMany(c => c.Menus)
.WithOne(m => m.MenuCard);
}
}
The configuration for the class Menu is defined in the
MenuConfiguration class. The methods used by the EntityTypeBuilder
are the same as used previously. The code is just simpler because the
entity type does not need to be selected because with
IEntityTypeConfiguration , the entity type is already specified:
public class MenuConfiguration :
IEntityTypeConfiguration<Menu>
{
public void Configure(EntityTypeBuilder<Menu> builder)
{
builder.ToTable("Menus")
.HasKey(m => m.MenuId);
builder.Property(m => m.MenuId)
.ValueGeneratedOnAdd();
builder.Property(m => m.Text)
.HasMaxLength(120);
builder.Property(m => m.Price)
.HasColumnType("Money");
builder.HasOne(m => m.MenuCard)
.WithMany(m => m.Menus)
.HasForeignKey(m => m.MenuCardId);
}
}
The OnModelCreating method of the MenusContext class can now be
simplified. To apply the configuration from the
IEntityTypeConfiguration types, the ApplyConfiguration method of
the ModelBuilder needs to be invoked (code file
MenusSample/MenusContext.cs ):
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
base.OnModelCreating(modelBuilder);


modelBuilder.HasDefaultSchema("mc");
modelBuilder.ApplyConfiguration(new
MenuCardConfiguration());
modelBuilder.ApplyConfiguration(new MenuConfiguration());
}
Scaffolding a Model from the Database
Instead of creating the database from the model, you can also create
the model from the database.
To do this, you need to add the NuGet package
Microsoft.EntityFrameworkCore.Design to the packages list of the
project and add Microsoft.EntityFrameworkCore.Tools.Dotntet within
a DotnetCliToolReference element. As the
Microsoft.EntityFrameworkCore.Design package is only needed for the
project itself and not for other projects referencing this package, the
attribute PrivateAssets can be specified (project file
ScaffoldSample/ScaffoldSample.csproj ):
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<OutputType>Exe</OutputType>
<TargetFramework>netcoreapp2.0</TargetFramework>
</PropertyGroup>
<ItemGroup>
<PackageReference Include="Microsoft.EntityFrameworkCore"
Version="2.0.0" />
<PackageReference
Include="Microsoft.EntityFrameworkCore.SqlServer"
Version="2.0.0" />
<PackageReference
Include="Microsoft.EntityFrameworkCore.Design"
Version="2.0.0" PrivateAssets="All" />
</ItemGroup>
<ItemGroup>
<DotNetCliToolReference
Include="Microsoft.EntityFrameworkCore.Tools.Dotnet"
Version="2.0.0" />
</ItemGroup>
</Project>
After the tools are installed, you can start the dotnet ef command


from the Developer Command Prompt:
> dotnet ef dbcontext scaffold
"server=(localdb)\MSSQLLocalDb;database=MenuCards;
trusted_connection=true"
"Microsoft.EntityFrameworkCore.SqlServer"
The dbcontext command enables you to list DbContext objects from the
project, as well as create DBContext objects. The command scaffold
creates DbContext -derived classes as well as model classes. dotnet ef
dbcontext scaffold needs two required arguments: the connection
string to the database and the provider that should be used. With the
statement shown earlier, the database MenuCards was accessed on the
SQL Server (localdb)\MSSQLLocalDb . The provider used was
Microsoft.EntityFrameworkCore.SqlServer . This NuGet package needs
to be added to the project.
After running this command, you can see the DbContext derived classes
as well as the model types generated. The configuration of the model
by default is done using the fluent API. However, you can change that
to using the data annotations supplying the --data-annotations
option. You can also influence the generated context class name as
well as the output directory. Just check the different available options
using the option --help .
Mapping to Fields
EF Core not only allows mapping table columns to properties, but also
to private fields. This makes it possible to create read-only properties
and use private fields that are not accessible outside of the class.
Let’s have a look at the class Book in the following code snippet. This
class contains a private field _bookId that is only accessible within the
class (and it’s used from the ToString method). Title is a read/write
property, and Publisher a read-only property. The publisher uses the
field _publisher . What’s needed by EF Core in the class is a default
constructor, but this one can be declared with the private access
modifier (code file BooksSample/Book.cs ):
public class Book
{


// parameterless constructor neeeded for EF Core
private Book() { }
public Book(string title, string publisher)
{
_title = title;
_publisher = publisher;
}
private int _bookId = 0;
public string Title { get; set; }
private string _publisher;
public string Publisher => _publisher;
public override string ToString() =>
$"id: {_bookId}, title: {Title}, publisher: {Publisher}";
}
To avoid typos, for the column names, the class ColumnNames with
strongly typed names of the columns is defined. Also, the using static
declaration accesses the const values without the class name (code file
BooksSample/BooksContext.cs ):
using static BooksSample.ColumnNames;
namespace BooksSample
{
internal class ColumnNames
{
public const string LastUpdated = nameof(LastUpdated);
public const string IsDeleted = nameof(IsDeleted);
public const string BookId = nameof(BookId);
public const string AuthorId = nameof(AuthorId);
}
//...
}
The property Publisher can now be configured to map to the
corresponding field with the HasField method. The _bookId doesn’t
have a corresponding property, thus it is configured with an overload
of the Property method where the name is assigned as string. This
maps the BookId column in the database table to the field _bookId
(code file BooksSample/BooksContext.cs ):
protected override void OnModelCreating(ModelBuilder


modelBuilder)
{
base.OnModelCreating(modelBuilder);
//...
modelBuilder.Entity<Book>().Property(b => b.Title)
.IsRequired()
.HasMaxLength(50);
modelBuilder.Entity<Book>().Property(b => b.Publisher)
.HasField("_publisher")
.IsRequired(false)
.HasMaxLength(30);
modelBuilder.Entity<Book>().Property<int>(BookId)
.HasField("_bookId")
.IsRequired();
modelBuilder.Entity<Book>()
.HasKey(BookId);
}
When you’re creating Book objects, you need to use the constructor.
The properties don’t have a set accessor. After the Book objects are
initialized, they are added to BooksContext with the AddRangeAsync
method (code file BooksSample/Program.cs ):
private async Task AddBooksAsync()
{
using (var context = new BooksContext())
{
var b1 = new Book("Professional C# 6 and .NET Core 1.0",
"Wrox Press");
var b2 = new Book("Professional C# 5 and .NET 4.5.1",
"Wrox Press");
var b3 = new Book("JavaScript for Kids", "Wrox Press");
var b4 = new Book("Web Design with HTML and CSS", "For
Dummies");
await context.Books.AddRangeAsync(b1, b2, b3, b4);
int records = await context.SaveChangesAsync();
Console.WriteLine($"{records} records added");
}
Console.WriteLine();
}


Shadow Properties
EF Core not only allows mapping database columns to private fields,
you can also define a mapping that doesn’t show up in the model at all.
You can use shadow properties that can be retrieved with the entity in
the context but are not available with the model.
Shadow properties are defined as strings. To avoid typos when using
these strings multiple times, a class defining const strings is defined
(code file BooksSample/BooksContext.cs ):
public class ColumnNames
{
public const string LastUpdated = nameof(LastUpdated);
public const string IsDeleted = nameof(IsDeleted);
public const string BookId = nameof(BookId);
}
To access the members of the class without the class name, the using
static declaration is used:
using static MappingToFields.ColumnNames;
The following code snippet defines the shadow properties IsDeleted
and LastUpdated using the strongly typed strings defined earlier:
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
base.OnModelCreating(modelBuilder);
//...
// shadow properties
modelBuilder.Entity<Book>().Property<bool>(IsDeleted);
modelBuilder.Entity<Book>().Property<DateTime>
(LastUpdated);
}
The shadow property LastUpdated is used to write the actual time
when the entity was updated last. The IsDeleted property is used to
define a state that the entity is deleted instead of deleting it.
Sometimes it can be useful not to delete the data on the request of the
user, but mark it as deleted instead. This allows making an undo to
recover the entity and offers history information.


To update the shadow property LastUpdated automatically, the method
SaveChangesAsync is overridden. In case you’re using the synchronous
SaveChanges method to write changes to the database, you need to
override this method as well. With the implementation, the actual
state of the entities is checked. If the state is Added , Modified , or
Deleted , the shadow property is updated with the current time. To
manage the shadow property IsDeleted , deleted entities are changed
to the Modified state, and the IsDeleted shadow property is set to true .
Shadow properties don’t have a property in the model that allows for
accessing it; instead you can use the CurrentValues indexer of the
EntityEntry (code file BooksSample/BooksContext.cs ):
public override Task<int> SaveChangesAsync(CancellationToken
cancellationToken
= default)
{
ChangeTracker.DetectChanges();
foreach (var item in ChangeTracker.Entries<Book>()
.Where(e => e.State == EntityState.Added ||
e.State == EntityState.Modified ||
e.State == EntityState.Deleted))
{
item.CurrentValues[LastUpdated] = DateTime.Now;
if (item.State == EntityState.Deleted)
{
item.State = EntityState.Modified;
item.CurrentValues[IsDeleted] = true;
}
}
return base.SaveChangesAsync(cancellationToken);
}
**NOTE**
The change tracker that is used with the sample code is shown in
detail later in the section “Object Tracking.”


**NOTE**
Having an IsDeleted property, it would be a good idea to not
return entities where IsDeleted is set to true when using normal
queries. You can do this with the EF Core 2.0 feature global query
filters that is discussed later in the section with this name.
To show deleted entities, the DeleteBookAsync method is defined to
delete the entity with the ID that is passed to this method. Here, the
Remove method is invoked by passing the entity object, and SaveChanges
is invoked (code file BooksSample/Program.cs ):
private async Task DeleteBookAsync(int id)
{
using (var context = new BooksContext())
{
Book b = await context.Books.FindAsync(id);
if (b == null) return;
context.Books.Remove(b);
int records = await context.SaveChangesAsync();
Console.WriteLine($"{records} books deleted");
}
Console.WriteLine();
}
Behind the scenes, the IsDeleted shadow property is set because of the
change to the SaveChangesAsync method. To verify this, you can access
the shadow property using the method EF.Property by passing the
IsDeleted string. All the Book entities with this flag are shown in the
QueryDeletedBooksAsync method:
private async Task QueryDeletedBooksAsync()
{
using (var context = new BooksContext())
{
IEnumerable<Book> deletedBooks =
await context.Books
.Where(b => EF.Property<bool>(b, IsDeleted))
.ToListAsync();
foreach (var book in deletedBooks)


{
Console.WriteLine($"deleted: {book}");
}
}
}
**NOTE**
EF is a static class in the namespace
Microsoft.EntityFrameworkCore that
offers static methods that are
useful when EF types are not available. In this section you’ve seen
the Property method that can be used to access shadow state.
Later in this chapter, the EF class is used with compiled queries
and EF.Functions .
QUERIES
Now that we’ve defined the model, let’s get into more details of
queries. This section covers
Basic queries
Evaluation on the server and on the client
Raw SQL queries
Compiled queries for better performance
Global query filters
EF.Functions
Basic Queries
You’ve already seen that accessing a context-property of DbSet returns
a list of all entities of the specified table. Let’s look at this in more
detail.
Accessing the Books property retrieves all the Book records from the
database (code file BooksSample/QuerySamples.cs ):


private async Task QueryAllBooksAsync()
{
Console.WriteLine(nameof(QueryAllBooksAsync));
using (var context = new BooksContext())
{
List<Book> books = await context.Books.ToListAsync();
foreach (var b in books)
{
Console.WriteLine(b);
}
}
Console.WriteLine();
}
With the asynchronous API it’s also possible to use an
IAsyncEnumerable that is returned from the ToAsyncEnumerable method
and use the ForEachAsync method instead of the foreach loop:
await context.Books.ToAsyncEnumerable()
.ForEachAsync(b =>
{
Console.WriteLine(b);
});
Accessing the Books property results in this SQL statement sent to the
database:
SELECT [b].[BookId], [b].[IsDeleted], [b].[LastUpdated], [b].
[Publisher],
[b].[Title]
FROM [Books] AS [b]
You can query for an object with a specific key with the Find and the
FindAsync methods. In case the record is not found, this method
returns null :
Book b = await context.Books.FindAsync(id);
if (b != null)
{
//...
This results in a SELECT SQL statement with TOP(1) and a WHERE clause:
SELECT TOP(1) [e].[BookId], [e].[IsDeleted], [e].
[LastUpdated],
[e].[Publisher], [e].[Title]


FROM [Books] AS [e]
WHERE [e].[BookId] = @__get_Item_0
Instead of using a Find method, you can also use the synchronous
Single or SingleOrDefault methods, or the asynchronous variants
SingleAsync or SingleOrDefaultAsync . The difference between Single
and SingleOrDefault is that Single throws an exception when no
records are found, whereas SingleOrDefault returns null when no
records are found. These methods also throw an exception of more
than one record is found.
The following code snippet uses the method SingleOrDefaultAsync to
ask for a book title:
Book book = await context.Books.SingleOrDefaultAsync(b =>
b.Title == title);
The generated SQL statement asks for the TOP(2) records, which
allows throwing an exception if two records are found:
SELECT TOP(2) [b].[BookId], [b].[IsDeleted], [b].
[LastUpdated],
[b].[Publisher], [b].[Title]
FROM [Books] AS [b]
WHERE [b].[Title] = @__title_0
The Where method allows for simple filtering based on a condition. You
can also use the Contains method within the Where expression. An
asynchronous variant of the Where method is not available, as the Where
method uses lazy evaluation. You can use a foreach statement to
iterate all the results from the query. However, foreach triggers the
execution of the query and blocks the thread until the result is
retrieved. Instead of using foreach with the result of the Where method,
you can use ToListAsync to immediately trigger the execution but in a
task:
List<Book> wroxBooks = await context.Books
.Where(b => b.Title.Contains(title))
.ToListAsync();
The resulting SQL statement makes use of a simple WHERE in the SQL
clause:


SELECT [b].[BookId], [b].[IsDeleted], [b].[LastUpdated], [b].
[Publisher],
[b].[Title]
FROM [Books] AS [b]
WHERE (CHARINDEX(@__title_0, [b].[Title]) > 0) OR (@__title_0
= N'')
In Chapter 12, you can read about many more LINQ methods and
LINQ clauses which you can also use with EF Core. Just bear in mind
that the implementation is different between LINQ to Objects and
LINQ to EF Core. With LINQ to EF Core, expression trees are used
that allow creating a SQL query with the complete LINQ expression at
runtime. With LINQ to objects, most of the LINQ queries are defined
in the Enumerable class. LINQ with expression trees is implemented in
the Queryable class, and many enhancements for EF Core such as the
Async variants are implemented in the
EntityFrameworkQueryableExtensions class. For more information
about the expression tree, also check Chapter 12.
Client and Server Evaluation
Not every part of a query can be converted to a SQL statement and
thus run on the server. Some parts need to run on the client. EF Core
allows for transparent client and server evaluation. If a query cannot
be resolved, it automatically runs on the client. This has a big
advantage for using different providers. For example, with one
provider the query can be completely evaluated on the server. Using a
different provider that doesn’t translate all queries, the program still
runs, but some parts are now evaluated on the client.
Let’s get into one example with a n-to-n relationship. The Book type is
related to the Author type with a relation entity. One book can be
written by multiple authors, and one author can write multiple books.
The following code snippet accesses the Book objects via the Books
property. The Where method is used for filtering, and the OrderBy
method defines the order. With the Select method, the result is
defined——including a relation to the authors using the BookAuthors
property:
var books = context.Books


.Where(b => b.Title.StartsWith("Pro"))
.OrderBy(b => b.Title)
.Select(b => new
{
b.Title,
Authors = b.BookAuthors
});
All this is translated using EF Core 2.0 to a SQL statement. The
evaluation happens completely on the server, translating Where ,
OrderBy , and Select with the relation, using SELECT , INNER JOIN , WHERE ,
and ORDER BY :
SELECT [b.BookAuthors].[BookId], [b.BookAuthors].[AuthorId]
FROM [BookAuthors] AS [b.BookAuthors]
INNER JOIN (
SELECT [b0].[BookId], [b0].[Title]
FROM [Books] AS [b0]
WHERE [b0].[Title] LIKE N'Pro' + N'%' AND (LEFT([b0].
[Title], LEN(N'Pro')) =
N'Pro')
) AS [t] ON [b.BookAuthors].[BookId] = [t].[BookId]
ORDER BY [t].[Title], [t].[BookId]
If the Select statement is modified to return a comma-separated
string containing the authors, the result is very different. This is done
in the following code snippet: a string is assigned to the Authors
property. Using the relation BookAuthors , just the FirstName and
LastName properties of the authors are selected, and string.Join joins
the list to a single string (code file BooksSample/QuerySamples.cs ):
var books = context.Books
.Where(b => b.Title.StartsWith("Pro"))
.OrderBy(b => b.Title)
.Select(b => new
{
b.Title,
Authors = string.Join(", ", b.BookAuthors.Select(a =>
$"{a.Author.FirstName} {a.Author.LastName}").ToArray())
});
EF Core 2.0 cannot translate this query to a SQL statement. Logging
information from EF Core shows this **WARNING**:
warn: Microsoft.EntityFrameworkCore.Query[200500]


The LINQ expression 'join Author a.Author in value(
Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryable`1[
BooksSample.Author]) on Property([a], "AuthorId")
equals
Property([a.Author], "AuthorId")'
could not be translated and will be evaluated locally.
Three queries are now executed. The result of these queries is joined
on the client. The application still works, but the queries are not that
efficient. Three statements are executed in SQL Server instead of one,
and as you analyze the queries you can see that all authors are
retrieved from the server before the evaluation happens on the client.
This might result in a large transfer to the client:
SELECT [b].[Title], [b].[BookId]
FROM [Books] AS [b]
WHERE [b].[Title] LIKE N'Pro' + N'%' AND (LEFT([b].[Title],
LEN(N'Pro')) =
N'Pro')
ORDER BY [b].[Title]
SELECT [b0].[BookId], [b0].[AuthorId]
FROM [BookAuthors] AS [b0]
WHERE @_outer_BookId = [b0].[BookId]
SELECT [a.Author].[AuthorId], [a.Author].[FirstName],
[a.Author].[LastName]
FROM [Authors] AS [a.Author]
It’s practical to automatically have client and server evaluation. Unlike
EF Core 1.0, the SQL Server provider for EF Core 2.0 can do more
evaluation on the server, and future versions will even support more
evaluations on the server. Using other providers can have different
results. The efficiency is not the same, but at least the program works.
To avoid evaluation on the server, you can configure the context to
throw exceptions when evaluation should be done only on the server.
You can do this by invoking the ConfigureWarnings method on the
optionsBuilder when configuring the context:
optionsBuilder.UseSqlServer(ConnectionString)
.ConfigureWarnings(warnings =>


warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
**WARNING**
Client and server evaluation is a great feature to make your
program work across different providers. However, this can lead
to a performance penalty. To define queries for best performance,
you can easily find out when evaluation happens on the client by
configuring to throw exceptions. Then you can change your
queries accordingly.
Raw SQL Queries
EF Core 2.0 also enables you to define raw SQL queries, which in turn
returns entity objects and tracks these objects. You just need to invoke
the FromSql method of the DbSet object as shown in the following code
snippet (code file BooksSample/QuerySamples.cs ):
private async Task RawSqlQuery(string publisher)
{
Console.WriteLine(nameof(RawSqlQuery));
using (var context = new BooksContext())
{
IList<Book> books = await context.Books.FromSql(
$"SELECT * FROM Books WHERE Publisher = {publisher}")
.ToListAsync();
foreach (var b in books)
{
Console.WriteLine($"{b.Title} {b.Publisher}");
}
}
Console.WriteLine();
}
The SQL query assigned to the RawSql method needs to return entity
types that are part of the model, and data for all the properties of the
model needs to be returned.


The SQL string assigned to the FromSql method might look like SQL
injection can happen as the string is defined. However, this is not the
case. FromSql requires that a FormattableString type be assigned. For
this FormattableString , EF Core extracts the parameters and creates
SQL parameters.
**NOTE**
For more information about string interpolation and the
FormattableString type, read Chapter 9, “Strings and Regular
Expressions.”
Compiled Queries
For queries that need to be done again and again, you can create a
compiled query that only needs to be executed. A compiled query can
be created using EF.CompileQuery . This method offers different generic
overloads where you can pass a different number of arguments. In the
following code snippet, one query is created that defines one string
parameter. This method needs a delegate parameter where the first
parameter is of type BooksContext , the second parameter is the string
parameter——here the publisher is used. After defining the compiled
query, you can use it passing a context and the parameter (code file
BooksSample/QuerySamples.cs ):
private void CompiledQuery()
{
Console.WriteLine(nameof(CompiledQuery));
Func<BooksContext, string, IEnumerable<Book>> query =
EF.CompileQuery<BooksContext, string, Book>((context,
publisher) =>
context.Books.Where(b => b.Publisher == publisher));
using (var context = new BooksContext())
{
IEnumerable<Book> books = query(context, "Wrox Press");
foreach (var b in books)


{
Console.WriteLine($"{b.Title} {b.Publisher}");
}
}
Console.WriteLine();
}
You can create a compiled query to a member field for having it
available later when it’s needed, and you can invoke the query passing
different contexts as needed.
Global Query Filters
Earlier in this chapter, you saw shadow state used with the IsDeleted
column. You do not need to define a WHERE clause with every query not
to return the records where IsDeleted is true; instead you can define a
global query filter when creating the mode. This is what the next code
snippet does——globally checking for IsDeleted . Because IsDeleted is
not mapped to the model and just via shadow state, the value can be
retrieved using EF.Property (code file BooksSample/BooksContext.cs ):
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
base.OnModelCreating(modelBuilder);
modelBuilder.Entity<Book>().HasQueryFilter(
b => !EF.Property<bool>(b, IsDeleted));
//...
}
With this query filter defined, the WHERE check for IsDeleted is added
to every query used with this context.
**NOTE**
Global query filters are also of practical use with multi-tenancy
requirements. You can filter all queries for a context for a specific
tenant-id. You just need to pass the tenant-id when constructing
the context. Without using dependency injection, you can pass a


tenant-id to the constructor. With dependency injection, you just
need to specify a service that is injected with the constructor
where the tenant-id can be retrieved in the query filter.
**NOTE**
Global query filters can be ignored. For example, to get all the
deleted entities, you can apply the method IgnoreQueryFilters
with LINQ expressions.
EF.Functions
EF Core allows custom extension methods that can be implemented by
providers. For this, the EF class defines the Functions property of type
DbFunctions that can be extended using extension methods. At the
time of this writing, the Like method is such an extension for
relational data providers.
The following code snippet enhances the query of the Where method by
using EF.Functions.Like and supplying an expression containing the
parameter titleSegment . The parameter titleSegment is embedded
within two % characters (code file BooksSample/QuerySample.cs ):
public static async Task UseEFCunctions(string titleSegment)
{
Console.WriteLine(nameof(UseEFCunctions));
using (var context = new BooksContext())
{
string likeExpression = $"%{titleSegment}%";
IList<Book> books = await context.Books.Where(
b => EF.Functions.Like(b.Title,
likeExpression)).ToListAsync();
foreach (var b in books)
{
Console.WriteLine($"{b.Title} {b.Publisher}");
}
}
Console.WriteLine();


}
When you run the application, the method Where that contains
EF.Functions.Like is translated to the SQL clause WHERE with LIKE :
SELECT [b].[BookId], [b].[IsDeleted], [b].[LastUpdated], [b].
[Publisher],
[b].[Title]
FROM [Books] AS [b]
WHERE ([b].[IsDeleted] = 0) AND [b].[Title] LIKE
@__likeExpression_1
RELATIONSHIPS
Relationships can be defined as one-to-one or one-to-many. For
many-to-many relationships, with EF Core 2.0 you need to specify an
intermediate class inside the relation, thus you split this relation to
one-to-many and many-to-one.
Relationships can be specified by using conventions, using
annotations, and with the fluent API. All the three variants are
discussed in the next sections.
Relationships Using Conventions
The first way to define relationships is simply by conventions. Let’s
have a look using an example with Book and Chapter types. A book can
have multiple chapters; thus, this is a one-to-many relationship. The
Book type also defines a relationship to an author. Here, the author is
represented by the User class. Later, when you define relationships
using annotations, you’ll see the reasoning for this name. Book and
author defines a one-to-one relation. (With multi-author books, the
author specified with the book is the lead author.)
The book is defined with the Book class. This class has a primary key
BookId that is created because of its name. The relationship is defined
by the Chapters property. The Chapters property is of type
List<Chapter> ; this is all that’s needed for the Book type to define the
one-to-many relationship. The relationship of the book to the author is
specified by the Author property of type User . It would also be possible
to define an AuthorId property of the same type as the key in the User


class to specify the foreign key. Without this definition, a shadow
property gets created (code file RelationUsingConventions/Book.cs ):
public class Book
{
public int BookId { get; set; }
public string Title { get; set; }
public List<Chapter> Chapters { get; } = new List<Chapter>
();
public User Author { get; set; }
}
**NOTE**
Another possible implementation of the Chapters property is to
define a read/write property of type List<Chapter> without
creating an instance beforehand. With such an implementation,
an instance would be created automatically from the EF Core
context.
The chapter is defined with the Chapter class. The relationship is
defined using the Book property. A one-to-many relationship defines a
collection on one side (the Book defines a collection of Chapter objects),
and a simple relationship on the other side (the Chapter defines a
simple property Book ). Using the Book property from a chapter, the
related book can be directly accessed. With this type, the BookId
property specifies a foreign key to the Book . As already mentioned with
the Book type, in case the BookId is not specified as a member of the
class, a shadow property is created by convention (code file
RelationUsingConventions/Chapter.cs ):
public class Chapter
{
public int ChapterId { get; set; }
public int Number { get; set; }
public string Title { get; set; }
public int BookId { get; set; }
public Book Book { get; set; }
}


The User class defines the UserId property for the primary key, the
Name property, and the AuthoredBooks property for the relationship
(code file RelationUsingConventions/User.cs ):
public class User
{
public int UserId { get; set; }
public string Name { get; set; }
public List<Book> AuthoredBooks { get; set; }
}
All that’s needed with the context is to specify properties for the Book ,
Chapter and User types using properties of type DbSet<T> (code file
RelationUsingConventions/BooksContext.cs ):
public class BooksContext : DbContext
{
private const string ConnectionString =
@"server=
(localdb)\MSSQLLocalDb;database=Books;trusted_connection=true";
protected override void
OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
base.OnConfiguring(optionsBuilder);
optionsBuilder.UseSqlServer(ConnectionString);
}
public DbSet<Book> Books { get; set; }
public DbSet<Chapter> Chapters { get; set; }
public DbSet<User> Users { get; set; }
}
**NOTE**
The downloadable sample code contains database-generation
code and code to generate sample data. Because this code is very
similar to what you’ve already seen in this chapter, it’s not
specifically covered with the samples going forward. Just consult
the downloadable code samples for more information.


Creating the database when you start the application creates the
database using the mapping as defined by convention. Figure 26-2
shows the Books , Chapters , and Users table with their relationships.
The Book class does not define a foreign key property to the User type,
but one is created that fills a shadow property: AuthorUserId .
FIGURE 26-2
Before I get into different ways of defining relationships (using
annotations and the fluent API), let’s have a look at accessing related
data with queries.
Explicit Loading Related Data
If you query for books and want to display related properties——for
example, the related chapters and the related author——you can use
explicit loading of relations.
Have a look at the following code snippet. The query requests all books
with a specified title and only needs a single record. If you try to access
the Chapters and the Author properties of the resulting book after
starting the query, the values for these properties is null. Relations are
not loaded implicitly. EF Core supports explicit loading by using Entry
methods of the context that return EntityEntry objects by passing an
entity. The EntityEntry class defines Collection and Reference
methods that allow explicit loading of relations. With a one-to-many
relationship, you can use the Collection method to specify the


collection, whereas a one-to-one relation needs the Reference method
to specify the relation. Explicit loading then happens with the Load
method (code file RelationUsingConventions/Program.cs ):
private static void ExplicitLoading()
{
Console.WriteLine(nameof(ExplicitLoading));
using (var context = new BooksContext())
{
var book = context.Books
.Where(b => b.Title.StartsWith("Professional C# 7"))
.FirstOrDefault();
if (book != null)
{
Console.WriteLine(book.Title);
context.Entry(book).Collection(b => b.Chapters).Load();
context.Entry(book).Reference(b => b.Author).Load();
Console.WriteLine(book.Author.Name);
foreach (var chapter in book.Chapters)
{
Console.WriteLine($"{chapter.Number}.
{chapter.Title}");
}
}
}
Console.WriteLine();
}
The NavigationEntry class that implements the Load method also
implements an IsLoaded property where you can check whether the
relation is already loaded. You do not need to check for a loaded
relation before invoking the Load method; in cases when the relation is
already loaded when you invoke the Load method, the query to the
database doesn’t happen a second time.
When you run the application with the query for the books, the
following SELECT statement is executed on SQL Server. This query only
accesses the Books table:
SELECT TOP(1) [b].[BookId], [b].[AuthorUserId], [b].[Title]
FROM [Books] AS [b]
WHERE [b].[Title] LIKE N'Professional C# 7' + N'%' AND
(LEFT([b].[Title],
LEN(N'Professional C# 7')) = N'Professional C# 7')


With the following Load method to retrieve the chapters for the book,
the SELECT statement retrieves the chapters based on the book ID:
SELECT [e].[ChapterId], [e].[BookId], [e].[Number], [e].
[Title]
FROM [Chapters] AS [e]
WHERE [e].[BookId] = @__get_Item_0
With the following Load method to retrieve the chapters for the book,
the SELECT statement retrieves the chapters based on the book ID:
SELECT [e].[ChapterId], [e].[BookId], [e].[Number], [e].
[Title]
FROM [Chapters] AS [e]
WHERE [e].[BookId] = @__get_Item_0
With a third query, user information is retrieved from the Users table:
SELECT [e].[UserId], [e].[Name]
FROM [Users] AS [e]
WHERE [e].[UserId] = @__get_Item_0
Instead of explicitly loading related data that results in multiple
queries sent to SQL server, EF Core also supports eager loading as
shown next.
Eager Loading Related Data
Loading of related data immediately when a query is executed can be
done by invoking the Include method and specifying the relation. The
following code snippet includes the chapters of the books and the
author for books that successfully apply the Where expression (code file
RelationUsingConventions/Program.cs ):
private static void EagerLoading()
{
Console.WriteLine(nameof(EagerLoading));
using (var context = new BooksContext())
{
var book = context.Books
.Include(b => b.Chapters)
.Include(b => b.Author)
.Where(b => b.Title.StartsWith("Professional C# 7"))
.FirstOrDefault();


if (book != null)
{
Console.WriteLine(book.Title);
foreach (var chapter in book.Chapters)
{
Console.WriteLine($"{chapter.Number}.
{chapter.Title}");
}
}
}
Console.WriteLine();
}
Using Include , just a single SQL statement is executed to access the
Books table and join the Chapters and Users table:
SELECT [b.Chapters].[ChapterId], [b.Chapters].[BookId],
[b.Chapters].[Number],
[b.Chapters].[Title]
FROM [Chapters] AS [b.Chapters]
INNER JOIN (
SELECT DISTINCT [t].*
FROM (
SELECT TOP(1) [b0].[BookId]
FROM [Books] AS [b0]
LEFT JOIN [Users] AS [b.Author0] ON [b0].[AuthorUserId] =
[b.Author0].[UserId]
WHERE [b0].[Title] LIKE N'Professional C# 7' + N'%' AND
(LEFT([b0].[Title],
LEN(N'Professional C# 7')) = N'Professional C# 7')
ORDER BY [b0].[BookId]
) AS [t]
) AS [t0] ON [b.Chapters].[BookId] = [t0].[BookId]
ORDER BY [t0].[BookId]
In case multiple levels of relationships need to be included, the
method ThenInclude can be used on the result of the Include method.
Relationships Using Annotations
Instead of using conventions, entity types can be annotated by
applying relation information. Let’s modify the previously created Book
type by adding ForeignKey attributes to the relation properties and
specify the property that represents the foreign key. Here, the Book is


not only associated with the author of the book but also the reviewer
and the project editor. These relations map to the User type. The
foreign key properties are defined of type int? to make them optional.
With mandatory relations, EF Core creates a cascading delete; when
the Book is deleted, the related author, editor, and reviewer are deleted
as well (code file RelationUsingAnnotations/Book.cs ):
public class Book
{
public int BookId { get; set; }
public string Title { get; set; }
public List<Chapter> Chapters { get; } = new List<Chapter>
();
public int? AuthorId { get; set; }
[ForeignKey(nameof(AuthorId))]
public User Author { get; set; }
public int? ReviewerId { get; set; }
[ForeignKey(nameof(ReviewerId))]
public User Reviewer { get; set; }
public int? ProjectEditorId { get; set; }
[ForeignKey(nameof(ProjectEditorId))]
public User ProjectEditor { get; set; }
}
The User class now has multiple associations with the Book type. The
WrittenBooks property lists all books for the user where the user is
added as author. Similarly, the ReviewedBooks and EditedBooks
properties are related with the Book type just on the Reviewer and the
ProjectEditor properties. The properties need to be annotated with
the InverseProperty attribute if more than one relation between the
same types exists. With this attribute, the related property on the
other side of the relation is specified (code file
RelationUsingAnnotations/User.cs ):
public class User
{
public int UserId { get; set; }
public string Name { get; set; }
[InverseProperty("Author")]
public List<Book> WrittenBooks { get; set; }
[InverseProperty("Reviewer")]
public List<Book> ReviewedBooks { get; set; }
[InverseProperty("ProjectEditor")]


public List<Book> EditedBooks { get; set; }
}
Figure 26-3 shows the relations of the generated tables in SQL Server.
The Books table is associated with the Chapters table as in the previous
sample. Now, the Users table has three associations with the Books
table.
FIGURE 26-3
Relationships Using Fluent API
The most powerful way to specify relations is by using the fluent API.
Using the fluent API, one-to-one relationships are defined with the
methods HasOne and WithOne , whereas one-to-many relationships are
defined by the methods HasOne and WithMany , and many-to-one
relationships are defined by HasMany and WithOne .
With the following code sample, the model types do not include any


annotations on the database schema. The Book class is a simple POCO
type that defines properties for a book information including relation
properties (code file RelationUsingFluentAPI/Book.cs ):
public class Book
{
public int BookId { get; set; }
public string Title { get; set; }
public List<Chapter> Chapters { get; } = new List<Chapter>
();
public User Author { get; set; }
public User Reviewer { get; set; }
public User Editor { get; set; }
}
The User type is similarly defined. Besides having a Name property, the
User type defines three different relationships to the Book type (code
file RelationUsingFluentAPI/User.cs ):
public class User
{
public int UserId { get; set; }
public string Name { get; set; }
public List<Book> WrittenBooks { get; set; }
public List<Book> ReviewedBooks { get; set; }
public List<Book> EditedBooks { get; set; }
}
The Chapter class has a relation to the Book class. However, the Chapter
class is different from the Book class because the Chapter class also
defines a property to associate a foreign key: BookId (code file
RelationUsingFluentAPI/Chapter.cs ):
public class Chapter
{
public int ChapterId { get; set; }
public int Number { get; set; }
public string Title { get; set; }
public int BookId { get; set; }
public Book Book { get; set; }
}
The mapping between the model types is now defined in the
OnModelCreating method of the BooksContext . The Book class is


associated with multiple Chapter objects; this is defined using HasMany
and WithOne . The Chapter class is associated with one Book object; this
is defined using HasOne and WithMany . Because there’s also a foreign
key property in the Chapter class, the method HasForeignKey is used to
specify this key (code file RelationUsingFluentAPI/BooksContext.cs ):
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
modelBuilder.Entity<Book>()
.HasMany(b => b.Chapters)
.WithOne(c => c.Book);
modelBuilder.Entity<Book>()
.HasOne(b => b.Author)
.WithMany(a => a.WrittenBooks);
modelBuilder.Entity<Book>()
.HasOne(b => b.Reviewer)
.WithMany(r => r.ReviewedBooks);
modelBuilder.Entity<Book>()
.HasOne(b => b.Editor)
.WithMany(e => e.EditedBooks);
modelBuilder.Entity<Chapter>()
.HasOne(c => c.Book)
.WithMany(b => b.Chapters)
.HasForeignKey(c => c.BookId);
modelBuilder.Entity<User>()
.HasMany(a => a.WrittenBooks)
.WithOne(b => b.Author);
modelBuilder.Entity<User>()
.HasMany(r => r.ReviewedBooks)
.WithOne(b => b.Reviewer);
modelBuilder.Entity<User>()
.HasMany(e => e.EditedBooks)
.WithOne(b => b.Editor);
}
Table per Hierarchy with Conventions
EF Core also supports the relationship type of table per hierarchy
(TPH). With this relationship, multiple model classes that form a
hierarchy are used to map to a single table. This relationship can be
specified by using conventions and by using the fluent API.


Let’s start using conventions and the types Payment , CashPayment , and
CreditcardPayment that form a hierarchy as shown in Figure 26-4.
Payment is a base class; CashPayment and CreditcardPayment derive from
it.
FIGURE 26-4
With the implementation, the Payment class defines the primary key
with the PaymentId property, a required Name , and an Amount property.
The Amount property maps to a database column type Money (code file
TPHWithConventions/Payment.cs ):
public class Payment
{
public int PaymentId { get; set; }
[Required]
public string Name { get; set; }
[Column(TypeName = "Money")]
public decimal Amount { get; set; }
}
The class CreditcardPayment derives from Payment and adds a
CreditcardNumber property (code file
TPHWithConventions/CreditcardPayment.cs ):
public class CreditcardPayment : Payment
{
public string CreditcardNumber { get; set; }
}
Finally, the CashPayment class derives from Payment but doesn’t declare
any additional members (code file
TPHWithConventions/CashPayment.cs ):


public class CashPayment : Payment
{
}
The EF Core context class, the BankContext , defines DbSet properties
for every class in the hierarchy (code file
TPHWithConventions/BankContext.cs ):
public class BankContext : DbContext
{
private const string ConnectionString = @"server=
(localdb)\MSSQLLocalDb;" +
"Database=LocalBank;Trusted_Connection=True";
protected override void
OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
base.OnConfiguring(optionsBuilder);
optionsBuilder.UseSqlServer(ConnectionString);
}
public DbSet<Payment> Payments { get; set; }
public DbSet<CreditcardPayment> CreditcardPayments { get;
set; }
public DbSet<CashPayment> CashPayments { get; set; }
}
The sample data created defines two CashPayment and one
CreditcardPayment payments (code file
TPHWithConventions/Program.cs ):
private static void AddSampleData()
{
using (var context = new BankContext())
{
context.CashPayments.Add(
new CashPayment { Name = "Donald", Amount = 0.5M });
context.CashPayments.Add(
new CashPayment { Name = "Scrooge", Amount = 20000M });
context.CreditcardPayments.Add(
new CreditcardPayment
{
Name = "Gus Goose",
Amount = 300M,
CreditcardNumber = "987654321"


});
context.SaveChanges();
}
}
When you run the application to create the database, just a single table
——Payments——gets created (as shown in Figure 26-5). This table defines
a Discriminator column that maps a record from the table to the
corresponding model type.
FIGURE 26-5
To query only specific types from the hierarchy, you can use the OfType
extension method. In the following code snippet, you can see a query
to return only payments of type CreditcardPayment (code file
TPHWithConventions/Program.cs ):
private static void QuerySample()
{
using (var context = new BankContext())
{
var creditcardPayments =
context.Payments.OfType<CreditcardPayment>();
foreach (var payment in creditcardPayments)
{
Console.WriteLine($"{payment.Name}, {payment.Amount}");
}
}
}
Using OfType , EF Core creates a query with a WHERE clause to
distinguish records only with a value of CreditcardPayment :
SELECT [p].[PaymentId], [p].[Amount], [p].[Discriminator],
[p].[Name],
[p].[CreditcardNumber]


FROM [Payments] AS [p]
WHERE [p].[Discriminator] = N'CreditcardPayment'
Of course, with this scenario it also would be possible to invoke the
context property CreditcardPayments , which results in the same query.
Table per Hierarchy with Fluent API
Using the fluent API, you have more control to define the hierarchy.
With this, the Payment class has been stripped off the annotations, and
it’s now an abstract type (code file TPHWithFluentAPI/Payment.cs ):
public abstract class Payment
{
public int PaymentId { get; set; }
public string Name { get; set; }
public decimal Amount { get; set; }
}
The CreditcardPayment and Payment classes look the same as in the
previous sample, so they aren’t repeated here. The context is different.
The new name of the discriminator is Type . This just should be a
column in the Payments table, but it should not show up in the Payment
type. The strings Cash and Creditcard should be used to differentiate
the model types. For all the strings, the ColumnNames and ColumnValues
classes are defined (code file TPHWithFluentAPI/BankContext.cs ):
public static class ColumnNames
{
public const string Type = nameof(Type);
}
public static class ColumnValues
{
public const string Cash = nameof(Cash);
public const string Creditcard = nameof(Creditcard);
}
This time the context defines just a single property Payments for all the
different Payment types. Of course, it would be possible to have
specialized properties as well, but in the previous sample this was a
necessity. The required schema information for the Name property as
well as the Money type for the Amount property is now specified in the


method OnModelCreating instead of using annotations. The TPH
hierarchy is specified with the HasDiscriminator method. The name of
the discriminator is Type , which is also specified as a shadow property.
The differentiation for the derived types is specified with the HasValue
method. HasValue is a method of the DiscriminatorBuilder that is
returned from the HasDiscriminator method.
public class BankContext : DbContext
{
//...
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
modelBuilder.Entity<Payment>().Property(p =>
p.Name).IsRequired();
modelBuilder.Entity<Payment>().Property(p => p.Amount)
.HasColumnType("Money");
// shadow property for the discriminator
modelBuilder.Entity<Payment>().Property<string>
(ColumnNames.Type);
modelBuilder.Entity<Payment>()
.HasDiscriminator<string>(ColumnNames.Type)
.HasValue<CashPayment>(ColumnValues.Cash)
.HasValue<CreditcardPayment>(ColumnValues.Creditcard);
}
public DbSet<Payment> Payments { get; set; }
}
The database created looks similar like before, just instead of the
Discriminator column the table Payments now defines the Type column
——as specified with the creation of the model. The new query asking for
credit card numbers filters the Type column:
SELECT [p].[PaymentId], [p].[Amount], [p].[Name], [p].[Type],
[p].[CreditcardNumber]
FROM [Payments] AS [p]
WHERE [p].[Type] = N'Creditcard'
Table Splitting
Table splitting is another new feature of EF Core 2.0. With table
splitting, a database table can be split into multiple entity types. Using


table splitting, each class that belongs to the same table needs a one-
to-one relationship and defines its own primary key. However,
because they share the same table, also the same primary key is
shared.
Let’s get into an example with the Menu class that represents
information about a lunch menu, and MenuDetails contains
information for the kitchen. The Menu class defines some properties for
the menu including the Details property. The Details property maps
the relation to the MenuDetails class (code file
TableSplitting/Menu.cs ):
public class Menu
{
public int MenuId { get; set; }
public string Title { get; set; }
public string Subtitle { get; set; }
public decimal Price { get; set; }
public MenuDetails Details { get; set; }
}
The MenuDetails class looks like it would map to its own table——with a
primary key——and map to the Menu class with the Menu property (code
file TableSplitting/MenuDetails.cs ):
public class MenuDetails
{
public int MenuDetailsId { get; set; }
public string KitchenInfo { get; set; }
public int MenusSold { get; set; }
public Menu Menu { get; set; }
}
Within the context, Menus and MenuDetails are two DbSet properties. In
the OnModelCreating method, the Menu class is configured to a one-to-
one relationship with MenuDetails using HasOne and WithOne . These
APIs already have been discussed in the section “Relationships Using
Fluent API.” Now you should put your attention to the invocation of
the ToTable methods. Without these code lines, by default, the classes
Menu and MenuDetails would map to two different tables. Here, the
argument passed to the ToTable methods specify the same table name.
Both Menu and MenuDetails map to the same table Menus . This makes


the difference for table splitting (code file
TableSplitting/MenusContext.cs ):
public static class SchemaNames
{
public const string Menus = nameof(Menus);
}
public class MenusContext : DbContext
{
//...
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
modelBuilder.Entity<Menu>()
.HasOne<MenuDetails>(m => m.Details)
.WithOne(d => d.Menu)
.HasForeignKey<MenuDetails>(d => d.MenuDetailsId);
modelBuilder.Entity<Menu>().ToTable(SchemaNames.Menus);
modelBuilder.Entity<MenuDetails>
().ToTable(SchemaNames.Menus);
}
public DbSet<Menu> Menus { get; set; }
public DbSet<MenuDetails> MenuDetails { get; set; }
}
When you verify how the table was generated in the database, you can
see with the following SQL statement that the Menus table includes the
columns for both the Menu and MenuDetails classes, and only the
primary key from the Menu class:
CREATE TABLE [dbo].[Menus](
[MenuId] [int] IDENTITY(1,1) NOT NULL,
[Price] [decimal](18, 2) NOT NULL,
[Subtitle] [nvarchar](max) NULL,
[Title] [nvarchar](max) NULL,
[KitchenInfo] [nvarchar](max) NULL,
[MenusSold] [int] NOT NULL,
CONSTRAINT [PK_Menus] PRIMARY KEY CLUSTERED
(
[MenuId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF,
IGNORE_DUP_KEY = OFF,
ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]


GO
**NOTE**
Entity splitting is the reverse of table splitting where an entity is
split into multiple tables. This feature is not yet available with EF
Core 2.0, but it’s planned with a later version of EF Core.
Owned Entities
A different way to split a table into multiple entity types is with the
feature known as owned entities. The owned entities don’t need a
primary key; they simply can be types owned within a normal entity.
Entity classes from owned entities can map to a single table——using the
table splitting feature——but also to different tables. When different
tables are used, they share the same primary key.
Let’s get into an example that shows both scenarios: using owned
entities with a single table and mapping it to another table.
The following code snippet shows the main entity type, Person . This is
the owner of owned entities with the primary key PersonId . This type
contains two addresses: a PrivateAddress and a CompanyAddress (code
file OwnedEntities/Person.cs ):
public class Person
{
public int PersonId { get; set; }
public string Name { get; set; }
public Address PrivateAddress { get; set; }
public Address CompanyAddress { get; set; }
}
The Address is an owned entity——a type without its own primary key.
This type has two string properties, and a relation named Location of
type Location . Location is another owned entity (code file
OwnedEntities/Address.cs ):
public class Address


{
public string LineOne { get; set; }
public string LineTwo { get; set; }
public Location Location { get; set; }
}
just contains Country and City properties, and as an owned
entity, it also doesn’t define a key (code file
OwnedEntities/Location.cs ):
Location
public class Location
{
public string Country { get; set; }
public string City { get; set; }
}
The most interesting part now comes with the context, where owned
entities are defined in the OnModelCreating method. Customizing the
model for the Person class, the first invocation of OwnsOne specifies that
the Person entity owns the entity referenced from the CompanyAddress
property, which is an Address type. The second invocation to OwnsOne
now invokes OwnsOne with the return type of the first OwnsOne
invocation, a ReferenceOwnershipBuilder . This way, the Address is
defined to own a Location . With the second invocation a different
overload of OwnsOne is used that allows some customization. With this
customization shown, the column names for the City and Country
properties are specified to be different from the default names. The
result of the CompanyAddress customization is having columns for
CompanyAddress and Location all contained within the People table with
customized column names for the City and Country properties. The
customization using the next OwnsOne invocation defines the ownership
for the PrivateAddress property. This time, the Address type is mapped
to a different table: to the table named Addr . This table also contains
the columns from the Location class with default column names (code
file OwnedEntities/OwnedEntitiesContext.cs ):
public class OwnedEntitiesContext : DbContext
{
//...
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{


modelBuilder.Entity<Person>()
.OwnsOne(p => p.CompanyAddress)
.OwnsOne<Location>(a => a.Location, builder =>
{
builder.Property(p =>
p.City).HasColumnName("BusinessCity");
builder.Property(p =>
p.Country).HasColumnName("BusinessCountry");
});
modelBuilder.Entity<Person>()
.OwnsOne(p => p.PrivateAddress)
.ToTable("Addr")
.OwnsOne(a => a.Location);
}
public DbSet<Person> People { get; set; }
}
When you run the sample application, it creates the database with two
tables. The first table is the People table as shown here. This table has
all the columns from the Person class, and the Address and Location
classes as mapped from the CompanyAddress property. LineOne and
LineTwo have the default naming where the property names are
concatenated, and underscores are used between the hierarchical
property names:
CREATE TABLE [dbo].[People](
[PersonId] [int] IDENTITY(1,1) NOT NULL,
[Name] [nvarchar](max) NULL,
[CompanyAddress_LineOne] [nvarchar](max) NULL,
[CompanyAddress_LineTwo] [nvarchar](max) NULL,
[BusinessCity] [nvarchar](max) NULL,
[BusinessCountry] [nvarchar](max) NULL,
CONSTRAINT [PK_People] PRIMARY KEY CLUSTERED
(
[PersonId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF,
IGNORE_DUP_KEY = OFF,
ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
The second table created ( Addr ) is created because of the ToTable
mapping on the PrivateAddress property. The columns have default
naming because nothing else was defined. The key for this table is the


same as the People table ( PersonId ):
CREATE TABLE [dbo].[Addr](
[PersonId] [int] NOT NULL,
[LineOne] [nvarchar](max) NULL,
[LineTwo] [nvarchar](max) NULL,
[Location_City] [nvarchar](max) NULL,
[Location_Country] [nvarchar](max) NULL,
CONSTRAINT [PK_Addr] PRIMARY KEY CLUSTERED
(
[PersonId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF,
IGNORE_DUP_KEY = OFF,
ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SAVING DATA
After creating the database with models and relations, you can write to
it. The section “Introducing EF Core” showed you how to add, update,
and delete records, but now let’s get into more details about how this
can be influenced and can include relations.
Adding Objects with Relations
The following code snippet writes a relationship, a MenuCard containing
Menu objects. Here, the MenuCard and Menu objects are instantiated.
The bidirectional associations are assigned. With the Menu, the
MenuCard property is assigned to the MenuCard , and with the MenuCard ,
the Menus property is filled with Menu objects. The MenuCard instance is
added to the context invoking the Add method of the MenuCards
property. When you add an object to the context, by default all objects
are added to the tree with the state added. Not only the MenuCard but
also the Menu objects are saved. Invoking SaveChanged on the context
now creates four records (code file MenusSample/Program.cs ):
private static void AddRecords()
{
//...
using (var context = new MenusContext())
{


var soupCard = new MenuCard();
Menu[] soups =
{
new Menu
{
Text = "Consommé Célestine (with shredded pancake)",
Price = 4.8m,
MenuCard = soupCard
},
new Menu
{
Text = "Baked Potato Soup",
Price = 4.8m,
MenuCard = soupCard
},
new Menu
{
Text = "Cheddar Broccoli Soup",
Price = 4.8m,
MenuCard = soupCard
},
};
soupCard.Title = "Soups";
soupCard.Menus.AddRange(soups);
context.MenuCards.Add(soupCard);
ShowState(context);
int records = context.SaveChanges();
Console.WriteLine($"{records} added");
//...
}
}
The method ShowState that is invoked after adding the four objects to
the context shows the state of all objects that are associated with the
context. The DbContext class has a ChangeTracker associated that can
be accessed using the ChangeTracker property. The Entries method of
the ChangeTracker returns all the objects the change tracker knows
about. With the foreach loop, every object including its state is written
to the console (code file MenusSample/Program.cs ):
public static void ShowState(MenusContext context)
{
foreach (EntityEntry entry in
context.ChangeTracker.Entries())
{
Console.WriteLine($"type: {entry.Entity.GetType().Name},


" +
$"state: {entry.State}, {entry.Entity}");
}
Console.WriteLine();
}
Run the application to see the Added state with these four objects:
type: MenuCard, state: Added, Soups
type: Menu, state: Added, Consommé Célestine (with shredded
pancake)
type: Menu, state: Added, Baked Potato Soup
type: Menu, state: Added, Cheddar Broccoli Soup
Because of this state, the SaveChanges method creates SQL Insert
statements to write every object to the database.
Object Tracking
You’ve seen the context knows about added objects. However, the
context also needs to know about changes. To know about changes,
every object retrieved needs its state in the context. For seeing this in
action let’s create two different queries that return the same object.
The following code snippet defines two different queries where each
query returns the same object with the menus as they are stored in the
database. Indeed, only one object gets materialized, as with the second
query result it is detected that the record returned has the same
primary key value as an object already referenced from the context.
Verifying whether the references of the variables m1 and m2 are the
same results in returning the same object (code file
MenusSample/Program.cs ):
private static void ObjectTracking()
{
using (var context = new MenusContext())
{
var m1 = (from m in context.Menus
where m.Text.StartsWith("Con")
select m).FirstOrDefault();
var m2 = (from m in context.Menus
where m.Text.Contains("(")
select m).FirstOrDefault();
if (object.ReferenceEquals(m1, m2))


{
Console.WriteLine("the same object");
}
else
{
Console.WriteLine("not the same");
}
ShowState(context);
}
}
The first LINQ query results in a SQL SELECT statement with a LIKE
comparison to compare for the string to start with the value Con :
SELECT TOP(1) [m].[MenuId], [m].[MenuCardId], [m].[Price],
[m].[Text]
FROM [mc].[Menus] AS [m]
WHERE [m].[Text] LIKE 'Con' + '%'
With the second LINQ query, the database needs to be consulted as
well. Here, a LIKE comparison is done to compare for a ( in the middle
of the text:
SELECT TOP(1) [m].[MenuId], [m].[MenuCardId], [m].[Price],
[m].[Text]
FROM [mc].[Menus] AS [m]
WHERE [m].[Text] LIKE ('%' + '(') + '%'
When you run the application, the same object is written to the
console, and only one object is kept with the ChangeTracker . The state
is Unchanged :
the same object
type: Menu, state: Unchanged, Consommé Célestine (with
shredded pancake)
To not track the objects running queries from the database, you can
invoke the AsNoTracking method with the DbSet :
var m1 = (from m in context.Menus.AsNoTracking()
where m.Text.StartsWith("Con")
select m).FirstOrDefault();
You can also configure the default tracking behavior of the
ChangeTracker to QueryTrackingBehavior.NoTracking :


using (var context = new MenusContext())
{
context.ChangeTracker.QueryTrackingBehavior =
QueryTrackingBehavior.NoTracking;
//...
}
For a more global configuration, the tracking behavior also can be
configured with the SQL Server configuration:
protected override void OnConfiguring(DbContextOptionsBuilder
optionsBuilder)
{
base.OnConfiguring(optionsBuilder);
optionsBuilder.UseSqlServer(ConnectionString)
.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
}
With such a configuration, two queries are made to the database, two
objects are materialized, and the state information is empty.
**NOTE**
Using the NoTracking configuration is useful when the context is
used to only read records, but changes are not made. This reduces
the overhead of the context as state information is not kept.
Updating Objects
As objects are tracked, they can be updated easily, as shown in the
following code snippet. First, a Menu object is retrieved. With this
tracked object, the price is modified before the change is written to the
database. In between all changes, state information is written to the
console (code file MenusSample/Program.cs ):
private static void UpdateRecords()
{
using (var context = new MenusContext())
{


Menu menu = context.Menus
.Skip(1)
.FirstOrDefault();
ShowState(context);
menu.Price += 0.2m;
ShowState(context);
int records = context.SaveChanges();
Console.WriteLine($"{records} updated");
ShowState(context);
}
}
When you run the application, you can see that the state of the object
is Unchanged after loading the record, Modified after the property value
is changed, and Unchanged after saving is completed:
type: Menu, state: Unchanged, Baked Potato Soup
type: Menu, state: Modified, Baked Potato Soup
1 updated
type: Menu, state: Unchanged, Baked Potato Soup
When you access the entries from the change tracker, by default
changes are automatically detected. You configure this by setting the
AutoDetectChangesEnabled property of the ChangeTracker . For checking
manually to see whether changes have been done, you invoke the
method DetectChanges . With the invocation of SaveChangesAsync , the
state is changed back to Unchanged . You can do this manually by
invoking the method AcceptAllChanges .
Updating Untracked Objects
DB contexts are usually very short-lived. Using EF Core with ASP.NET
Core MVC, with one HTTP request one object context is created to
retrieve objects. When you receive an update from the client, the
object must again be created on the server. This object is not
associated with the object context. To update it in the database, the
object needs to be associated with the DB context, and the state
changed to create an INSERT , UPDATE , or DELETE statement.
Such a scenario is simulated with the next code snippet. The local
function GetMenu method returns a Menu object that is disconnected
from the context; the context is disposed at the end of the local


function. GetMenu is invoked by the method ChangeUntracked . This
method changes the Menu object that is not associated with any
context. After the change, the Menu object is passed to the method
UpdateUntracked to save it in the database (code file
MenusSample/Program.cs ):
private static void ChangeUntracked()
{
Menu GetMenu()
{
using (var context = new MenusContext())
{
Menu menu = context.Menus
.Skip(2)
.FirstOrDefault();
return menu;
}
}
Menu m = GetMenu();
m.Price += 0.7m;
UpdateUntracked(m);
}
The method UpdateUntracked receives the updated object and needs to
attach it with the context. One way to attach an object with the context
is by invoking the Attach method of the DbSet , and set the state as
needed. The Update method does both with one call: attaching the
object and setting the state to Modified (code file
MenusSample/Program.cs ):
private static void UpdateUntracked(Menu m)
{
using (var context = new MenusContext())
{
ShowState(context);
// EntityEntry<Menu> entry = context.Menus.Attach(m);
// entry.State = EntityState.Modified;
context.Menus.Update(m);
ShowState(context);
context.SaveChanges();
}
}
When you run the application with the ChangeUntracked method, you


can see that the state is modified. The object was untracked at first,
but because the state was explicitly updated, you can see the Modified
state:
type: Menu, state: Modified, Cheddar Broccoli Soup
Batching
An object mapping tool is not geared to support all scenarios. For
example, if the ZIP Code of a city changed to a new code, and you want
to update all customers with the old ZIP Code to the new one, it would
be best to invoke a single SQL UPDATE statement to update all these
records. Using EF Core, update statements are generated for every
customer.
However, EF Core is not that bad for sending a bunch of separate SQL
statements with a single call to SaveChanges . EF Core supports
batching. SaveChanges sends one command to SQL Server where
multiple inserts or updates just happen with one statement. You can
control the batch size——for example, deactivate batching by invoking
MaxBatchSize with a value of 1 when configuring SQL Server:
protected override void OnConfiguring(DbContextOptionsBuilder
optionsBuilder)
{
base.OnConfiguring(optionsBuilder);
optionsBuilder.UseSqlServer(ConnectionString,
options => options.MaxBatchSize(1));
}
The following code snippet creates hundred menu objects, and adds
these as added objects to the context, to write it to the database with
the SaveChanges method (code file MenusSample/Program.cs ):
private static void AddHundredRecords()
{
Console.WriteLine(nameof(AddHundredRecords));
using (var context = new MenusContext())
{
var card = context.MenuCards.FirstOrDefault();
if (card != null)
{
var menus = Enumerable.Range(1, 100).Select(x => new


Menu
{
MenuCard = card,
Text = $"menu {x}",
Price = 9.9m
});
context.Menus.AddRange(menus);
Stopwatch stopwatch = Stopwatch.StartNew();
int records = context.SaveChanges();
stopwatch.Stop();
Console.WriteLine($"{records} records added after " +
$"{stopwatch.EllapsedMilliseconds} milliseconds");
}
}
Console.WriteLine();
}
Running the application with batching enabled, the EF Core provider
creates a TABLE MERGE statement where 100 new menu records are
written with one statement. Changing the batch size to 1, 100 INSERT
statements are sent to the database. On my system the time difference
is 56 milliseconds with batching compared to 105 milliseconds without
batching——when the database is running on the same system. With a
database on a different system, the difference will be larger.
CONFLICT HANDLING
What if multiple users change the same record and then save the
state? Who will win with the changes?
If multiple users accessing the same database work on different
records, there’s no conflict. All users can save their data without
interfering with data edited by other users. If multiple users work on
the same record, though, you need to give some thought to conflict
resolution. You have different ways to deal with this. The easiest one is
that the last one wins. The user saving the data last overwrites changes
from the user that did the changes previously.
EF Core also offers a way for letting the first one win. With this option,
when saving a record, a verification is needed if the data originally
read is still in the database. If this is the case, saving data can continue
as no changes occurred between reading and writing. However, if the


data changed, a conflict resolution needs to be done.
Let’s get into these different options.
The Last One Wins
The default scenario is that the last one saving changes wins. To see
multiple accesses to the database, the BooksSample application is
extended.
For an easy simulation of two users, the method ConflictHandling
invokes the method PrepareUpdate two times, makes different changes
to two Book objects within two contexts that reference the same record,
and invokes the Update method two times. Last, the book ID is passed
to the CheckUpdate method, which shows the actual state of the book
from the database (code file BooksSample/Program.cs ):
public static void ConflictHandling()
{
// user 1
var tuple1 = await PrepareUpdate();
tuple1.book.Title = "updated from user 1";
// user 2
var tuple2 = await PrepareUpdate();
tuple2.book.Title = "updated from user 2";
// user 1
Update(tuple1.context, tuple1.book, "user 1");
// user 2
UpdateAsync(tuple2.context, tuple2.book, "user 2");
tuple1.context.Dispose();
tuple2.context.Dispose();
CheckUpdate(tuple1.book.BookId);
}
The PrepareUpdate method opens a BookContext and returns both the
context and the book within a tuple. Remember, this method is
invoked two times, and different Book objects associated with different
context objects are returned (code file
ConflictHandlingSample/Program.cs ):


private static (BooksContext context, Book book)
PrepareUpdate()
{
var context = new BooksContext();
Book book = await context.Books
.Where(b => b.Title == BookTitle)
.FirstOrDefault();
return (context, book);
}
**NOTE**
Tuples are explained in Chapter 13, “Functional Programming
with C#.”
The Update method receives the opened BooksContext with the updated
Book object to save the book to the database. Remember, this method
is invoked two times as well (code file BooksSample/Program.cs ):
private static void Update(BooksContext context, Book book,
string user)
{
int records = context.SaveChanges();
Console.WriteLine($"{user}: {records} record updated from
{user}");
}
The CheckUpdate method writes the book with the specified id to the
console (code file BooksSample/Program.cs ):
private static void CheckUpdate(int id)
{
using (var context = new BooksContext())
{
Book book = context.Books.Find(id);
Console.WriteLine($"updated: {book.Title}");
}
}
What happens when you run the application? You see the first update
is successful, and so is the second update. When updating a record, it
is not verified whether any changes happened after reading the record,


which is the case with this sample application. The second update just
overwrites the data from the first update, as you can see with the
application output:
user 1: 1 record updated from user 1
user 2: 1 record updated from user 2
this is the updated state: updated from user 2
The First One Wins
In case you need a different behavior, such as the first user’s changes
being saved to the record, you need to do some changes. The sample
project ConflictHandlingSample uses the Book and BookContext objects
like before, but it deals with the first-one-wins scenario.
For conflict resolution, you need to specify the properties that should
be verified if any change happened between reading and updating with
a concurrency token. Based on the property you specify, the SQL
UPDATE statement is modified to verify not only for the primary key, but
also all properties that are marked with the concurrency token. Adding
many concurrency tokens to the entity type creates a huge WHERE clause
with the UPDATE statement, which is not very efficient. Instead you can
add a property that is updated from SQL Server with every UPDATE
statement——and this is what’s done with the Book class. The property
TimeStamp is defined as timeStamp in SQL Server (code file
ConflictHandlingSample/Book.cs ):
public class Book
{
public int BookId { get; set; }
public string Title { get; set; }
public string Publisher { get; set; }
public byte[] TimeStamp { get; set; }
}
To define the TimeStamp property as a timestamp type in SQL Server,
you use the Fluent API. The SQL data type is defined using the
HasColumnType method. The method ValueGeneratedOnAddOrUpdate
informs the context that with every SQL INSERT or UPDATE statement
the TimeStamp property can change, and it needs to be set with the
context after these operations. The IsConcurrencyToken method marks


this property as required to check whether it didn’t change after
reading it (code file ConflictHandlingSample/BooksContext.cs ):
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
base.OnModelCreating(modelBuilder);
var book = modelBuilder.Entity<Book>();
book.HasKey(p => p.BookId);
book.Property(p => p.Title).HasMaxLength(120).IsRequired();
book.Property(p => p.Publisher).HasMaxLength(50);
book.Property(p => p.TimeStamp)
.HasColumnType("timestamp")
.ValueGeneratedOnAddOrUpdate()
.IsConcurrencyToken();
}
**NOTE**
Instead of using the IsConcurrencyToken method with the Fluent
API, you can also apply the attribute ConcurrencyCheck to the
property where concurrency should be checked.
The process of the conflict-handling check is like what was done
before. Both user 1 and user 2 invoke the PrepareUpdateAsync method,
change the book title, and call the UpdateAsync method to make the
change in the database (code file ConflictHandlingSample/Program.cs ):
public static void ConflictHandling()
{
// user 1
var tuple1 = PrepareUpdate();
tuple1.book.Title = "user 1 wins";
// user 2
var tuple2 = await PrepareUpdate();
tuple2.book.Title = "user 2 wins";
// user 1
Update(tuple1.context, tuple1.book);
// user 2
Update(tuple2.context, tuple2.book);


tuple1.context.Dispose();
tuple2.context.Dispose();
CheckUpdate(context1.book.BookId);
}
The PrepareUpdate method is not repeated here, as this method is
implemented in the same way as with the previous sample. What’s
quite different is the Update method. To see the different timestamps,
before and after the update, a custom extension method StringOutput
for the byte array is implemented that writes the byte array in a
readable form to the console. Next, the changes of the Book object are
shown calling the ShowChanges helper method. The SaveChanges
method is invoked to write all updates to the database. In case the
update fails with a DbUpdateConcurrencyException , information is
written to the console about the failure (code file
ConflictHandlingSample/Program.cs ):
private static Update(BooksContext context, Book book, string
user)
{
try
{
Console.WriteLine($"{user}: updating id {book.BookId}, "
+
$"timestamp: {book.TimeStamp.StringOutput()}");
ShowChanges(book.BookId, context.Entry(book));
int records = await context.SaveChangesAsync();
Console.WriteLine($»{user}: updated
{book.TimeStamp.StringOutput()}»);
Console.WriteLine($"{user}: {records} record(s) updated
while updating " +
$"{book.Title}");
}
catch (DbUpdateConcurrencyException ex)
{
Console.WriteLine($"{user}: update failed with
{book.Title}");
Console.WriteLine($"error: {ex.Message}");
foreach (var entry in ex.Entries)
{
if (entry.Entity is Book b)
{
Console.WriteLine($"{b.Title}
{b.TimeStamp.StringOutput()}");
ShowChanges(book.BookId, context.Entry(book));


}
}
}
}
With objects that are associated with the context, you can access the
original values and the current values with a PropertyEntry object. The
original values that were retrieved when reading the object from the
database can be accessed with the OriginalValue property, the current
values with the CurrentValue property. The PropertyEntry object can
be accessed with the Property method of an EntityEntry as shown in
the ShowChanges and ShowChange methods (code file
ConflictHandlingSample/Program.cs ):
private static void ShowChanges(int id, EntityEntry entity)
{
void ShowChange(PropertyEntry propertyEntry) =>
Console.WriteLine($"id: {id}, current:
{propertyEntry.CurrentValue}, " +
$"original: {propertyEntry.OriginalValue}, " +
$"modified: {propertyEntry.IsModified}");
ShowChange(entity.Property("Title"));
ShowChange(entity.Property("Publisher"));
}
To convert the byte array of the TimeStamp property that is updated
from SQL Server for visual output, the extension method StringOutput
is defined (code file ConflictHandlingSample/ByteArrayExtensions.cs ):
static class ByteArrayExtension
{
public static string StringOutput(this byte[] data)
{
var sb = new StringBuilder();
foreach (byte b in data)
{
sb.Append($"{b}.");
}
return sb.ToString();
}
}
When you run the application, you can see output such as the


following. The timestamp values and book IDs differ with every run.
The first user updates the book with the original title sample book to
the new title user 1 wins. The IsModified property returns true for the
Title property but false for the Publisher property, as only the title
changed. The original timestamp ends with 1.1.209; after the update to
the database the timestamp is changed to 1.17.114. In the meantime,
user 2 opened the same record; this book still has a timestamp of
1.1.209. User 2 updates this book, but here the update failed because
the timestamp of this book does not match the timestamp from the
database. Here, a DbUpdateConcurrencyException exception is thrown.
In the exception handler, the reason of the exception is written to the
console as you can see in the program output:
user 1: updating id 1, timestamp 0.0.0.0.0.0.7.209.
id: 1, current: user 1 wins, original: sample book, modified:
True
id: 1, current: Sample, original: Sample, modified: False
user 1: updated 0.0.0.0.0.0.7.210.
user 1: 1 record(s) updated while updating user 1 wins
user 2: updating id 1, timestamp 0.0.0.0.0.0.7.209.
id: 1, current: user 2 wins, original: sample book, modified:
True
id: 1, current: Sample, original: Sample, modified: False
user 2 update failed with user 2 wins
user 2 error: Database operation expected to affect 1 row(s)
but actually
affected 0 row(s). Data may have been modified or deleted
since entities were loaded.
See http://go.microsoft.com/fwlink/?LinkId=527962 for
information on
understanding and handling optimistic concurrency exceptions.
user 2 wins 0.0.0.0.0.0.7.209.
id: 1, current: user 2 wins, original: sample book, modified:
True
id: 1, current: Sample, original: Sample, modified: False
this is the updated state: user 1 wins
When using concurrency tokens and handling the
DbConcurrencyException , you can deal with concurrency conflicts as
needed. You can, for example, automatically resolve concurrency
issues. If different properties are changed, you can retrieve the
changed record and merge the changes. If the property changed is a
number where you do some calculations——for example, a point system


——you can increment or decrement the values from both updates and
just throw an exception if a limit is reached. You can also ask the user
to resolve the concurrency issue by giving the user the information
that’s currently in the database and ask what changes he or she would
like to do. Just don’t ask too much from the user. It’s likely that the
only thing the user wants is to get rid of this rarely shown dialog,
which means he or she might click OK or Cancel without reading the
content. For rare conflicts, you can also write logs and inform the
system administrator that an issue needs to be resolved.
CONTEXT POOLING
With EF Core 2.0 you can increase performance by pooling the
context. Connections are already pooled for a long time. You should
open connections just before they are needed and close them
immediately after use. With EF Core, this behavior is already
implemented in the framework. On closing a connection, the
connection to the database server is not really closed. Instead, the
connection returns to the pool and can be reused when the next
connection is opened. Connection pools are configured with the
connection string.
DB contexts have similar usage guidelines to connections. They should
be created just before they are needed and closed (disposed)
immediately after use. The overhead of this is not as significant as you
might expect. The model is not newly initialized with every new
invocation of the context; instead the model is reused. With Entity
Framework and the XML file mapping, the overhead on creating the
context was a lot larger than it is now with EF Core. However, when
you have big contexts, the overhead of creating the context might be
still significant in your scenario. Here, you can increase performance
by using context pooling.
To use context pooling, dependency injection must be used. All you
need to do to activate context pooling is to change the EF Core
registration from AddDbContext to AddDbContextPool . This way, the
context injected (in the sample code the BooksContext ) is retrieved
from the context pool.


var services = new ServiceCollection();
services.AddTransient<BooksController>();
services.AddTransient<BooksService>();
services.AddEntityFrameworkSqlServer();
services.AddDbContextPool<BooksContext>(options =>
options.UseSqlServer(ConnectionString));
services.AddLogging();
Container = services.BuildServiceProvider();
USING TRANSACTIONS
Chapter 25 introduces programming with transactions. With every
access of the database using the Entity Framework, a transaction is
involved, too. You can use transactions implicitly or create them
explicitly with configurations as needed. The sample project used with
this section demonstrates transactions in both ways. Here, the Menu ,
MenuCard , and MenuContext classes are used as shown earlier with the
MenusSample project.
Using Implicit Transactions
An invocation of the SaveChanges method automatically resolves to one
transaction. If one part of the changes that need to be done fails——for
example, because of a database constraint——all the changes already
done are rolled back. This is demonstrated with the following code
snippet. Here, the first Menu ( m1 ) is created with valid data. A reference
to an existing MenuCard is done by supplying the MenuCardId . After the
update succeeds, the MenuCard property of the Menu m1 is filled
automatically. However, the second Menu created, mInvalid , references
an invalid menu card by supplying a MenuCardId that is one value
higher than the highest ID available in the database. Because of the
defined foreign key relation between MenuCard and Menu , adding this
object will fail (code file TransactionsSample/Program.cs ):
private static void AddTwoRecordsWithOneTx()
{
Console.WriteLine(nameof(AddTwoRecordsWithOneTx));
try
{
using (var context = new MenusContext())


{
var card = context.MenuCards.First();
var m1 = new Menu
{
MenuCardId = card.MenuCardId,
Text = "added",
Price = 99.99m
};
int hightestCardId = context.MenuCards.Max(c =>
c.MenuCardId);
var mInvalid = new Menu
{
MenuCardId = ++hightestCardId,
Text = "invalid",
Price = 999.99m
};
context.Menus.AddRange(m1, mInvalid);
int records = context.SaveChanges();
Console.WriteLine($"{records} records added");
}
}
catch (DbUpdateException ex)
{
Console.WriteLine($"{ex.Message}");
Console.WriteLine($"{ex?.InnerException.Message}");
}
Console.WriteLine();
}
After running the application invoking the method
AddTwoRecordsWithOneTx , you can verify the content of the database to
see that not a single record was added. The exception message as well
as the message of the inner exception gives the details:
AddTwoRecordsWithOneTx
trying to add one invalid record to the database, this should
fail...
An error occurred while updating the entries. See the inner
exception for details.
The MERGE statement conflicted with the FOREIGN KEY
constraint
"FK_Menus_MenuCards_MenuCardId".
The conflict occurred in database "ProCSharpMenuCards",
table "mc.MenuCards", column 'MenuCardId'.
The statement has been terminated.


In case writing the first record to the database should be successful
even if the second record write fails, you must invoke the SaveChanges
method multiple times as shown in the following code snippet. In the
method AddTwoRecordsWithTwoTx , the first invocation of SaveChanges
inserts the m1 Menu object, whereas the second invocation tries to
insert the mInvalid Menu object (code file
TransactionsSample/Program.cs ):
private static void AddTwoRecordsWithTwoTx()
{
Console.WriteLine(nameof(AddTwoRecordsWithTwoTx));
try
{
using (var context = new MenusContext())
{
var card = context.MenuCards.First();
var m1 = new Menu
{
MenuCardId = card.MenuCardId,
Text = "added",
Price = 99.99m
};
context.Menus.Add(m1);
int records = context.SaveChanges();
Console.WriteLine($"{records} records added");
int hightestCardId = context.MenuCards.Max(c =>
c.MenuCardId);
var mInvalid = new Menu
{
MenuCardId = ++hightestCardId,
Text = "invalid",
Price = 999.99m
};
context.Menus.Add(mInvalid);
records = context.SaveChanges();
Console.WriteLine($"{records} records added");
}
}
catch (DbUpdateException ex)
{
Console.WriteLine($"{ex.Message}");
Console.WriteLine($"{ex?.InnerException.Message}");
}
Console.WriteLine();
}


When you run the application, adding the first INSERT statement
succeeds, but of course the second one results in a DbUpdateException .
You can verify the database to see that one record was added this time:
AddTwoRecordsWithTwoTx
adding two records with two transactions to the database.
One record should be written, the other not....
1 records added
An error occurred while updating the entries. See the inner
exception for details.
The INSERT statement conflicted with the FOREIGN KEY
constraint "FK_Menus_MenuCards_MenuCardId".
The conflict occurred in database "ProCSharpMenuCards",
table "mc.MenuCards", column 'MenuCardId'.
The statement has been terminated.
Creating Explicit Transactions
Instead of using implicitly created transactions, you can also create
them explicitly. This gives you the advantage of also having the option
to roll back in case some of your business logic fails, and you can
combine multiple invocations of SaveChanges within one transaction.
To start a transaction that is associated with the DbContext derived
class, you need to invoke the BeginTransaction method of the
DatabaseFacade class that is returned from the Database property. The
transaction returned implements the interface IDbContextTransaction .
The SQL statements done with the associated DbContext are enlisted
with the transaction. To commit or roll back, you must explicitly
invoke the methods Commit or Rollback . In the sample code, Commit is
done when the end of the DbContext scope is reached; Rollback is done
in cases where an exception occurs (code file
TransactionsSample/Program.cs ):
private static void TwoSaveChangesWithOneTx()
{
Console.WriteLine(nameof(TwoSaveChangesWithOneTxAsync));
IDbContextTransaction tx = null;
try
{
using (var context = new MenusContext())
using (tx = await context.Database.BeginTransaction())
{
var card = context.MenuCards.First();


var m1 = new Menu
{
MenuCardId = card.MenuCardId,
Text = "added with explicit tx",
Price = 99.99m
};
context.Menus.Add(m1);
int records = await context.SaveChanges();
Console.WriteLine($"{records} records added");
int hightestCardId = context.MenuCards.Max(c =>
c.MenuCardId);
var mInvalid = new Menu
{
MenuCardId = ++hightestCardId,
Text = "invalid",
Price = 999.99m
};
context.Menus.Add(mInvalid);
records = await context.SaveChanges();
Console.WriteLine($"{records} records added");
tx.Commit();
}
}
catch (DbUpdateException ex)
{
Console.WriteLine($"{ex.Message}");
Console.WriteLine($"{ex?.InnerException.Message}");
Console.WriteLine("rolling back...");
tx.Rollback();
}
Console.WriteLine();
}
When you run the application, you can see that no records have been
added, although the SaveChanges method was invoked multiple times.
The first return of SaveChanges lists one record as being added, but this
record is removed based on the Rollback later. Depending on the
setting of the isolation level, the updated record can only be seen
before the rollback was done within the transaction, but not outside
the transaction.
TwoSaveChangesWithOneTx
using one explicit transaction, writing should roll back...
1 records added


An error occurred while updating the entries. See the inner
exception for details.
The INSERT statement conflicted with the FOREIGN KEY
constraint
"FK_Menus_MenuCards_MenuCardId".
The conflict occurred in database "ProCSharpMenuCards",
table "mc.MenuCards", column 'MenuCardId'.
The statement has been terminated.
rolling back...
**NOTE**
With the BeginTransaction method, you can also supply a value
for the isolation level to specify the isolation requirements and
locks needed in the database. Isolation levels are discussed in
Chapter 25.
MIGRATIONS
You can use EF Core with an existing database (known as “database
first”). In many scenarios where EF Core is used, the database already
exists. Updates to the database happen independently of the
applications, and the application is updated after database changes are
done. In such a scenario, EF Core migrations do not help much.
If you create the database with the application, EF Core migrations
can be very helpful. As you change your code models, the database can
be updated automatically. If your customers each have their own
database, and you change the database schema with newer versions of
the application, updating customers with older application versions
can be a challenge. EF Core migrations can solve this: With migrations
you can easily upgrade from version x to version y. The current version
of the database is read from the database, and migration has the
information that’s needed with every step to upgrade to the newest
version. You also can upgrade or downgrade to a specific version.
You have different options to upgrade the database. Migration can
happen directly from the application with upgrade commands. You


can also update the database from the command line using a dotnet
command. Another option is to create an SQL server script that can be
used by the database administrator to update the database.
The sample application to show migrations exists from a .NET
Standard library and a .NET Core Web application. Typically, data
access code is implemented within a library, and there are some
additional command-line options needed to deal with this, that’s why
migrations are demonstrated in such a scenario.
Preparing the Project File
Let’s start with a .NET Standard 2.0 Library. This library contains Menu
and MenuCard classes to define the model, MenuConfiguration and
MenuCardConfiguration classes to configure the mapping for the
corresponding model types by implementing the interface
IEntityTypeConfiguration , and the context class MenusContext .
The project file needs to be prepared to not only reference the NuGet
packages Microsoft.EntityFrameworkCore and
Microsoft.EntityFrameworkCore.SqlServer but also for having the EF
Core tools extension with the dotnet command line, a tool reference to
Microsoft.EntityFrameworkCore.Tools.Dotnet (project file
MigrationsLib/MigrationsLib.csproj ):
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<TargetFramework>netstandard2.0</TargetFramework>
</PropertyGroup>
<ItemGroup>
<PackageReference Include="Microsoft.EntityFrameworkCore"
Version="2.0.0" />
<PackageReference
Include="Microsoft.EntityFrameworkCore.SqlServer"
Version="2.0.0" />
</ItemGroup>
<ItemGroup>
<DotNetCliToolReference
Include="Microsoft.EntityFrameworkCore.Tools.Dotnet"
Version="2.0.0" />


</ItemGroup>
</Project>
For using the context class from a web application, the MenusContext is
implemented to use dependency injection with the constructor
requiring DbContextOptions (code file MigrationsLib/MenusContext.cs ):
public class MenusContext : DbContext
{
public MenusContext(DbContextOptions<MenusContext>
options):
base(options) { }
public DbSet<Menu> Menus { get; set; }
public DbSet<MenuCard> MenuCards { get; set; }
protected override void OnModelCreating(ModelBuilder
modelBuilder)
{
base.OnModelCreating(modelBuilder);
modelBuilder.HasDefaultSchema("mc");
modelBuilder.ApplyConfiguration(new
MenuCardConfiguration());
modelBuilder.ApplyConfiguration(new MenuConfiguration());
}
}
Hosting Applications with ASP.NET Core MVC
With a new ASP.NET Core MVC web application, dependency
injection using Microsoft.Extensions.DependencyInjection is already
built in to the template. All you need to do to enable migrations is to
add the EF Core DB context using the extension method AddDbContext
and configure SQL Server with UseSqlServer . The connection string to
the database needs to be configured in the configuration file. With
this, you are ready for using the command line for migrations (code
file MigrationsWebApp/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddMvc();
services.AddDbContext<MenusContext>(options =>


options.UseSqlServer(
Configuration.GetConnectionString("MenusConnection")));
}
**NOTE**
ASP.NET Core MVC is covered in Chapter 31, “ASP.NET Core
MVC.” Before that you should read Chapter 20, “Dependency
Injection,” and Chapter 30, “ASP.NET Core.”
Hosting .NET Core Console App
If your EF Core DB context is not using dependency injection, you are
ready to go and use the context class with the tools configured. In that
case, the connections string can be retrieved with the OnConfiguring
method of the context. Using dependency injection, the connection
string is injected from the outside. ASP.NET Core has special support
from the tools in accessing the Main method of the web application to
get the connection string via the dependency injection container. Your
Main method in console applications (and with UWP, WPF, and
Xamarin applications) looks different. Here, you need to implement a
factory class that returns the DB context by implementing the
interface IDesignTimeDbContextFactory . A class implementing this
interface is automatically detected from the .NET Core tools when
accessing the assembly. The method CreateDbContext defined by this
interface needs to return a configured context (code file
MigrationsConsoleApp/MenusContextFactory.cs ):
public class MenusContextFactory :
IDesignTimeDbContextFactory<MenusContext>
{
private const string ConnectionString =
@"server=
(localdb)\mssqllocaldb;database=ProCSharpMigrations;" +
"trusted_connection=true";
public MenusContext CreateDbContext(string[] args)
{


var optionsBuilder = new
DbContextOptionsBuilder<MenusContext>();
optionsBuilder.UseSqlServer(ConnectionString);
return new MenusContext(optionsBuilder.Options);
}
}
The project file of the console application that is used by the .NET
Core tools needs to reference the NuGet package
Microsoft.EntityFrameworkCore.Design . The Design-Library is only
needed for the tools and does not need to be referenced from calling
apps, that’s why the PrivateAssets attribute can be set (project file
MigrationsConsoleApp/MigrationsConsoleApp.csproj ):
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<OutputType>Exe</OutputType>
<TargetFramework>netcoreapp2.0</TargetFramework>
</PropertyGroup>
<ItemGroup>
<PackageReference Include="Microsoft.EntityFrameworkCore"
Version="2.0.0" />
<PackageReference
Include="Microsoft.EntityFrameworkCore.SqlServer"
Version="2.0.0" />
<PackageReference
Include="Microsoft.EntityFrameworkCore.Design"
Version="2.0.0" PrivateAssets="All" />
</ItemGroup>
<ItemGroup>
<ProjectReference
Include="..\MigrationsLib\MigrationsLib.csproj" />
</ItemGroup>
</Project>
Creating Migrations
With all this in place, you can create an initial migration. Using the
following command, the current directory needs to be the directory of
the library——the directory where the tool reference is defined. The


following command creates the initial migration named InitMenus .
The startup project referenced with the option --startup-project
contains the initial code that contains the connection string to the
server——either with the Main method generated from the default project
template of the ASP.NET Core web application or an object
implementing IDesignTimeContextFactory as shown in the previous
section:
> dotnet ef migrations add InitMenus --startup-project
../MigrationsConsoleApp
In case your project contains multiple DB contexts, you need to supply
the additional option --context and supply the name of the DB context
class.
Running this command creates a Migrations folder with a snapshot to
create the complete database schema based on the model (code file
MigrationsLib/Migration/MenusContextModelSnapshot.cs ):
[DbContext(typeof(MenusContext))]
partial class MenusContextModelSnapshot : ModelSnapshot
{
protected override void BuildModel(ModelBuilder
modelBuilder)
{
#pragma **WARNING** disable 612, 618
modelBuilder
.HasDefaultSchema("mc")
.HasAnnotation("ProductVersion", "2.0.0-rtm-26452")
.HasAnnotation("SqlServer:ValueGenerationStrategy",
SqlServerValueGenerationStrategy.IdentityColumn);
modelBuilder.Entity("MigrationsLib.Menu", b =>
{
b.Property<int>("MenuId")
.ValueGeneratedOnAdd();
b.Property<int>("MenuCardId");
b.Property<decimal>("Price")
.HasColumnType("Money");
b.Property<string>("Text")
.HasMaxLength(120);


b.HasKey("MenuId");
b.HasIndex("MenuCardId");
b.ToTable("Menus");
});
modelBuilder.Entity("MigrationsLib.MenuCard", b =>
{
b.Property<int>("MenuCardId")
.ValueGeneratedOnAdd();
b.Property<bool>("IsDeleted");
b.Property<DateTime>("LastUpdated");
b.Property<string>("Title")
.HasMaxLength(50);
b.HasKey("MenuCardId");
b.ToTable("MenuCards");
});
modelBuilder.Entity("MigrationsLib.Menu", b =>
{
b.HasOne("MigrationsLib.MenuCard", "MenuCard")
.WithMany("Menus")
.HasForeignKey("MenuCardId")
.OnDelete(DeleteBehavior.Cascade);
});
#pragma **WARNING** restore 612, 618
}
}
For every migration, a migration class deriving from the base class
Migration is created. This base class defines the Up and Down methods
that allow applying the migration to this migration version or to step a
level back (code file MigrationsLib/<version>_InitialMenus.cs ):
public partial class InitialMenus : Migration
{
protected override void Up(MigrationBuilder
migrationBuilder)
{
migrationBuilder.EnsureSchema(name: "mc");


migrationBuilder.CreateTable(
name: "MenuCards",
schema: "mc",
columns: table => new
{
MenuCardId = table.Column<int>(type: "int", nullable:
false)
.Annotation("SqlServer:ValueGenerationStrategy",
SqlServerValueGenerationStrategy.IdentityColumn),
IsDeleted = table.Column<bool>(type: "bit", nullable:
false),
LastUpdated = table.Column<DateTime>(type:
"datetime2",
nullable: false),
Title = table.Column<string>(type: "nvarchar(50)",
maxLength: 50,
nullable: true)
},
constraints: table =>
{
table.PrimaryKey("PK_MenuCards", x => x.MenuCardId);
});
migrationBuilder.CreateTable(
name: "Menus",
schema: "mc",
columns: table => new
{
MenuId = table.Column<int>(type: "int", nullable:
false)
.Annotation("SqlServer:ValueGenerationStrategy",
SqlServerValueGenerationStrategy.IdentityColumn),
MenuCardId = table.Column<int>(type: "int", nullable:
false),
Price = table.Column<decimal>(type: "Money",
nullable: false),
Text = table.Column<string>(type: "nvarchar(120)",
maxLength: 120,
nullable: true)
},
constraints: table =>
{
table.PrimaryKey("PK_Menus", x => x.MenuId);
table.ForeignKey(
name: "FK_Menus_MenuCards_MenuCardId",
column: x => x.MenuCardId,
principalSchema: "mc",
principalTable: "MenuCards",


principalColumn: "MenuCardId",
onDelete: ReferentialAction.Cascade);
});
migrationBuilder.CreateIndex(
name: "IX_Menus_MenuCardId",
schema: "mc",
table: "Menus",
column: "MenuCardId");
}
protected override void Down(MigrationBuilder
migrationBuilder)
{
migrationBuilder.DropTable(
name: "Menus",
schema: "mc");
migrationBuilder.DropTable(
name: "MenuCards",
schema: "mc");
}
}
After making a change to a model, such as adding Allergens to the
Menu class (code file MigrationsLib/Menu.cs ):
public class Menu
{
public int MenuId { get; set; }
public string Text { get; set; }
public decimal Price { get; set; }
public string Allergens { get; set; }
public int MenuCardId { get; set; }
public MenuCard MenuCard { get; set; }
public override string ToString() => Text;
}
Requires a new migration:
> dotnet ef migrations add AddAllergens --startup-project
..\MigrationsConsoleApp
With the new migration, that snapshot class is updated to show the
current state, and a new Migration type is added to add and remove
the allergen column with the Up and Down methods (code file


MigrationsLib/<version>_AddAllergens.cs )
public partial class AddAllergens : Migration
{
protected override void Up(MigrationBuilder
migrationBuilder)
{
migrationBuilder.AddColumn<string>(
name: "Allergens",
schema: "mc",
table: "Menus",
type: "nvarchar(max)",
nullable: true);
}
protected override void Down(MigrationBuilder
migrationBuilder)
{
migrationBuilder.DropColumn(
name: "Allergens",
schema: "mc",
table: "Menus");
}
}
Pay attention to build the library before applying a new migration.
Otherwise, the new migration can be empty.
**NOTE**
With every change you’re doing, you can create another
migration. The new migration defines only the changes needed to
get from the previous version to the new version. In case a
customer’s database needs to be updated from any earlier
version, the necessary migrations are invoked when migrating
the database.
During the development process, you might end up with many
migrations that are not needed in production. You just need to keep
the migrations for all the versions that might be running on the
customer sites. To remove the migrations from development time,


you can invoke dotnet ef migrations remove to remove the latest
migration code. Then add new larger migrations that contain all the
changes since the previous migration.
Applying Migrations Programmatically
After you’ve configured the migrations, you can start the migration
process of the database directly from the application. To do this, the
console application is configured to use the dependency injection
container to retrieve the DB context and then to invoke the Migrate
method of the Database property (code file
MigrationsConsoleApp/Program.cs ):
class Program
{
private const string ConnectionString =
@"server=
(localdb)\mssqllocaldb;database=ProCSharpMigrations;" +
@"trusted_connection=true";
static void Main(string[] args)
{
RegisterServices();
var context = Container.GetService<MenusContext>();
context.Database.Migrate();
}
private static void RegisterServices()
{
var services = new ServiceCollection();
services.AddDbContext<MenusContext>(options =>
options.UseSqlServer(ConnectionString));
Container = services.BuildServiceProvider();
}
public static IServiceProvider Container { get; private
set; }
}
In case the database does not exist yet, the Migrate method creates the
database——with the schemas defined by the model——as well as a
__EFMigrationsHistory table that lists all the migrations that have
been applied to the database. You cannot use the EnsureCreated
method to create the database as was used earlier because this method


does not apply the migration information to the database.
With an existing database, the database gets updated to the current
version of the migration. Programmatically you can get all the
migrations available in the application with the GetMigrations method.
To see all applied migrations, you can use the GetAppliedMigrations
method. For all migrations that are missing in the database, use the
GetPendingMigrations method.
Other Ways to Apply Migrations
Instead of applying migrations programmatically, you can apply
migrations using the command line:
> dotnet ef database update --startup-project
../MigrationsConsoleApp
This command applies the latest migration to the database. You can
also supply the name of the migration to this command to put the
database into a specific version of the migration.
In case you have a database administrator who needs to keep full
control over the database and doesn’t allow programmatic changes,
and no changes from a tool such as the .NET Core CLI command line,
you can create a SQL script and hand this over or use it by yourself.
The following command line creates the SQL script
migrationsscript.sql from the initial database creation up to the
latest migration. You can also supply specific from/to values for the
range of the migrations that should be applied in the script:
> dotnet ef migrations script --output migrationsscript.sql
--startup-project ..\MigrationsConsoleApp
SUMMARY
This chapter introduced you to the features of the EF Core. You’ve
learned how the object context keeps knowledge about entities
retrieved and updated, and how changes can be written to the
database. You’ve also seen how migrations can be used to create and
change the database schema from C# code. To define the schema,


you’ve seen how the database mapping can be done using data
annotations, and you’ve also seen the fluent API that offers more
features compared to the annotations.
You’ve seen possibilities for reacting to conflicts when multiple users
work on the same record, as well as using transactions implicitly or
explicitly for more transactional control.
New features of EF Core 2.0, such as compiled queries, global query
filters, table splitting, and owned entities, have been covered with
great information to get you started.
The next chapter gets into globalization and localization features of
.NET, using culture specific date, time, and number formats, as well as
resources to define text for different languages.