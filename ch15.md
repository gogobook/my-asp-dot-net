

Asynchronous Programming
WHAT’S IN THIS CHAPTER?
- The importance of asynchronous programming
- Asynchronous patterns
- Foundations of asynchronous programming
- Error handling with asynchronous methods
- Asynchronous programming with Windows Apps

WROX.COM CODE DOWNLOADS FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory Async .
The code for this chapter is divided into the following major
examples:
- AsyncHistory
- Foundations
- Error Handling
- AsyncWindowsApp


## WHY ASYNCHRONOUS PROGRAMMING IS IMPORTANT
The .NET Framework 4.5 added the Task Parallel Library (TPL) to
.NET to make parallel programming easier. C# 5.0 added two
keywords to make asynchronous programming easier: async and
await . These two keywords are the main focus of this chapter.
With asynchronous programming a method is called that runs in the
background (typically with the help of a thread or task), and the calling
thread is not blocked.
In this chapter, you can read about different patterns on asynchronous
programming such as the asynchronous pattern, the event-based
asynchronous pattern, and the task-based asynchronous pattern
(TAP). TAP makes use of the async and await keywords. When you
compare these patterns, you can see the real advantage of this style of
asynchronous programming.
After discussing the different patterns, you see the foundation of
asynchronous programming by creating tasks and invoking
asynchronous methods. You find out what’s behind the scenes with
continuation tasks and the synchronization context.
Error handling needs some special emphasis; as with asynchronous
tasks, some scenarios require some different handling with errors.
The last part of this chapter discusses specific scenarios with Universal
Windows apps, what you need to be aware of with asynchronous
programming.
**NOTE**
Chapter 21, “Tasks and Parallel Programming,” covers other
information about parallel programming.
Users find it annoying when an application does not immediately react
to requests. With the mouse, we have become accustomed to
experiencing a delay, as we’ve learned that behavior over several
decades. With a touch UI, an application needs to immediately react to
requests. Otherwise, the user tries to redo the action.
Because asynchronous programming was hard to achieve with older
versions of the .NET Framework, it was not always done when it
should have been. One of the applications that blocked the UI thread
fairly often is an older version of Visual Studio. With that version,
opening a solution containing hundreds of projects meant you could
take a long coffee break. Visual Studio 2017 offers the Lightweight
Solution Load feature, which loads projects only as needed and with
the selected project loaded first. Since Visual Studio 2015, the NuGet
package manager is no longer implemented as a modal dialog. The
new NuGet package manager can load information about packages
asynchronously while you do other things at the same time. These are
just a few examples of important changes built into Visual Studio
related to asynchronous programming.
Many APIs with .NET offer both a synchronous and an asynchronous
version. Because the synchronous version of the API was a lot easier to
use, it was often used where it wasn’t appropriate. With the new
Windows Runtime (WinRT), if an API call is expected to take longer
than 40 milliseconds, only an asynchronous version is available. Since
C# 5.0, programming asynchronously is as easy as programming in a
synchronous manner, so there shouldn’t be any barrier to using the
asynchronous APIs, but of course there can be traps, which are
covered in this chapter.


## .NET HISTORY OF ASYNCHRONOUS PROGRAMMING
Before stepping into the new async and await keywords, it is best to
understand asynchronous patterns from the .NET Framework.
Asynchronous features have been available since .NET Framework 1.0,
and many classes in the .NET Framework implement one or more
such patterns.
Here, we start doing a synchronous networking call followed by the
different asynchronous patterns:

- Asynchronous pattern
- Event-based asynchronous pattern
- Task-based asynchronous pattern

The asynchronous pattern, which was the first way of handling
asynchronous features, is not only available with several APIs but also
with a base functionality such as the delegate type.
Because doing updates on the UI——both with Windows Forms and
WPF——with the asynchronous pattern is quite complex, .NET
Framework 2.0 introduced the event-based asynchronous pattern.
With this pattern, an event handler is invoked from the thread that
owns the synchronization context, so updating UI code is easily
handled with this pattern. Previously, this pattern was also known
with the name asynchronous component pattern.
With the .NET Framework 4.5, another way to achieve asynchronous
programming was introduced: the task-based asynchronous pattern
(TAP). This pattern is based on the Task type and makes use of a
compiler feature with the keywords async and await .
The sample code for the HistorySample uses at least C# 7.1 and these
namespaces:
```
System
System.IO
System.Net
System.Threading.Tasks
```
A sample app doing an HTTP request is a good use case as several of
the System.Net APIs offer synchronous as well as asynchronous APIs.

### Synchronous Call
Let’s start with the synchronized version using the WebClient class.
This class offers several synchronous APIs, such as DownloadString ,


DownloadFile , and DownloadData . In the following code snippet,
DownloadString makes an HTTP request and writes the response
in the
string content. A substring of this string is written to the console (code
file AsyncHistory/Program.cs ):
private const string url = "http://www.cninnovation.com";
private static <T> void SynchronizedAPI()
{
Console.WriteLine(nameof(SynchronizedAPI));
using (var client = new WebClient())
{
string content = client.DownloadString(url);
Console.WriteLine(content.Substring(0, 100));
}
Console.WriteLine();
}
The method DownloadString blocks the calling thread until the result is
returned. It’s not a good idea to invoke this method from the user
interface thread of the client application because it blocks the user
interface. The wait is unpleasant to the user because the application is
unresponsive during this network call.
Asynchronous Pattern
One way to make the call asynchronously is by using the asynchronous
pattern. Many APIs of .NET offer the asynchronous pattern. With the
.NET Framework, also the delegate type supports this pattern. Just be
aware that when you invoke these methods of the delegate with .NET
Core, an exception with the information that the platform is not
supported is thrown.
The asynchronous pattern defines a BeginXXX method and an EndXXX
method. For example, if a synchronous method DownloadString is
offered, the asynchronous variants would be BeginDownloadString and
EndDownloadString . The BeginXXX method takes all input arguments of
the synchronous method, and EndXXX takes the output arguments and
return type to return the result. With the asynchronous pattern, the
BeginXXX method also defines a parameter of AsyncCallback , which
accepts a delegate that is invoked as soon as the asynchronous method


is completed. The BeginXXX method returns IAsyncResult , which can
be used for polling to verify whether the call is completed, and to wait
for the end of the method.
The WebClient class doesn’t offer an implementation of the
asynchronous pattern. Instead, the WebRequest class can be used. The
WebRequest class itself is used by the WebClient . WebRequest offers this
pattern with the methods BeginGetResponse and EndGetResponse
( GetResponse is the synchronous version of this API).
In the following code snippet, a WebRequest is created using the Create
method of the WebRequest class. Using this request object, the
BeginGetResponse method starts the asynchronous HTTP GET request
to the server. The calling thread is not blocked. The first parameter of
the method is an AsyncCallback . This is a delegate referencing a void
method with an IAsyncResult argument. The implementation is done
with the local function ReadResponse . This method is invoked as soon
as the network request is completed. Within the implementation, the
request object is used again to retrieve the result using
GetResponseStream . In the code sample, Stream and StreamReader are
used to access the returned string content (code file
AsyncHistory/Program.cs ):
private static void AsynchronousPattern()
{
Console.WriteLine(nameof(AsynchronousPattern));
WebRequest request = WebRequest.Create(url);
IAsyncResult result =
request.BeginGetResponse(ReadResponse, null);
void ReadResponse(IAsyncResult ar)
{
using (WebResponse response = request.EndGetResponse(ar))
{
Stream stream = response.GetResponseStream();
var reader = new StreamReader(stream);
string content = reader.ReadToEnd();
Console.WriteLine(content.Substring(0, 100));
Console.WriteLine();
}
}
}


Because a local function is used with the implementation, the request
variable from the outer scope can be directly accessed with the closure
functionality of the local function. Similar behavior is available with
lambda expressions. In case a separate method would be used, the
request object must be passed to this method. This is possible by
passing the request object as the second argument of the
BeginGetResponse method. This parameter can be retrieved in the
called method using the AsyncState property of the IAsyncResult .
**NOTE**
Local functions are explained in Chapter 13, “Functional
Programming with C#.”
There’s a problem with using the asynchronous pattern with UI
applications: The method invoked from the AsyncCallback is not
running in the UI thread, thus you cannot access members of UI
elements without switching to the UI thread. An exception with the
information The calling thread cannot access this object because
a different thread owns it. would be the thrown. To make this
easier, the .NET Framework 2.0 introduced the event-based
asynchronous pattern, which makes it easier to deal with UI updates.
This pattern is discussed next.
Event-Based Asynchronous Pattern
The method EventBasedAsyncPattern makes use of the event-based
asynchronous pattern. This pattern defines a method with the suffix
Async . Again, the example code uses the WebClient class. With the
synchronous method DownloadString , the WebClient class offers the
asynchronous variant DownloadStringAsync . When the request is
completed, the DownloadStringCompleted event is fired. With the event
handler of this event, the result can be retrieved. The
DownloadStringCompleted event is of type
DownloadStringCompletedEventHandler . The second argument is of type
DownloadStringCompletedEventArgs . This argument returns the result


string with the Result property (code file AsyncHistory/Program.cs ):
private static void EventBasedAsyncPattern()
{
Console.WriteLine(nameof(EventBasedAsyncPattern));
using (var client = new WebClient())
{
client.DownloadStringCompleted += (sender, e) =>
{
Console.WriteLine(e.Result.Substring(0, 100));
};
client.DownloadStringAsync(new Uri(url));
Console.WriteLine();
}
}
With the DownloadStringCompleted event, the event handler is invoked
with the thread that holds the synchronization context. Using
Windows Forms, WPF, and the Universal Windows Platform, this is
the UI thread. Thus, you can directly access UI elements from the
event handler. This is the big advantage of this pattern compared to
the asynchronous pattern.
The difference between this event-based asynchronous pattern and
synchronous programming is the order of method calls; they’re
reversed for the asynchronous pattern. Before invoking the
asynchronous method, you need to define what happens when the
method call is completed. The following section plunges into the new
world of asynchronous programming with the async and await
keywords.
Task-Based Asynchronous Pattern
The WebClient class was updated with the .NET Framework 4.5 to offer
the task-based asynchronous pattern (TAP) as well. This pattern
defines a suffix Async method that returns a Task type. Because the
WebClient class already offers a method with the Async suffix to
implement the task-based asynchronous pattern, the new method has
the name DownloadStringTaskAsync .
The method DownloadStringTaskAsync is declared to return
Task<string> . You do not need to declare a variable of Task<string> to


assign the result from DownloadStringTaskAsync ; instead, you can
declare a variable of type string , and you can use the await keyword.
The await keyword unblocks the thread to do other tasks. As soon as
the method DownloadStringTaskAsync completes its background
processing, the UI thread can continue and get the result from the
background task to the string variable resp . Also, the code following
this line continues (code file AsyncHistory/Program.cs ):
private static async Task TaskBasedAsyncPatternAsync()
{
Console.WriteLine(nameof(TaskBasedAsyncPatternAsync));
using (var client = new WebClient())
{
string content = await
client.DownloadStringTaskAsync(url);
Console.WriteLine(content.Substring(0, 100));
Console.WriteLine();
}
}
**NOTE**
The async keyword creates a state machine similar to the yield
return statement, which is discussed in Chapter 7, “Arrays.”
The code is much simpler now. There is no blocking, and no manually
switching back to the UI thread, as this is done automatically. Also, the
code follows the same order as you’re used to with synchronous
programming.
**NOTE**
A more modern HTTP client is implemented with the class
HttpClient . This class offers only asynchronous methods
supporting the task-based asynchronous pattern. How this class
can be used is explained in Chapter 23, “Networking.”


Async Main Method
The entry point of the console application, the Main method, has the
async modifier applied to allow the await keyword in the
implementation. Using this declaration of the Main method to return a
task requires C# 7.1 (code file AsyncHistory/Program.cs ):
static async Task Main()
{
SynchronizedAPI();
AsynchronousPattern();
EventBasedAsyncPattern();
await TaskBasedAsyncPatternAsync();
Console.ReadLine();
}
**NOTE**
To specify version 7.1 of the C# compiler you need to add the
LangVersion element to the csproj project file, or you can make a
change to Visual Studio in the Advanced Build Project Settings.
Now that you’ve seen the advantages of the async and await keywords,
the next section examines the programming foundation behind these
keywords.
FOUNDATION OF ASYNCHRONOUS
PROGRAMMING
The async and await keywords are just a compiler feature. The
compiler creates code by using the Task class. Instead of using the new
keywords, you could get the same functionality with C# 4 and methods
of the Task class; it’s just not as convenient.
This section gives information about what the compiler does with the
async and await keywords. It shows you an effortless way to create an
asynchronous method and demonstrates how to invoke multiple
asynchronous methods in parallel. You also see how you can change a


class to offer the asynchronous pattern with the new keywords.
The sample code for all the Foundations sample makes use of these
namespaces:
System
System.Collections.Generic
System.IO
System.Linq
System.Net
System.Runtime.CompilerServices
System.Threading
System.Threading.Tasks
**NOTE**
This downloadable sample application makes use of command-
line arguments, so you can easily verify each scenario. For
example, using the dotnet CLI, you can pass the -async command-
line parameter with this command: dotnet run -- -async . Using
Visual Studio, you can also configure the application arguments
in the Debug Project Settings.
To better understand what’s going on, the TraceThreadAndTask method
is created to write thread and task information to the console.
Task.CurrentId returns the identifier of the task.
Thread.CurrentThread.ManagedThreadId returns the identifier of the
current thread (code file Foundations/Program.cs):
public static void TraceThreadAndTask(string info)
{
string taskInfo = Task.CurrentId == null ? "no task" :
"task " +
Task.CurrentId;


Console.WriteLine($"{info} in thread
{Thread.CurrentThread.ManagedThreadId}" +
$"and {taskInfo}");
}
Creating Tasks
Let’s start with the synchronous method Greeting , which takes a while
before returning a string (code file Foundations/Program.cs ):
static string Greeting(string name)
{
TraceThreadAndTask($"running {nameof(Greeting)}");
Task.Delay(3000).Wait();
return $"Hello, {name}";
}
To make such a method asynchronously, you define the method
GreetingAsync . The task-based asynchronous pattern specifies that an
asynchronous method is named with the Async suffix and re-turns a
task. GreetingAsync is defined to have the same input parameters as
the Greeting method but returns Task<string>. Task<string> defines
a task that returns a string in the future. A simple way to return a task
is by using the Task.Run method. The generic version Task.Run<string>
() creates a task that returns a string. As the compiler already knows
the return type from the implementation ( Greeting returns a string),
you can also simplify the implementation by just using Task.Run():
static Task<string> GreetingAsync(string name) =>
Task.Run<string>(() =>
{
TraceThreadAndTask($"running {nameof(GreetingAsync)}");
return Greeting(name);
});
Calling an Asynchronous Method
You can call this asynchronous method GreetingAsync by using the
await keyword on the task that is returned. The await keyword
requires the method to be declared with the async modifier. The code
within this method does not continue before the GreetingAsync


method is completed. However, you can reuse the thread that started
the CallerWithAsync method. This thread is not blocked (code file
Foundations/Program.cs ):
private async static void CallerWithAsync()
{
TraceThreadAndTask($"started {nameof(CallerWithAsync)}");
string result = await GreetingAsync("Stephanie");
Console.WriteLine(result);
TraceThreadAndTask($"ended {nameof(CallerWithAsync)}");
}
When you run the application, you can see from the first output that
there’s no task. The GreetingAsync method is running in a task, and
this task is using a different thread from the caller. The synchronous
Greeting method then runs in this task. As the Greeting method
returns, the GreetingAsync method returns, and the scope is back in
the CallerWithAsync method after the await. Now, the CallerWithAsync
method runs in a different thread than before. There’s not a task
anymore, but although the method started with thread 2, after the
await thread 3 was used. The await made sure that the continuation
happens after the task was completed, but it now uses a different
thread. This behavior is different between Console applications and
applications that have a synchronization context as you see later in
this chapter in the “Async with Windows Apps” section:
started CallerWithAsync in thread 2 and no task
running GreetingAsync in thread 3 and task 1
running Greeting in thread 3 and task 1
Hello, Stephanie
ended CallerWithAsync in thread 3 and no task
Instead of passing the result from the asynchronous method to a
variable, you can also use the await keyword directly by passing an
argument. Here, the result from the GreetingAsync method is awaited
as it was in the previous code snippet, but this time the result is
directly passed to the Console.WriteLine method:
private async static void CallerWithAsync2()
{
TraceThreadAndTask($"started {nameof(CallerWithAsync2)}");
Console.WriteLine(await GreetingAsync("Stephanie"));


TraceThreadAndTask($"ended {nameof(CallerWithAsync2)}");
}
**NOTE**
With C# 7, the async modifier can be used with methods that
return void or return an object that offers the GetAwaiter method.
.NET offers the Task and ValueTask types. With the Windows
Runtime you also can use IAsyncOperation . You should avoid
using the async modifier with void methods; read more about this
in the “Error Handling” section later in this chapter.
The next section explains what’s driving the await keyword. Behind
the scenes, continuation tasks are used.
Using the Awaiter
You can use the async keyword with any object that offers the
GetAwaiter method and returns an awaiter. An awaiter implements the
interface INotifyCompletion with the method OnCompleted . This
method is invoked when the task is completed. With the following
code snippet, instead of using await on the Task, the GetAwaiter
method of the task is used. GetAwaiter from the Task class returns a
TaskAwaiter . Using the OnCompleted method, a local function is
assigned that is invoked when the task is completed (code file
Foundations/Program.cs ):
private static void CallerWithAwaiter()
{
TraceThreadAndTask($"starting
{nameof(CallerWithAwaiter)}");
TaskAwaiter<string> awaiter =
GreetingAsync("Matthias").GetAwaiter();
awaiter.OnCompleted(OnCompleteAwaiter);
void OnCompleteAwaiter()
{
Console.WriteLine(awaiter.GetResult());
TraceThreadAndTask($"ended {nameof(CallerWithAwaiter)}");


}
}
When you run the application, you can see a result similar to the
scenario in which you used the await keyword:
starting CallerWithAwaiter in thread 2 and no task
running GreetingAsync in thread 3 and task 1
running Greeting in thread 3 and task 1
Hello, Matthias
ended CallerWithAwaiter in thread 3 and no task
The compiler converts the await keyword by putting all the code that
follows within the block of a OnCompleted method.
Continuation with Tasks
You can also handle continuation by using features of the Task object .
GreetingAsync returns a Task<string> object. The Task object contains
information about the task created, and allows waiting for its
completion. The ContinueWith method of the Task class defines the
code that should be invoked as soon as the task is finished. The
delegate assigned to the ContinueWith method receives the completed
task with its argument, which allows accessing the result from the task
using the Result property (code file Foundations/Program.cs ):
private static void CallerWithContinuationTask()
{
TraceThreadAndTask("started CallerWithContinuationTask");
var t1 = GreetingAsync("Stephanie");
t1.ContinueWith(t =>
{
string result = t.Result;
Console.WriteLine(result);
TraceThreadAndTask("ended CallerWithContinuationTask");
});
}
Synchronization Context


If you verify the thread that is used within the methods you will find
that in all three methods—— CallerWithAsync CallerWithAwaiter , and
CallerWithContinuationTask ——different threads are used during the
lifetime of the methods. One thread is used to invoke the method
GreetingAsync , and another thread takes action after the await
keyword or within the code block in the ContinueWith method.
With a console application usually this is not an issue. However, you
have to ensure that at least one foreground thread is still running
before all background tasks that should be completed are finished. The
sample application invokes Console.ReadLine to keep the main thread
running until the return key is pressed.
With applications that are bound to a specific thread for some actions
(for example, with WPF applications or Windows apps, UI elements
can only be accessed from the UI thread), this is an issue.
Using the async and await keywords you don’t have to do any special
actions to access the UI thread after an await completion. By default,
the generated code switches the thread to the thread that has the
synchronization context. A WPF application sets a
DispatcherSynchronizationContext , and a Windows Forms application
sets a WindowsFormsSynchronizationContext . Windows apps use the
WinRTSynchronizationContext . If the calling thread of the
asynchronous method is assigned to the synchronization context, then
with the continuous execution after the await , by default the same
synchronization context is used. If the same synchronization context
shouldn’t be used, you must invoke the Task method
ConfigureAwait(continueOnCapturedContext: false) . An example that
illustrates this usefulness is a Windows app in which the code that
follows the await is not using any UI elements. In this case, it is faster
to avoid the switch to the synchronization context.
Using Multiple Asynchronous Methods
Within an asynchronous method you can call multiple asynchronous
methods. How you code this depends on whether the results from one
asynchronous method are needed by another.


Calling Asynchronous Methods Sequentially
You can use the await keyword to call every asynchronous method. In
cases where one method is dependent on the result of another method,
this is very useful. Here, the second call to GreetingAsync is completely
independent of the result of the first call to GreetingAsync . Thus, the
complete method MultipleAsyncMethods could return the result faster
if await is not used with every single method, as shown in the
following example (code file Foundations/Program.cs ):
private async static void MultipleAsyncMethods()
{
string s1 = await GreetingAsync("Stephanie");
string s2 = await GreetingAsync("Matthias");
Console.WriteLine($"Finished both methods.
{Environment.NewLine} " +
$"Result 1: {s1}{Environment.NewLine} Result 2: {s2}");
}
Using Combinators
If the asynchronous methods are not dependent on each other, it is a
lot faster not to await on each separately; instead assign the return of
the asynchronous method to a Task variable. The GreetingAsync
method returns Task<string> . Both these methods can now run in
parallel. Combinators can help with this. A combinator accepts
multiple parameters of the same type and returns a value of the same
type. The passed parameters are "combined" to one. Task combinators
accept multiple Task objects as parameter and return a Task .
The sample code invokes the Task.WhenAll combinator method that
you can await to have both tasks finished (code file
Foundations/Program.cs ):
private async static void
MultipleAsyncMethodsWithCombinators1()
{
Task<string> t1 = GreetingAsync("Stephanie");
Task<string> t2 = GreetingAsync("Matthias");
await Task.WhenAll(t1, t2);
Console.WriteLine($"Finished both methods.
{Environment.NewLine} " +
$"Result 1: {t1.Result}{Environment.NewLine} Result 2:


{t2.Result}");
}
The Task class defines the WhenAll and WhenAny combinators. The Task
returned from the WhenAll method is completed as soon as all tasks
passed to the method are completed; the Task returned from the
WhenAny method is completed as soon as one of the tasks passed to the
method is completed.
The WhenAll method of the Task type defines several overloads. If all
the tasks return the same type, you can use an array of this type for the
result of the await . The GreetingAsync method returns a Task<string> ,
and awaiting for this method results in a string . Therefore, you can
use Task.WhenAll to return a string array:
private async static void
MultipleAsyncMethodsWithCombinators2()
{
Task<string> t1 = GreetingAsync("Stephanie");
Task<string> t2 = GreetingAsync("Matthias");
string[] result = await Task.WhenAll(t1, t2);
Console.WriteLine($"Finished both methods.
{Environment.NewLine} " +
$"Result 1: {result[0]}{Enviornment.NewLine} Result 2:
{result[1]}");
}
The WhenAll method is of practical use when the waiting task can
continue only when all tasks it’s waiting for are finished. The WhenAny
method can be used when the calling task can do some work when any
task it’s waiting for is completed. It can use a result from the task to go
on.
Using ValueTasks
C# 7 is more flexible with the await keyword; it can now await any
object offering the GetAwaiter method. A new type that can be used
with await is ValueTask . Contrary to the Task which is a class,
ValueTask is a struct. This has a performance advantage as the
ValueTask doesn’t have an object on the heap.
What is the real overhead of a Task object compared to the


asynchronous method call? A method that needs to be invoked
asynchronously typically has a lot more overhead than an object on the
heap. Most times, the overhead of a Task object on the heap can be
ignored——but not always. For example, a method can have one path
where data is retrieved from a service with an asynchronous API. With
this data retrieval, the data is written to a local cache. When you
invoke the method the second time, the data can be retrieved in a fast
manner without needing to create a Task object.
The sample method GreetingValueTaskAsync does exactly this. In case
the name is already found in the dictionary, the result is returned as a
ValueTask . If the name isn’t in the dictionary, the GreetingAsync
method is invoked, which returns a Task . Awaiting on this task to
retrieve the result, a ValueTask is returned again (code file
Foundations/Program.cs ):
private readonly static Dictionary<string, string> names =
new Dictionary<string, string>();
static async ValueTask<string> GreetingValueTaskAsync(string
name)
{
if (names.TryGetValue(name, out string result))
{
return result;
}
else
{
result = await GreetingAsync(name);
names.Add(name, result);
return result;
}
}
The UseValueTask method invokes the method GreetingValueTaskAsync
two times with the same name. The first time, the data is retrieved
using the GreetingAsync method; the second time, data is found in the
dictionary and returned from there:
private static async void UseValueTask()
{
string result = await GreetingValueTaskAsync("Katharina");
Console.WriteLine(result);


string result2 = await GreetingValueTaskAsync("Katharina");
Console.WriteLine(result2);
}
In case a method doesn’t use the async modifier and a ValueTask needs
to be returned, ValueTask objects can be created using the constructor
passing the result, or passing a Task object:
static ValueTask<string> GreetingValueTask2Async(string name)
{
if (names.TryGetValue(name, out string result))
{
return new ValueTask<string>(result);
}
else
{
Task<string> t1 = GreetingAsync(name);
TaskAwaiter<string> awaiter = t1.GetAwaiter();
awaiter.OnCompleted(OnCompletion);
return new ValueTask<string>(t1);
void OnCompletion()
{
names.Add(name, awaiter.GetResult());
}
}
}
Converting the Asynchronous Pattern
Not all classes from the .NET Framework introduced the new
asynchronous method style. There are still many classes that offer the
asynchronous pattern with the BeginXXX and EndXXX methods and not
with task-based asynchronous methods; you will see this when you
work with different classes from the frame-work. However, you can
convert the asynchronous pattern to the new task-based asynchronous
pattern.
This example uses the HttpWebRequest class with the BeginGetResponse
method to convert this method to the task-based async pattern.
Task.Factory.FromAsync is a generic method that offers a few overloads
to convert the asynchronous pattern to the task-based asynchronous
pattern. With the sample application, when the BeginGetResponse


method of the HttpWebRequest is invoked, the asynchronous network
request is started. This method returns an IAsyncResult , which is the
first argument to the FromAsync method. The second argument is a
reference to the method EndGetResponse , and it requires a delegate
with the IAsyncResult argument——which the EndGetResponse method is.
The second argument also requires a return of WebResponse as defined
by the generic parameter for the FromAsync method. The
EndGetResponse method is invoked by the task helper functionality
when the IAsyncResult signals completion (code file
Foundations/Program.cs ):
private static async void ConvertingAsyncPattern()
{
HttpWebRequest request =
WebRequest.Create("http://www.microsoft.com")
as HttpWebRequest;
using (WebResponse response = await
Task.Factory.FromAsync<WebResponse>(
request.BeginGetResponse(null, null),
request.EndGetResponse))
{
Stream stream = response.GetResponseStream();
using (var reader = new StreamReader(stream))
{
string content = reader.ReadToEnd();
Console.WriteLine(content.Substring(0, 100));
}
}
}
**WARNING**
With legacy applications, often the BeginInvoke method of the
delegate is used when using the asynchronous pattern. The
compiler does not complain when you use this method from a
.NET Core application. However, during runtime you get a
platform not supported exception.


ERROR HANDLING
Chapter 14, “Errors and Exceptions,” provides detailed coverage of
errors and exception handling. However, in the context of
asynchronous methods, you should be aware of some special handling
of errors.
The code for the ErrorHandling example makes use of these
namespaces:
System
System.Threading.Tasks
Let’s start with a simple method that throws an exception after a delay
(code file ErrorHandling/Program.cs ):
static async Task ThrowAfter(int ms, string message)
{
await Task.Delay(ms);
throw new Exception(message);
}
If you call the asynchronous method without awaiting it, you can put
the asynchronous method within a try / catch block——and the exception
will not be caught. That’s because the method DontHandle has already
completed before the exception from ThrowAfter is thrown. You need
to await the ThrowAfter method, as shown in the example that follows
in the next section. Pay attention that the exception is not caught in
this code snippet:
private static void DontHandle()
{
try
{
ThrowAfter(200, "first");
// exception is not caught because this method is
finished
// before the exception is thrown
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}


}
**WARNING**
Asynchronous methods that return void cannot be awaited. The
issue with this is that exceptions that are thrown from async void
methods cannot be caught. That’s why it is best to return a Task
type from an asynchronous method. Handler methods or
overridden base methods are exempted from this rule.
Handling Exceptions with Asynchronous Methods
A good way to deal with exceptions from asynchronous methods is to
use await and put a try / catch statement around it, as shown in the
following code snippet. The HandleOneError method releases the
thread after calling the ThrowAfter method asynchronously, but it
keeps the Task referenced to continue as soon as the task is completed.
When that happens (which, in this case, is when the exception is
thrown after two seconds), the catch matches and the code within the
catch block is invoked (code file ErrorHandling/Program.cs ):
private static async void HandleOneError()
{
try
{
await ThrowAfter(2000, "first");
}
catch (Exception ex)
{
Console.WriteLine($"handled {ex.Message}");
}
}
Handling Exceptions with Multiple Asynchronous
Methods
What if two asynchronous methods are invoked and both throw
exceptions? In the following example, first the ThrowAfter method is


invoked, which throws an exception with the message first after two
seconds. After this method is completed, the ThrowAfter method is
invoked, throwing an exception after one second. Because the first call
to ThrowAfter already throws an exception, the code within the try
block does not continue to invoke the second method, instead landing
within the catch block to deal with the first exception (code file
ErrorHandling/Program.cs ):
private static async void StartTwoTasks()
{
try
{
await ThrowAfter(2000, "first");
await ThrowAfter(1000, "second"); // the second call is
not invoked
// because the first method throws
// an exception
}
catch (Exception ex)
{
Console.WriteLine($"handled {ex.Message}");
}
}
Now start the two calls to ThrowAfter in parallel. The first method
throws an exception after two seconds and the second one after one
second. With Task.WhenAll you wait until both tasks are completed,
whether an exception is thrown or not. Therefore, after a wait of about
two seconds, Task.WhenAll is completed, and the exception is caught
with the catch statement. However, you only see the exception
information from the first task that is passed to the WhenAll method.
It’s not the task that threw the exception first (which is the second
task), but the first task in the list:
private async static void StartTwoTasksParallel()
{
try
{
Task t1 = ThrowAfter(2000, "first");
Task t2 = ThrowAfter(1000, "second");
await Task.WhenAll(t1, t2);
}
catch (Exception ex)


{
// just display the exception information of the first
task
// that is awaited within WhenAll
Console.WriteLine($"handled {ex.Message}");
}
}
One way to get the exception information from all tasks is to declare
the task variables t1 and t2 outside of the try block, so they can be
accessed from within the catch block. Here you can check the status of
the task to determine whether they are in a faulted state with the
IsFaulted property. In case of an exception, the IsFaulted property
returns true. The exception information itself can be accessed by using
Exception.InnerException of the Task class. Another, and usually
better, way to retrieve exception information from all tasks is
demonstrated next.
Using AggregateException Information
To get the exception information from all failing tasks, you can write
the result from Task.WhenAll to a Task variable. This task is then
awaited until all tasks are completed. Otherwise the exception would
still be missed. As described in the last section, with the catch
statement only the exception of the first task can be retrieved.
However, now you have access to the Exception property of the outer
task. The Exception property is of type AggregateException . This
exception type defines the property InnerExceptions (not only
InnerException ), which contains a list of all the exceptions that have
been awaited for. Now you can easily iterate through all the exceptions
(code file ErrorHandling/Program.cs ):
private static async void ShowAggregatedException()
{
Task taskResult = null;
try
{
Task t1 = ThrowAfter(2000, "first");
Task t2 = ThrowAfter(1000, "second");
await (taskResult = Task.WhenAll(t1, t2));
}
catch (Exception ex)


{
Console.WriteLine($"handled {ex.Message}");
foreach (var ex1 in taskResult.Exception.InnerExceptions)
{
Console.WriteLine($"inner exception {ex1.Message}");
}
}
}
ASYNC WITH WINDOWS APPS
Using the async keyword with Universal Windows Platform (UWP)
apps works the same as what you’ve already seen in this chapter.
However, you need to be aware that after calling await from the UI
thread, when the asynchronous method returns, you’re by default back
in the UI thread. This makes it easy to update UI elements after the
asynchronous method is completed.
**NOTE**
To build and create Universal Windows Platform (UWP) app, you
need Windows 10, and your Windows system must be configured
in “developer mode.” Enable the developer mode by opening the
Windows settings, chose the Update & Security tile, select the “For
developers” category, and click the radio button “Developer
mode.” This allows your system to run sideloaded apps (apps
without installing them from the Windows Store), and adds a
Windows package for the developer mode.
To understand the functionality——and the issues——a Universal
Windows App is created. This app contains five buttons and a
TextBlock element to demonstrate different scenarios (code file
AsyncWindowsApps/MainPage.xaml ):
<StackPanel>
<Button Content="Start Async" Click="OnStartAsync"
Margin="4" />
<Button Content="Start Async with Config"
Click="OnStartAsyncConfigureAwait"


Margin="4" />
<Button Content="Start Async with Thread Switch"
Click="OnStartAsyncWithThreadSwitch" Margin="4" />
<Button Content="Use IAsyncOperation"
Click="OnIAsyncOperation" Margin="4" />
<Button Content="Deadlock" Click="OnStartDeadlock"
Margin="4" />
<TextBlock x:Name="text1" Margin="4" />
</StackPanel>
**NOTE**
Programming UWP apps is covered in detail in Chapters 33 to 36.
In the OnStartAsync method, the thread ID of the UI thread is written
to the TextBlock element. Next the asynchronous method Task.Delay ,
which does not block the UI thread, is invoked, and after this method
completed the thread ID is written to the TextBlock again (code file
AsyncWindowsApps/MainPage.xaml.cs ):
private async void OnStartAsync(object sender,
RoutedEventArgs e)
{
text1.Text = $"UI thread: {GetThread()}";
await Task.Delay(1000);
text1.Text += $"\n after await: {GetThread()}";
}
For accessing the thread ID, you use the Environment class. With UWP
apps, the Thread class is not available——at least not until build 15063:
private string GetThread() => $"thread:
{Environment.CurrentManagedThreadId}";
When you run the application, you can see similar output in the text
element. Contrary to console applications, with UWP apps defining a
synchronization context, after the await you can see the same thread
as before. This allows direct access to UI elements:
UI thread: thread 3
after await: thread 3


Configure Await
In case you don’t need access to UI elements, you can configure await
to not use the synchronization context. The following code snippet
demonstrates the configuration and also shows why you shouldn’t
access UI elements from a background thread.
With the method OnStartAsyncConfigureAwait , after writing the ID of
the UI thread to the text information, the local function AsyncFunction
is invoked. In this local function, the starting thread is written before
the asynchronous method Task.Delay is invoked. Using the task
returned from this method, the ConfigureAwait is invoked. With this
method, the task is configured by passing the continueOn-
CapturedContext argument set to false . With this context
configuration, you see that the thread after the await is not the UI
thread anymore. Using a different thread to write the result to the
result variable is okay. What you should never do is shown in the try
block: accessing UI elements from a non-UI thread. The exception you
get contains the HRESULT value as shown in the when clause. Just this
exception is caught in the catch : the result is returned to the caller.
With the caller, ConfigureAwait is invoked as well, but this time the
continueOnCapturedContext is set to true. Here, both before and after
the await, the method is running in the UI thread (code file
AsyncWindowsApp/MainWindow.xaml.cs ):
private async void OnStartAsyncConfigureAwait(object sender,
RoutedEventArgs e)
{
text1.Text = $"UI thread: {GetThread()}";
string s = await AsyncFunction().ConfigureAwait(
continueOnCapturedContext: true);
// after await, with continueOnCapturedContext true we are
back in the UI thread
text1.Text += $"\n{s}\nafter await: {GetThread()}";
async Task<string> AsyncFunction()
{
string result = $"\nasync function: {GetThread()}\n";
await
Task.Delay(1000).ConfigureAwait(continueOnCapturedContext:


false);
result += $"\nasync function after await :
{GetThread()}";
try
{
text1.Text = "this is a call from the wrong thread";
return "not reached";
}
catch (Exception ex) when (ex.HResult == -2147417842)
{
return result;
// we know it's the wrong thread
// don't access UI elements from the previous try block
}
}
}
**NOTE**
Exception handling and filtering is explained in Chapter 14.
When you run the application, you can see output similar to the
following. In the async local function after the await, a different thread
is used. The text “ not reached ” is never written, because the exception
is thrown:
UI thread: thread 3
async function: thread 3
async function after await: thread 6
after await: thread 3
**WARNING**
In later UWP chapters in this book, data binding is used instead of
directly accessing properties of UI elements. However, with UWP


you also can’t write properties that are bound to UI elements
from a non UI-thread.
Switch to the UI Thread
In some scenarios, there’s no effortless way around using a
background thread and accessing UI elements. Here, you can switch to
the UI thread with the CoreDispatcher object that is returned from the
Dispatcher property. The Dispatcher property is defined in the
DependencyObject class. DependencyObject is a base class of UI
elements. Invoking the RunAsync method of the CoreDispatcher object
runs the passed lambda expression again in a UI thread (code file
AsyncWindowsApp/MainWindow.xaml.cs ):
private async void OnStartAsyncWithThreadSwitch(object
sender, RoutedEventArgs e)
{
text1.Text = $"UI thread: {GetThread()}";
string s = await AsyncFunction();
text1.Text += $"\nafter await: {GetThread()}";
async Task<string> AsyncFunction()
{
string result = $"\nasync function: {GetThread()}\n";
await
Task.Delay(1000).ConfigureAwait(continueOnCapturedContext:
false);
result += $"\nasync function after await :
{GetThread()}";
await Dispatcher.RunAsync(CoreDispatcherPriority.Normal,
() =>
{
text1.Text +=
$"\nasync function switch back to the UI thread:
{GetThread()}";
});
return result;
}
}


When you run the application, you can see always the UI thread used
when using RunAsync :
UI Thread: thread 3
async function switch back to the UI thread: thread 3
async function: thread 3
async function after await: thread 5
after await: thread 3
Using IAsyncOperation
Asynchronous methods are defined by the Windows Runtime to not
return a Task or a ValueTask . Task and ValueTask are not part of the
Windows Runtime. Instead, these methods return an object that
implements the interface IAsyncOperation . IAsyncOperation does not
define the method GetAwaiter as needed by the await keyword.
However, an IAsyncOperation is automatically converted to a Task
when you use the await keyword. You can also use the AsTask
extension method to convert an IAsyncOperation object to a task.
With the example application, in the method OnIAsyncOperation , the
ShowAsync method of the MessageDialog is invoked. This method
returns an IAsyncOperaition , and you can simply use the await
keyword to get the result (code file
AsyncWindowsApp/MainWindow.xaml.cs ):
private async void OnIAsyncOperation(object sender,
RoutedEventArgs e)
{
var dlg = new MessageDialog("Select One, Two, Or Three",
"Sample");
dlg.Commands.Add(new UICommand("One", null, 1));
dlg.Commands.Add(new UICommand("Two", null, 2));
dlg.Commands.Add(new UICommand("Three", null, 3));
IUICommand command = await dlg.ShowAsync();
text1.Text = $"Command {command.Id} with the label
{command.Label} invoked";


}
Avoid Blocking Scenarios
It’s dangerous using Wait on a Task and the async keyword together.
With applications using the synchronization context, this can easily
result in a deadlock.
In the method OnStartDeadlock , the local function DelayAsync is
invoked. DelayAsync waits on the completion of Task.Delay before
continuing in the foreground thread. However, the caller invokes the
Wait method on the task returned from DelayAsync . The Wait method
blocks the calling thread until the task is completed. In this case, the
Wait is invoked from the foreground thread, so the Wait blocks the
foreground thread. The await on Task.Delay can never complete,
because the foreground thread is not available. This is a classical
deadlock scenario (code file AsyncWindowsApps/MainWindow.xaml.cs ):
private void OnStartDeadlock(object sender, RoutedEventArgs
e)
{
DelayAsync().Wait();
}
private async Task DelayAsync()
{
await Task.Delay(1000);
}
**WARNING**
Avoid using Wait and await together in applications using the
synchronization context.
SUMMARY
This chapter introduced the async and await keywords. Having looked
at several examples, you’ve seen the advantages of the task-based


asynchronous pattern compared to the asynchronous pattern and the
event-based asynchronous pattern available with earlier editions of
.NET.
You’ve also seen how easy it is to create asynchronous methods with
the help of the Task class, and learned how to use the async and await
keywords to wait for these methods without blocking threads. Finally,
you looked at the error-handling aspect of asynchronous methods.
For more information on parallel programming, and details about
threads and tasks, see Chapter 21.
The next chapter continues with core features of C# and .NET and
gives detailed information on reflection, metadata, and dynamic
programming.