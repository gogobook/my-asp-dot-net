

Dependency Injection
WHAT’S IN THIS CHAPTER?
Defining dependency injection
Using dependency injection with
Microsoft.Extensions.DependencyInjection
Working with lifetime of services
Using options and configuration to initialize services
Using DI to create platform independence for WPF, UWP, and
Xamarin
Using other dependency injection containers
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory DependencyInjection. The code for this chapter is
divided into the following major examples:
NoDI
WithDI
WithDIContainer


ServicesLifetime
DIWithOptions
DIWithConfigurations
PlatformIndependenceSample
DIWithAutofac
WHAT IS DEPENDENCY INJECTION?
Faster development cycles demand unit tests and better updatability.
Making some code changes should not result in errors in unexpected
places. Creating more modular applications where dependencies are
reduced helps with that.
Dependency injection (DI) allows injection dependencies from the
outside of a class, thus the class where the dependency is injected only
needs to know about a contract (usually a C# interface). The class can
be independent of the creation of its objects.
Dependency injection allows for easier unit tests. With the unit test,
only a specific class needs testing, and the dependencies needed can be
replaced by a special mock class that contains test data.
You can also use different implementations to differentiate between
production mode and development mode. For example, in production
you might need to access an SAP server, or you might need to
authenticate with a specific active directory that is not accessible for all
developers. During development, during every debug session you don’t
want to wait to have a successful authentication, and you don’t need
the SAP server to develop the user interface. Here you can have——for
the same contract——different implementations where authentication is
simulated, and you can work with test data instead of accessing the
SAP server.
You can also use different implementations with different platforms.
You can, for example, create a .NET Standard library where all the
common functionality is implemented for UWP, WPF, and Xamarin
applications, and you can redirect to platform-specific code as needed.


Dependency injection also enables you to replace standard
functionality with custom features. ASP.NET Core and Entity
Framework Core is heavily based on dependency injection. These
technologies use hundreds of contracts——for example, to find a
controller, to map a HTTP request to a controller, to convert data
received to a parameter, to map a database table to an entity type, and
so on. You easily can replace the custom functionality by using a
different implementation.
DI is the core pattern of agile software development and continuous
software delivery practices.
A dependency injection container is not required with dependency
injection, but it helps for managing the dependencies. As soon as you
have a growing list of services managed by the dependency injection
container, you can see its advantages. ASP.NET Core and Entity
Framework Core use Microsoft.Extensions.DependencyInjection as a
container to manage all the dependencies to manage hundreds of
services.
Although dependency injection and dependency injection containers
increase the complexity in very small applications, as soon as your
application grows larger and needs multiple services, dependency
injection reduces the complexity and fosters implementations that are
not tightly bound.
This chapter starts with a small application that doesn’t use
dependency injection; in subsequent examples it turns into an
application that does use dependency injection and uses a dependency
injection container. This chapter also covers lifetime management and
configuration of services. In the last sections of this chapter you see
how you can use dependency injection to cover platform-specific
services with WPF, UWP, and Xamarin. Finally, the chapter discusses
integrating third-party containers with
Microsoft.Extensions.DependencyInjection .
Using a Service Without Dependency Injection
Let’s start an example without using dependency injection; later we’ll
change it to use dependency injection. The service implementation


that is used is defined in the class GreetingService . This class defines
the method Greet that returns a string (code file
NoDI/GreetingService.cs ):
public class GreetingService
{
public string Greet(string name) => $"Hello, {name}";
}
The class HomeController makes use of this service. In the Hello
method, the GreetingService is instantiated, and the Greet method is
invoked (code file NoDI/HomeController.cs ):
public class HomeController
{
public string Hello(string name)
{
var service = new GreetingService();
return service.Greet(name);
}
}
Let’s have a look at the Main method of the Program class. Here, the
HomeController is instantiated, the Hello method invoked, and the
result is written to the console (code file NoDI/Program.cs ):
static void Main()
{
var controller = new HomeController();
string result = controller.Hello("Stephanie");
Console.WriteLine(result);
}
The program is working, and Hello, Stephanie is written to the
console. What are the issues with that?
The HomeController and GreetingService are tightly coupled. It’s not
easy to replace the GreetingService in the HomeController for a
different implementation. This GreetingService is a simple one that
returns a string . In normal applications, you typically have a more
complex scenario——for example, the GreetingService might access an
API service using HTTP requests, or it might access the database using
Entity Framework. You might want to change the service used in one


place instead of finding all the places where the service is used.
Also, when you create a unit test for the HomeController , the
GreetingService is tested as well. With a unit test, you want to test just
the functionality of the methods of a single class without using other
dependencies. In the HomeController , the GreetingService cannot be
easily replaced for unit tests. Technically it’s possible to make
replacements of the internal implementation of the GreetingService
method for unit tests. With the Microsoft Fakes framework, it is
possible to change the implementation of the method by replacing
specific methods and properties of the GreetingService class. This
change is defined with the unit test and happens only when the unit
test runs: “faking” the original method by a different one. There are
better ways to do this: by using dependency injection.
In the next section, you see how to change this implementation to use
dependency injection.
**NOTE**
Entity Framework Core is covered in detail in Chapter 26, “Entity
Framework Core.” Check Chapter 28, “Testing,” for more
information on unit testing. API services are explained in Chapter
32, “ASP.NET Web API.”
Using Dependency Injection
Let’s make the HomeController independent of the implementation of
the GreetingService . You can do this by creating the interface
IGreetingService that defines the functionality needed by the
HomeController (code file WithDI/IGreetingService.cs ):
public interface IGreetingService
{
string Greet(string name);
}
GreetingService
now implements the interface IGreetingService (code


file WithDI/GreetingService.cs ):
public class GreetingService : IGreetingService
{
public string Greet(string name) => $"Hello, {name}";
}
All the HomeController now needs is a reference to an object that
implements the interface IGreetingService . This is injected with the
constructor of the HomeController , assigned to the private field, and
used with the method Hello (code file WithDI/HomeController.cs ):
public class HomeController
{
private readonly IGreetingService _greetingService;
public HomeController(IGreetingService greetingService)
{
_greetingService = greetingService ??
throw new
ArgumentNullException(nameof(greetingService));
}
public string Hello(string name) =>
_greetingService.Greet(name);
}
With this implementation, the HomeController makes use of the
inversion of control design principle. The HomeController doesn’t
instantiate the GreetingService like it did before. Instead, the control
to define the concrete class that is used by the HomeController is given
to the outside; in other words, the control is inversed.
**NOTE**
Inversion of control is also known as the Hollywood principle:
Don’t call us; we call you.
Inversion of control also reduces the dependencies on different
technologies and creates more common code. For example, you
can use the same view-models and service contracts from WPF,
UWP, and Xamarin applications in a common .NET Standard


library. Some services need to be implemented differently with
WPF, UWP, and Xamarin. The implementation for such services
can come from the hosting application, whereas the contract is
defined and used in a .NET Standard library. Read Chapter 34,
“Patterns with XAML Apps,” for more information on view-
models.
The class HomeController doesn’t have a dependency on the
implementation of a concrete implementation of the IGreetingService
interface. The HomeController can use any class that implements the
interface IGreetingService . The class just needs to implement all
members of this interface. Now, the dependency needs to be injected
from the outside, passing a concrete implementation to the
constructor of the HelloController class. With the sample code, the
inversion of control design principle is implemented using the
dependency injection pattern with constructor injection. It’s called
constructor injection because the interface is injected in the
constructor. The dependency needs to be injected to create a
HomeController instance.
Let’s change the Main method to pass a concrete implementation of the
IGreetingService to the HomeController . Here, the dependency is
injected (code file WithDI/Program.cs ):
static void Main()
{
var controller = new HomeController(new GreetingService());
string result = controller.Hello("Matthias");
Console.WriteLine(result);
}
Creating a unit test for the Hello method of the HomeController , a
different implementation can be injected——for example, a
MockGreetingService implementing IGreetingService .
The sample application is currently very small. The only thing that
needs to be injected is a single concrete class that implements a
contract. This class is instantiated at the same time you instantiate the
HomeController . In real applications, you need to deal with many
interfaces and implementations, and you also need to share instances.


A simple way for doing this is to use a dependency injection container
that manages all the dependencies. In the next section, the application
is changed to use the Microsoft.Extensions.DependencyInjection
container.
USING THE .NET CORE DI CONTAINER
With a dependency injection container, you can have one place in your
application where you define what contracts map to which specific
implementation, and you also can specify if a service should be used as
a singleton, or a new instance should be created every time it’s used.
In the next sample, let’s use the previously created GreetingService to
implement IGreetingService as well as the HomeController class, but
this time we use a dependency injection container.
The sample WithDIContainer makes use of these NuGet packages and
namespaces:
Packages
Microsoft.Extensions.DependencyInjection
Namespaces
System
Microsoft.Extensions.DependencyInjection
Within the Program class, now the RegisterServices method is defined.
Here, a new ServiceCollection object is instantiated.
ServiceCollection is defined in the namespace
Microsoft.Extensions.DependencyInjection after you add the NuGet
package Microsoft.Extensions.DependencyInjection . When you use
AddSingleton and AddTransient , extension methods to the
ServiceCollection are used to register the types that need to be known
by the DI container. With the sample application, both the
GreetingService and the HomeController are registered in the
container, which allows retrieving the HomeController from the
container.
The class GreetingService is instantiated when the IGreetingService


interface is requested. The HomeController itself does not implement
an interface. With this DI container configuration, the HomeController
is instantiated when the HomeController is requested. The DI container
configuration also defines the lifetime of the services. With
GreetingService , the same instance always is returned when
IGreetingService is requested. This is different with the
HomeController . With the HomeController with every request to retrieve
a HomeController , a new instance is created. The lifetime information
for the services is specified by using the AddSingleton and the
AddTransient methods. Later in this chapter, you can read more about
the lifetime of these services.
Invoking the method BuildServiceProvider returns a ServiceProvider
object that can then be used to access the services registered (code file
WithDIContainer/Program.cs ):
static ServiceProvider RegisterServices()
{
var services = new ServiceCollection();
services.AddSingleton<IGreetingService, GreetingService>();
services.AddTransient<HomeController>();
return services.BuildServiceProvider();
}
**NOTE**
With .NET Core 1.1, the BuildServiceProvider returned the
interface IServiceProvider instead of returning the concrete class
ServiceProvider . With .NET Core 1.1, ServiceProvider was
declared internal and thus could be used from the outside only via
its public interface IServiceProvider . The implementation
changed with .NET Core 2.0 to make the ServiceProvider class
public, and to change the method declaration of
BuildServiceProvider to return ServiceProvider . This allows
directly accessing the Dispose method of the ServiceProvider
without the need to cast the returned object to IDisposable to
invoke Dispose .


**NOTE**
In case you add the same interface contract multiple times to the
services collection, the last one added wins on getting the
interface from the container. This makes it easy to replace
contracts with different implementations if you need some other
functionality, such as with services implemented by ASP.NET
Core or Entity Framework Core.
On the other hand, with the ServiceCollection class you also have
access to remove services and to retrieve a list of all services for a
specific contract.
Next, let’s change the Main method to invoke the RegisterServices
method for making the registration within the DI container and then
to invoke the GetRequiredService method of the ServiceProvider to get
a reference to a HomeController instance (code file
WithDIContainer/Program.cs ):
static void Main()
{
using (ServiceProvider container = RegisterServices())
{
var controller =
container.GetRequiredService<HomeController>();
string result = controller.Hello("Katharina");
Console.WriteLine(result);
}
}
**NOTE**
With the ServiceProvider class, different overloads of GetService
and GetRequiredService exists. The method that is directly
implemented in the ServiceProvider class is GetService with a
Type parameter. The generic method GetService<T> is an extension


method that takes the generic type parameter and passes it to the
GetService method.
If the service is not available in the container, GetService returns
null . The extension method GetRequiredService checks for a null
result and throws an InvalidOperationException in case the
service is not found. In case the service provider implements the
interface ISupportsRequiredService , the extension method
GetRequiredService invokes the GetRequiredService of the
provider. The container of .NET Core 2.0 does not implement this
interface, but some third-party containers do.
When you start the application, on the request of the
GetRequiredService method, the DI container creates an instance of
the HomeController class. The HomeController constructor requires an
object implementing IGreetingService . This interface is also
registered with the container; for IGreetingService a GreetingService
object needs to be returned. The GreetingService class has a default
constructor, so the container can create an instance and pass this
instance to the constructor of the HomeController . This instance is used
with the controller variable, and it’s used as before to invoke the Hello
method.
What happens if not every dependency is registered with the DI
container? To see this in action, you can remove the configuration of
the IGreetingService with the DI container. In that case, the container
throws the InvalidOperationException . This error message is shown:
Unable to resolve service for type
'WithDIContainer.IGreetingService' while attempting to activate
'WithDIContainer.HomeController'.
LIFETIME OF SERVICES
The lifetime of services defines how long a service instance exists.
Does it exist for the lifetime of the application? Is a new instance
created on every request? There’s also something in-between, as you
will see here.
Registering a service as a singleton always returns the same instance,


and registering a service as transient returns a new object every time
the service is injected. There are more options available, and more
issues to think about. Let’s start with another example showing the
lifetime features and issues. The example also implements the
IDisposable interface with the services, so you can see how this is dealt
with.
The sample ServicesLifetime makes use of the following NuGet
package and namespaces:
Package
Microsoft.Extensions.DependencyInjection
Namespaces
System
Microsoft.Extensions.DependencyInjection
To easily differentiate between different instances, every service
instantiated will be given a different number. The number is created
from a shared service. This shared service defines a simple interface
INumberService to return a number (code file
ServicesLifetime/INumberService.cs ):
public interface INumberService
{
int GetNumber();
}
The implementation of INumberService always returns a new number
in the GetNumber method. This service will be registered as a singleton
to have the number shared between the other services (code file
ServicesLifetime/NumberService.cs ):
public class NumberService : INumberService
{
private int _number = 0;
public int GetNumber() => Interlocked.Increment(ref
_number);
}
The other services that will be looked at are defined by the interface
contracts IServiceA , IServiceB , and IServiceC with the corresponding


methods A , B , and C . The following code snippet shows the contract for
IServiceA (code file ServicesLifetime/IServiceA.cs ):
public interface IServiceA
{
void A();
}
With the implementation of ServiceA , the constructor needs injection
of the INumberService . With this service, the number is retrieved to
assign it to the private field _n . With the implementation of the
constructor, the method A , and the Dispose method that implements
the IDisposable interface, console output is written, so you can see
lifetime information (code file ServicesLifetime/ServiceA.cs ):
public class ServiceA : IServiceA, IDisposable
{
private int _n;
public ServiceA(INumberService numberService)
{
_n = numberService.GetNumber();
Console.WriteLine($"ctor {nameof(ServiceA)}, {_n}");
}
public void A() => Console.WriteLine($"{nameof(A)}, {_n}");
public void Dispose() =>
Console.WriteLine($"disposing {nameof(ServiceA)}, {_n}");
}
**NOTE**
The IDiposable interface is explained in detail in Chapter 17,
“Managed and Unmanaged Memory.”
In addition to the services, the controller ControllerX is implemented.
ControllerX requires constructor injection of three services: IServiceA ,
IServiceB , and INumberService . With the method M , two of the injected
services are invoked. Also, constructor and Dispose information is
written to the console (code file ServicesLifetime/ControllerX.cs ):


public class ControllerX : IDisposable
{
private readonly IServiceA _serviceA;
private readonly IServiceB _serviceB;
private readonly int _n;
private int _countm = 0;
public ControllerX(IServiceA serviceA, IServiceB serviceB,
INumberService numberService)
{
_n = numberService.GetNumber();
Console.WriteLine($"ctor {nameof(ControllerX)}, {_n}");
_serviceA = serviceA;
_serviceB = serviceB;
}
public void M()
{
Console.WriteLine($"invoked {nameof(M)} for the
{++_countm}. time");
_serviceA.A();
_serviceB.B();
}
public void Dispose() => Console.WriteLine(
$"disposing {nameof(ControllerX)}, {_n}");
}
Using Singleton and Transient Services
Let’s start registering singleton and transient services.
RegisterServices is implemented as a local function within the
method SingletonAndTransient . Here, the services ServiceA , ServiceB ,
and NumberService and the controller class ControllerX are registered.
The NumberService needs to be registered as a singleton to have shared
state. ServiceA is registered as a singleton as well. ServiceB and
ControllerX are registered transient (code file
ServicesLifetime/Program.cs ):
private static void SingletonAndTransient()
{
Console.WriteLine(nameof(SingletonAndTransient));
ServiceProvider RegisterServices()
{


IServiceCollection services = new ServiceCollection();
services.AddSingleton<IServiceA, ServiceA>();
services.AddTransient<IServiceB, ServiceB>();
services.AddTransient<ControllerX>();
services.AddSingleton<INumberService, NumberService>();
return services.BuildServiceProvider();
}
//...
}
and AddTransient are extension methods that make it
easier to register services with the
Microsoft.Extensions.DependencyInjection framework. Instead of
using these helpful methods, you can also register services with the Add
method (which is itself invoked by the convenient methods). The Add
method requires a ServiceDescriptor that contains the service type,
the implementation type, and the kind of the service. The kind of the
service is specified using the ServiceLifetime enum type.
ServiceLifetime defines the values Singleton , Transient , and Scoped :
AddSingleton
services.Add(new ServiceDescriptor(typeof(ControllerX),
typeof(ControllerX), ServiceLifetime.Transient));
**NOTE**
The Add method of the ServiceCollection class is explicitly
implemented for the interface IServiceCollection . With this, you
can see the method only when you use the interface
IServiceCollection and not when you have a variable of the
ServiceCollection type. Explicit interface implementation is
covered in Chapter 4, “Object-Oriented Programming with C#.”
The local function RegisterServices method is invoked to retrieve the
ServiceProvider , get the ControllerX two times, and invoke the
method M before the ServiceProvider gets disposed (code file
ServicesLifetime/Program.cs ):
private static void SingletonAndTransient()
{


//...
using (ServiceProvider container = RegisterServices())
{
ControllerX x = container.GetRequiredService<ControllerX>
();
x.M();
x.M();
Console.WriteLine($"requesting {nameof(ControllerX)}");
ControllerX x2 =
container.GetRequiredService<ControllerX>();
x2.M();
Console.WriteLine();
}
}
**NOTE**
Local functions are explained in Chapter 13, “Functional
Programming with C#.”
When you run the application, you can see when the ControllerX is
requested, ServiceA and ServiceB are instantiated, and the
NumberService returns a new number every time the GetNumber method
is invoked. When the ControllerX is requested the second time, not
only is the ControllerX newly created but also ServiceB is created and
is registered transient. With ServiceB , the same instance is used as
before, and no new instance is created:
SingletonAndTransient
requesting ControllerX
ctor ServiceA, 1
ctor ServiceB, 2
ctor ControllerX, 3
invoked M for the 1. time
A, 1
B, 2
invoked M for the 2. time
A, 1
B, 2
requesting ControllerX


ctor ServiceB, 4
ctor ControllerX, 5
invoked M for the 1. time
A, 1
B, 4
disposing
disposing
disposing
disposing
disposing
ControllerX, 5
ServiceB, 4
ControllerX, 3
ServiceB, 2
ServiceA, 1
Using Scoped Services
Services can also be registered within a scope. This is something in-
between transient and singleton. With singleton, only a single instance
is created. Transient creates a new instance every time the service is
requested from the container. With scoped, always the same instance
is returned from the same scope, but from a different scope a different
instance is returned. Scopes are by default defined with ASP.NET Core
web applications. Here, the scope is a HTTP Web request. With the
scoped service, the same instance is returned if the request to the
container is coming from the same HTTP request. With different
HTTP requests, other instances are returned. This allows for easily
sharing state inside an HTTP request.
With non-ASP.NET Core web applications you need to create the
scope for yourself to get advantages of scoped services.
Let’s start registering services with the local function
RegisterServices . ServiceA is registered as a scoped service, ServiceB
as singleton, and ServiceC as transient (code file
ServicesLifetime/Program.cs ):
private static void UsingScoped()
{
Console.WriteLine(nameof(UsingScoped));
ServiceProvider RegisterServices()
{
var services = new ServiceCollection();
services.AddSingleton<INumberService, NumberService>();
services.AddScoped<IServiceA, ServiceA>();


services.AddSingleton<IServiceB, ServiceB>();
services.AddTransient<IServiceC, ServiceC>();
return services.BuildServiceProvider();
}
//...
}
You can create a scope invoking the CreateScope method of the
ServiceProvider . This returns a scope object that implements the
interface IServiceScope . From there you can access the
ServiceProvider belonging to this scope where you can request the
services from the container. With the following code snippet, ServiceA
and ServiceC are requested two times, whereas ServiceB is requested
just once. Then the methods A , B , and C are invoked:
private static void UsingScoped()
{
//...
using (ServiceProvider container = RegisterServices())
{
using (IServiceScope scope1 = container.CreateScope())
{
IServiceA a1 =
scope1.ServiceProvider.GetService<IServiceA>();
a1.A();
IServiceA a2 =
scope1.ServiceProvider.GetService<IServiceA>();
a2.A();
IServiceB b1 =
scope1.ServiceProvider.GetService<IServiceB>();
b1.B();
IServiceC c1 =
scope1.ServiceProvider.GetService<IServiceC>();
c1.C();
IServiceC c2 =
scope1.ServiceProvider.GetService<IServiceC>();
c2.C();
}
Console.WriteLine("end of scope1");
//...
}
After the first scope is disposed, another scope is created. With the
second scope, again the services ServiceA , ServiceB , and ServiceC are


requested and methods invoked:
private static void UsingScoped()
{
//...
Console.WriteLine("end of scope1");
using (IServiceScope scope2 = container.CreateScope())
{
IServiceA a3 =
scope2.ServiceProvider.GetService<IServiceA>();
a3.A();
IServiceB b2 =
scope2.ServiceProvider.GetService<IServiceB>();
b2.B();
IServiceC c3 =
scope2.ServiceProvider.GetService<IServiceC>();
c3.C();
}
Console.WriteLine("end of scope2");
Console.WriteLine();
}
When you run the application, you can see the services for the
instances are created, methods are invoked, and they’re automatically
disposed. As ServiceA is registered as scoped, within the same scope
the same instance is used. ServiceC is registered as transient, so here
an instance is created with every request to the container. At the end
of the scope, the transient and scoped services are automatically
disposed, but not ServiceB . ServiceB is registered as singleton and
thus needs to survive the end of the scope:
UsingScoped
ctor ServiceA, 1
A, 1
A, 1
ctor ServiceB, 2
B, 2
ctor ServiceC, 3
C, 3
ctor ServiceC, 4
C, 4
disposing ServiceC, 4
disposing ServiceC, 3
disposing ServiceA, 1


end of scope1
Starting the second scope, ServiceA and ServiceB are instantiated
again. When you request ServiceB , the same object previously created
is returned. At the end of the scope, ServiceA and ServiceC are
disposed again. ServiceB is disposed after disposing the root provider:
ctor ServiceA, 5
A, 5
B, 2
ctor ServiceC, 6
C, 6
disposing ServiceC, 6
disposing ServiceA, 5
end of scope2
disposing ServiceB, 2
**NOTE**
You don’t need to invoke the Dispose method on services to release
them. With services implementing the IDisposable interface, the
container invokes the Dispose method. Transient and scoped
services are disposed when the scope is disposed. Singleton
services are disposed when the root provider is disposed.
With .NET Core 2.0, the service instances are disposed in the
reverse order they have been created. This is important when one
service needs another one injected. For example, ServiceA
requires ServiceB to be injected. Thus, ServiceB is created first,
followed by ServiceA . With disposing, ServiceA is disposed first
and can still access methods from ServiceB while it’s being
disposed. This behavior is different from .NET Core 1.0 where
disposing of service instances happened in the order the service
instances were created.
Using Custom Factories


Other than defining to use transient, scoped, and singleton, you can
also create a custom factory or pass an existing instance to the
container. The following code snippet shows how you can do this.
You can pass a previously created instance to the container by using an
overload of the AddSingleton method. Here, in the RegisterServices
method, a NumberService object is created first, and then it’s passed to
the AddSingleton method. Using the GetService method, or injecting it
in the constructor, is not different from the code you’ve seen before.
You just need to be aware that the container is not responsible for
invoking the Dispose method in this case. With objects creating and
passing to the container, it’s your responsibility to dispose these
objects (if the objects need disposing at all). You also can use a factory
method that is used to create the instance instead of letting the service
be created from the container. In case the service needs a custom
initialization or defines constructors that aren’t supported by the DI
container, this is a useful option. You can pass a delegate with an
IServiceProvider parameter and return the service instance to the
AddSingleton , AddScoped , and AddTransient methods. With the sample
code, the local function named CreateServiceBFactory returns a
ServiceB object. In case the constructor of the service implementation
needs other services, these can be retrieved using the passed
IServiceProvider instance (code file ServicesLifetime/Program.cs ):
private static void CustomFactories()
{
Console.WriteLine(nameof(CustomFactories));
IServiceB CreateServiceBFactory(IServiceProvider provider)
=>
new ServiceB(provider.GetService<INumberService>());
ServiceProvider RegisterServices()
{
var numberService = new NumberService();
var services = new ServiceCollection();
services.AddSingleton<INumberService>(numberService);
add existing
//
services.AddTransient<IServiceB>(CreateServiceBFactory);
// use a factory


services.AddSingleton<IServiceA, ServiceA>();
return services.BuildServiceProvider();
}
using (ServiceProvider container = RegisterServices())
{
IServiceA a1 = container.GetService<IServiceA>();
IServiceA a2 = container.GetService<IServiceA>();
IServiceB b1 = container.GetService<IServiceB>();
IServiceB b2 = container.GetService<IServiceB>();
}
Console.WriteLine();
}
INITIALIZATION OF SERVICES USING OPTIONS
You’ve already seen that a service can be injected in another service.
This can also be used to initialize a service with options. You cannot
define non-service contracts with the constructor of a service for
initialization because the container does not know how to initialize
this. Services are needed. However, to pass options for a service, you
can also use a service that is already available with .NET Core.
The sample DIWithOptions makes use of these NuGet packages and
namespaces:
Packages
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Options
Namespaces
System
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Options
The sample code makes use of the previously used GreetingService
with modifications to pass options. The configuration values needed
by the service are defined with the class GreetingServiceOptions . The
sample code requires a string parameter with the From property (code


file DIWithOptions/GreetingServiceOptions.cs ):
public class GreetingServiceOptions
{
public string From { get; set; }
}
The options for the service can be passed by specifying a constructor
with an IOptions<T> parameter. The previously defined class
GreetingServiceOptions is the generic type used with IOptions . The
value passed to the constructor is used to initialize the field _from
(code file DIWithOptions/GreetingService.cs ):
public class GreetingService : IGreetingService
{
public GreetingService(IOptions<GreetingServiceOptions>
options) =>
_from = options.Value.From;
private readonly string _from;
public string Greet(string name) => $"Hello, {name}!
Greetings from {_from}";
}
**NOTE**
The IOptions interface and the service used with options is
implemented in the NuGet package
Microsoft.Extensions.Options .
For making it easy to register the service with the DI container, the
extension method AddGreetingService is defined. This method extends
the IServiceCollection interface and allows passing the
GreetingServiceOptions with a delegate. In the implementation, the
Configure method is used to specify the configuration with the
IOptions interface. The Configure method is an extension method for
IServiceCollection in the Microsoft.Extensions.Options NuGet
package (code file DIWithOptions/GreetingServiceExtensions.cs ):


public static class GreetingServiceExtensions
{
public static IServiceCollection AddGreetingService(
this IServiceCollection collection,
Action<GreetingServiceOptions> setupAction)
{
if (collection == null)
throw new ArgumentNullException(nameof(collection));
if (setupAction == null)
throw new ArgumentNullException(nameof(setupAction));
collection.Configure(setupAction);
return collection.AddTransient<IGreetingService,
GreetingService>();
}
}
The HomeController that makes use of the GreetingService with
constructor injection doesn’t need any change (code file
DIWithOptions/HomeController.cs ):
public class HomeController
{
private readonly IGreetingService _greetingService;
public HomeController(IGreetingService greetingService)
{
_greetingService = greetingService;
}
public string Hello(string name) =>
_greetingService.Greet(name);
}
You can now register the services with the helper method
AddGreetingService . The configuration for the GreetingService is done
here by passing the required options. What’s also needed is a service
that implements the IOptions interface. Here, an extension method
can be used as well: AddOptions . This method adds several interfaces
and maps it to implementations that are used with options (code file
DIWithOptions/Program.cs ):
static ServiceProvider RegisterServices()
{
var services = new ServiceCollection();
services.AddOptions();


services.AddGreetingService(options =>
{
options.From = "Christian";
});
services.AddTransient<HomeController>();
return services.BuildServiceProvider();
}
The service can now be used like before. The HomeController is
retrieved from the container, and constructor injection is used in the
HomeController where the IGreetingService is used:
static void Main()
{
using (var container = RegisterServices())
{
var controller = container.GetService<HomeController>();
string result = controller.Hello("Katharina");
Console.WriteLine(result);
}
}
When you run the application, now the options are used:
Hello, Katharina! Greetings from Christian
USING CONFIGURATION FILES
Options as shown in the previous section also can be used when a
service needs to be configured from a configuration file. However,
there’s a more direct way to do this: You can use the .NET
configuration features in conjunction with an extension to the options.
Options can be extended with configuration using the NuGet package
Microsoft.Extensions.Options.ConfigurationExtensions .
The sample DIWithConfiguration makes use of these NuGet packages
and namespaces:
Packages
Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.Json
Microsoft.ExtensionsDependencyInjection


Microsoft.Extensions.Options
Microsoft.Extensions.Options.ConfigurationExtensions
Namespaces
System
Microsoft.Extensions.Configuration
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Options
The sample code is based on the sample from the previous section, but
now options are extended with configuration. No change needs to be
done with the GreetingService class; it’s still initialized using the
IOptions interface. What’s changed is the AddGreetingService
extension method, which makes it easier to use the service. The second
parameter of this method is now of type IConfiguration to receive
configuration values. The config parameter is used for passing it to the
Configure extension method. The Configure extension method is
different one from the one used previously; this one is defined in the
NuGet package
Microsoft.Extensions.Options.ConfigurationExtensions (code file
DIWithConfiguration/GreetingServiceExtensions.cs ):
public static class GreetingServiceExtensions
{
public static IServiceCollection AddGreetingService(
this IServiceCollection collection, IConfiguration
config)
{
if (collection == null)
throw new ArgumentNullException(nameof(collection));
if (config == null) throw new
ArgumentNullException(nameof(config));
collection.Configure<GreetingServiceOptions>(config);
return collection.AddTransient<IGreetingService,
GreetingService>();
}
}
Configuration can be read from environmental variables, program


arguments, and from files with different formats such as XML, INI,
and JSON files. Here, the provider to read JSON configuration is used
for adding the NuGet packages Microsoft.Extensions.Configuration
and Microsoft.Extensions.Json . In the method DefineConfiguration ,
first a ConfigurationBuilder is created, and then fluent API is used to
configure the base path for the directory where the JSON file can be
read and to configure the JSON file itself. The file appsettings.json is
used to read the configuration. After the setup of the
ConfigurationBuilder , invoking the Build method returns an object
that implements IConfiguration where the configuration values can be
accessed (code file DIWithConfiguration/Program.cs ):
static void DefineConfiguration()
{
IConfigurationBuilder configBuilder = new
ConfigurationBuilder()
.SetBasePath(Directory.GetCurrentDirectory())
.AddJsonFile("appsettings.json");
Configuration = configBuilder.Build();
}
public static IConfiguration Configuration { get; set; }
The configuration file specifies the From settings for the
GreetingService configuration (configuration file
DIWithConfiguration/appsettings.json :
{
"GreetingService": {
"From": "Matthias"
}
}
**NOTE**
Read more about the .NET Configuration in Chapter 30,
“ASP.NET Core.”
The ServiceCollection is configured like it was before. The IOptions


interface needs to be specified as well. What’s different is that the new
version of the AddGreetingService extension method that passes the
IConfiguration value. This can be done by accessing the Configuration
property that’s defined previously to read the section GreetingService ,
which passes the values that contain this section (code file
DIWithConfiguration/Program.cs ):
static ServiceProvider RegisterServices()
{
var services = new ServiceCollection();
services.AddOptions();
services.AddSingleton<IGreetingService, GreetingService>();
services.AddGreetingService(
Configuration.GetSection("GreetingService"));
services.AddTransient<HomeController>();
return services.BuildServiceProvider();
}
Before registering the services, the configuration needs to be specified.
You do this in the Main method as shown. When you run the
application, it behaves like it did before, but the configuration comes
from a file:
static void Main()
{
DefineConfiguration();
var container = RegisterServices();
var controller = container.GetService<HomeController>();
string result = controller.Hello("Katharina");
Console.WriteLine(result);
}
CREATING PLATFORM INDEPENDENCE
Dependency injection also can be used to use platform-specific
features from platform-independent libraries. For example, you can
create a .NET Standard Library that is used from WPF, UWP, and
Xamarin applications, and it makes calls into platform-specific APIs.
Calling a Web API can be implemented so it’s completely platform
independent. Doing such simple things like opening a message dialog
is platform specific.


**NOTE**
You can read more about the MVVM pattern in Chapter 34,
“Patterns with XAML Apps.” Programming UWP applications is
covered in detail in the Chapters 33 to 36, and programming
applications with Xamarin is introduced in Chapter 37, “Xamarin
Forms.”
The next sample solution, PlatformIndependenceSample , consists of the
projects in the following table.
This is a .NET Standard library consisting of services,
service contracts, and a view-model. Because the
message service is platform specific, for this service
only a contract is defined within the library
( IMessageService ).
WPFClient
The WPF client application references the DISampleLib
and contains a reference to the NuGet package
Microsoft.Extensions.DependencyInjection . This
application defines a user interface with XAML and
makes use of the view-model and services from the
.NET Standard library. For the interface
IMessageService , the service WPFMessageService is
implemented in the WPF project.
UWPClient
The UWP client application is like the WPF
application. It just needs a different implementation of
the IMessageService : UWPMessageService .
XamarinClient With Xamarin, a Xamarin.Forms application was
created. This results in a project for Android, a project
for iOS, and a project for UWP. Common code (you
can share the user interface) is in a shared project.
With every single Xamarin.Forms project the .NET
Standard library and the NuGet package
Microsoft.Extensions.DependencyInjection need to be
referenced. The code for the user interface, the setup
DISampleLib


of the DI container, and the implementation of the
IMessageService interface—— XamarinMessageService ——is
common between UWP, Android, and iPhone in the
shared project.
**NOTE**
To have the Xamarin project templates available with Visual
Studio, you need to install the workload Mobile development with
.NET using the Visual Studio Installer. You can also use Visual
Studio for Mac. To successfully compile for iOS, you also need a
Mac.
.NET Standard Library
Let’s start with the .NET Standard library implementing services and
contracts. The interface IMessageService is a contract. This contract
defines the method ShowMessageAsync , where a pop-up window should
be shown on calling this method. As mentioned previously, creating
these dialogs is not possible from .NET Standard (code file
PlatformIndependenceSample/DISampleLib/IMessageService.cs ):
public interface IMessageService
{
Task ShowMessageAsync(string message);
}
The interface IMessageService is used in the class
ShowMessageViewModel . The object implementing this interface will be
injected with the constructor of ShowMessageViewModel . This view-
model class defines the command ShowMessageCommand that is fired
from the user interfaces of the specific platforms. On firing of this
command, the ShowMessageAsync method of the IMessageService is
invoked (code file
PlatformIndependenceSample/DISampleLib/ShowMessageViewModel.cs ):
public class ShowMessageViewModel


{
private readonly IMessageService _messageService;
public ShowMessageViewModel(IMessageService messageService)
{
_messageService = messageService ??
throw new
ArgumentNullException(nameof(messageService));
ShowMessageCommand = new RelayCommand(ShowMessage);
}
public ICommand ShowMessageCommand { get; }
public void ShowMessage()
{
_messageService.ShowMessageAsync("A message from the
view-model");
}
}
WPF Application
The first client application using this library is the WPF application.
The WPFMessageService class implements the IMessageService
interface. With WPF, dialogs can be opened using MessageBox.Show .
This class does not offer asynchronous functionality; thus, a completed
task is returned to fulfill the contract from the ShowMessageAsync
method (code file
PlatformIndependenceSample/WPFClient/WPFMessageService.cs ):
public class WPFMessageService : IMessageService
{
public Task ShowMessageAsync(string message)
{
MessageBox.Show(message);
return Task.CompletedTask;
}
}
In the App class, the DI container is created, and the services are
registered. The WPFMessageService class is mapped to the
IMessageService interface (code file
PlatformIndependenceSample/WPFClient/App.xaml.cs ):


protected override void OnStartup(StartupEventArgs e)
{
base.OnStartup(e);
RegisterServices();
}
public void RegisterServices()
{
var services = new ServiceCollection();
services.AddSingleton<IMessageService, WPFMessageService>
();
services.AddTransient<ShowMessageViewModel>();
Container = services.BuildServiceProvider();
}
public IServiceProvider Container { get; private set; }
In the code-behind file of the user interface, the ViewModel property is
set by requesting ShowMessageViewModel from the container (code file
PlatformIndependenceSample/WPFClient/MainWindow.xaml.cs ):
public MainWindow()
{
InitializeComponent();
ViewModel = (Application.Current as App)
.Container.GetService<ShowMessageViewModel>();
this.DataContext = this;
}
public ShowMessageViewModel ViewModel { get; }
With the XAML code, the Button element defines a Command property
that binds to the ShowMessageCommand of the view-model (XAML file
PlatformIndependenceSample/WPFClient/MainWindow.xaml ):
<Button Content="Click Me!"
Command="{Binding ViewModel.ShowMessageCommand,
Mode=OneTime}" />
When you run the application, clicking the button invokes the
command in the view-model that is requested from the container, and
the command handler invokes a service that in turn is implemented
with the WPF application to show the MessageBox shown in Figure 20-
1.


FIGURE 20-1
UWP Application
The UWP application is very similar to the WPF application, but there
are some important differences. The first one shows up with the
UWPMessageService class; to show a dialog, the MessageDialog class is
used. This class offers the async method ShowAsync (code file
PlatformIndependenceSample/UWPClient/UWPMessageService.cs ):
public class UWPMessageService : IMessageService
{
public async Task ShowMessageAsync(string message) =>
await new MessageDialog(message).ShowAsync();
}
The DI container is filled in the same way except that the
UWPMessageSerivce is now used to fulfill the contract for the
IMessageService interface (code file
PlatformIndependenceSample/UWPClient/App.xaml.cs ):
public void RegisterServices()
{
var services = new ServiceCollection();
services.AddSingleton<IMessageService, UWPMessageService>


();
services.AddTransient<ShowMessageViewModel>();
Container = services.BuildServiceProvider();
}
public IServiceProvider Container { get; private set; }
Requesting the view-model from the container is done in the same way
as with WPF (code file
PlatformIndependenceSample/UWPClient/MainPage.xaml.cs ):
public MainPage()
{
this.InitializeComponent();
ViewModel = (Application.Current as App)
.Container.GetService<ShowMessageViewModel>();
}
public ShowMessageViewModel ViewModel { get; }
Another difference with UWP is the use of compiled binding, but this
is not really related to dependency injection (XAML file
PlatformIndependenceSample/UWPClient/MainPage.xaml ):
<Button Content="Click Me!"
Command="{x:Bind ViewModel.ShowMessageCommand,
Mode=OneTime}" />
When you run the application, you can see the same behavior, but with
UWP user interfaces (Figure 20-2).


FIGURE 20-2
Xamarin Application
When you implement the same features with a Xamarin.Forms
application, there’s another interesting approach with dependency
injection. With Xamarin.Forms, the method to show a message dialog
requires a Page object, so the XamarinMessageService that’s
implementing IMessageService needs to be configured for receiving a
Page object. It’s not possible to change the IMessageService , as the Page
type is not available with a .NET Standard library. It’s also not possible
to use an extra configuration property with the XamarinMessageService
class, as this class is instantiated from the view-model type that is also
implemented in the .NET Standard library. A good approach is to add
another service with a service contract that is only used within
Xamarin.Forms application. The XamarinMessageService constructor
demands an object implementing the IPageService interface. This
service is then used to retrieve the Page, and with this the
DisplayAlert method can be invoked (code file
PlatformIndependenceSample/XamarinClient/XamarinMessageService.cs ):
public class XamarinMessageService : IMessageService
{
private readonly IPageService _pageService;
public XamarinMessageService(IPageService pageService)
{


_pageService = pageService;
}
public Task ShowMessageAsync(string message)
{
return _pageService.Page.DisplayAlert("Message", message,
"Close");
}
}
The contract IPageService just defines a Page property as needed for
the dialog (code file
PlatformIndependenceSample/XamarinClient/IPageService.cs ):
public interface IPageService
{
Page Page { get; set; }
}
The implementation of the IPageService is just a simple auto-property
(code file
PlatformIndependenceSample/XamarinClient/PageService.cs ):
public class PageService : IPageService
{
public Page Page { get; set; }
}
The container is created in the App class. This time, the
XamarinMessageSerivce is mapped as implementation for the
IMessageService contract, and IPageService needs to be listed, too
(code file PlatformIndependenceSample/XamarinClient/App.xaml.cs ):
public App()
{
InitializeComponent();
RegisterServices();
MainPage = new XamarinClient.MainPage();
}
public void RegisterServices()
{
var services = new ServiceCollection();
services.AddSingleton<IPageService, PageService>();


services.AddSingleton<IMessageService,
XamarinMessageService>();
services.AddTransient<ShowMessageViewModel>();
Container = services.BuildServiceProvider();
}
public IServiceProvider Container { get; private set; }
In the code-behind file, the Page property needs to be associated with
the PageService (code file
PlatformIndependenceSample/XamarinClient/MainPage.xaml.cs ):
public MainPage()
{
InitializeComponent();
IServiceProvider container = (Application.Current as
App).Container;
ViewModel = container.GetService<ShowMessageViewModel>();
this.BindingContext = this;
container.GetService<IPageService>().Page = this;
}
public ShowMessageViewModel ViewModel { get; }
The XAML code looks like the previous samples (XAML file
PlatformIndependenceSample/XamarinClient/MainPage.xaml ):
<Button Text="Click Me!"
Command="{Binding ViewModel.ShowMessageCommand,
Mode=OneWay}" />
When you run the application, the alert message pops up, as shown in
Figure 20-3.


FIGURE 20-3
USING OTHER DI CONTAINERS
is a simple DI container;
many third-party containers offer additional functionality. For
example, Autofac allows configuration of the services in a
configuration file.
Microsoft.Extensions.DependencyInjection
While ASP.NET Core uses Microsoft.Extensions.DependencyInjection ,
you can also configure this——using an adapter——to use other third-party
dependency injection containers, such as Autofac, Rezolver, Scan,
Neleus, CuteAnt, fm, Dryloc, CuteAnt, Stashbox, and others. You just
need to add an adapter in the form of a NuGet package and make the
initialization according to the container’s needs.
The sample project DIWithAutofac uses the same GreetingService and
HomeController as implemented previously, but it uses the Autofac
dependency injection container adapter. For this, these NuGet
packages and namespaces are needed:
Packages
Autofac.Extensions.DependencyInjection
Microsoft.ExtensionsDependencyInjection


Namespaces
Autofac
Autofac.Extensions.DependencyInjection
Microsoft.Extensions.DependencyInjection
System
For using the Autofac container adapter, the services are registered in
a ServiceCollection like before. Instead of creating an
IServiceProvider , now you use a ContainerBuilder from Autofac. This
builder can be populated with the ServiceCollection that invokes the
Populate method. This is a way of adding the hundreds of ASP.NET
Core services to this container. The container also supports several
Register methods to add managed services. The Build method now
creates a container and returns it with the IContainer interface (code
file DIWithAutoFac/Program.cs ):
static IContainer RegisterServices()
{
var services = new ServiceCollection();
services.AddSingleton<IGreetingService, GreetingService>();
services.AddTransient<HomeController>();
var builder = new ContainerBuilder();
builder.Populate(services);
return builder.Build();
}
The Resolve method can now be used to resolve services from this
container. Other than this, no changes are needed. The HomeController
receives GreetingService via dependency injection (code file
DIWithAutoFac/Program.cs ):
static void Main()
{
using (IContainer container = RegisterServices())
{
var controller = container.Resolve<HomeController>();
string result = controller.Hello("Katharina");
Console.WriteLine(result);
}
}


SUMMARY
This chapter served as an introduction to dependency injection and
continued using Microsoft’s container
Microsoft.Extensions.DependencyInjection with various scenarios
including configuration via options and .NET Core configuration.
You’ve also seen how to use dependency injection with different
platforms by using platform-specific features with WPF, UWP, and
Xamarin.
This book contains several chapters in which dependency injection has
an important role. Chapter 26 shows how dependency injection is used
with Entity Framework Core, and how you can replace built-in
functionality. You can read in Chapter 28 about using dependency
injection with unit tests and mocking functionality that should not be
tested by a unit test. Chapter 30 and the chapters that follow it cover
how dependency injection is used with ASP.NET Core. You will see
hundreds of services registered in a container. Chapter 34 shows the
MVVM pattern and other patterns that are used with XAML-based
applications. Dependency injection is an important foundation in
those applications.
Chapter 21 goes into the detail of parallel programming with the Task
and Parallel classes that help you use multiple cores from the
operating system. Issues that come up when you use multiple tasks are
covered as well.