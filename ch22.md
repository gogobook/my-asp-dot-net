

Files and Streams
WHAT’S IN THIS CHAPTER?
Exploring the directory structure
Moving, copying, and deleting files and folders
Reading and writing text in files
Using streams to read and write files
Using readers and writers to read and write files
Compressing files
Monitoring file changes
Communicating using pipes
Using Windows Runtime streams
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory FilesAndStreams .
The code for this chapter is divided into the following major
examples:


DriveInformation
WorkingWithFilesAndFolders
StreamSamples
ReaderWriterSamples
CompressFileSample
FileMonitor
MemoryMappedFiles
NamedPipes
AnonymousPipes
WindowsAppEditor
INTRODUCTION
When you’re reading and writing to files and directories you can use
simple APIs, or you can use advanced ones that offer more features.
You also have to differentiate between .NET classes and functionality
offered from the Windows Runtime. From Universal Windows
Platform (UWP) Windows apps, you don’t have access to the file
system in any directory; you have access only to specific directories.
Alternatively, you can let the user pick files. This chapter covers all
these options. You’ll read and write files by using a simple API and get
into more features by using streams. You’ll use both .NET types and
types from the Windows Runtime, and you’ll mix both of these
technologies to take advantage of .NET features with the Windows
Runtime.
As you use streams, you also learn about compressing data and
sharing data between different tasks using memory mapped files and
pipes.
MANAGING THE FILE SYSTEM
The classes used to browse around the file system and perform


operations such as moving, copying, and deleting files are shown in
Figure 22-1.
FIGURE 22-1
The following list explains the function of these classes:
FileSystemInfo ——The
FileInfo
base class represents any file system object.
and File ——These classes represent a file on the file system.
and Directory ——These classes represent a folder on
the file system.
DirectoryInfo
Path ——This
class contains static members that you can use to
manipulate pathnames.
DriveInfo ——This
class provides properties and methods that
provide information about a selected drive.
**NOTE**
Directories or folders? These terms are often used
interchangeably. Directory is a classical term for a file system
object. A directory contains files and other directories. A folder
has its origin with Apple’s Lisa and is a GUI object. Often it is
associated with an icon to map to a directory.


Notice in the previous list that two classes are used to work with
folders and two classes are for working with files. Which one of these
classes you use depends largely on how many operations you need to
access that folder or file:
and File contain only static methods and are never
instantiated. You use these classes by supplying the path to the
appropriate file system object whenever you call a member
method. If you want to do only one operation on a folder or file,
using these classes is more efficient because it saves the overhead
of creating a .NET object.
Directory
DirectoryInfo and FileInfo implement roughly the same public
methods as Directory and File , as well as some public properties
and constructors, but they are stateful and the members of these
classes are not static. You need to instantiate these classes before
each instance is associated with a particular folder or file. This
means that these classes are more efficient if you are performing
multiple operations using the same object. That’s because they
read in the authentication and other information for the
appropriate file system object on construction, and then they do
not need to read that information again, no matter how many
methods and so on you call against each object (class instance). In
comparison, the corresponding stateless classes need to check the
details of the file or folder again with every method you call.
Checking Drive Information
Before working with files and folders, let’s check the drives of the
system. You use the DriveInfo class, which can perform a scan of a
system to provide a list of available drives and then dig in deeper to
provide a large amount of detail about any of the drives.
To demonstrate using the DriveInfo class, the following example
creates a simple Console application that lists information of all the
available drives on a computer.
The sample code for DriveInformation makes use of the following
namespaces:


System
System.IO
The following code snippet invokes the static method
DriveInfo.GetDrives . This method returns an array of DriveInfo
objects. With this array, every drive that is ready is accessed to write
information about the drive name, type, and format, and it also shows
size information (code file DriveInformation/Program.cs ):
DriveInfo[] drives = DriveInfo.GetDrives();
foreach (DriveInfo drive in drives)
{
if (drive.IsReady)
{
Console.WriteLine($"Drive name: {drive.Name}");
Console.WriteLine($"Format: {drive.DriveFormat}");
Console.WriteLine($"Type: {drive.DriveType}");
Console.WriteLine($"Root directory:
{drive.RootDirectory}");
Console.WriteLine($"Volume label: {drive.VolumeLabel}");
Console.WriteLine($"Free space: {drive.TotalFreeSpace}");
Console.WriteLine($"Available space:
{drive.AvailableFreeSpace}");
Console.WriteLine($"Total size: {drive.TotalSize}");
Console.WriteLine();
}
}
When I run this program on my Windows system, which doesn’t have
a DVD drive but has a solid-state disk (SSD) and a memory card, I see
this information:
Drive name: C:\
Format: NTFS
Type: Fixed
Root directory: C:\
Volume label: Windows
Free space: 289063882752
Available space: 289063882752
Total size: 509571969024
Drive name: D:\
Format: exFAT
Type: Removable
Root directory: D:\


Volume label:
Free space: 196831477760
Available space: 196831477760
Total size: 196832395264
On my Mac, drive letters are not available, but you can also see Ram
and Network types as they are accessible using File APIs on Unix-
based systems:
Drive name: /
Format: hfs
Type: Fixed
Root directory: /
Volume label: /
Free space: 170332930048
Available space: 170070786048
Total size: 249769230336
Drive name: /dev
Format: devs
Type: Ram
Root directory: /dev
Volume label: /dev
Free space: 0
Available space: 0
Total size: 184832
Drive name: /net
Format: autofs
Type: Network
Root directory: /net
Volume label: /net
Free space: 0
Available space: 0
Total size: 0
Working with the Path Class
For accessing files and directories, the names of the files and
directories need to be defined——including parent folders. When you
combine multiple folders and files using string concatenation
operators, you can easily miss a separator character or use one too
many characters. The Path class can help with this because this class
adds missing separator characters, and it also deals with different
platform requirements on Windows- and Unix-based systems.


The Path class exposes some static methods that make operations on
pathnames easier. For example, suppose that you want to display the
full pathname for a file, ReadMe.txt , in the folder D:\Projects . You
could find the path to the file using the following code:
Console.WriteLine(Path.Combine(@"D:\Projects",
"ReadMe.txt"));
Path.Combine is the method of this class that you are likely to
often, but Path also implements other methods that supply
use most
information about the path or the required format for it.
With the public fields VolumeSeparatorChar , DirectorySeparatorChar ,
AltDirectorySeparatorChar , and PathSeparator you can get the
platform-specific character that is used to separate drives, folders, and
files, and the separator of multiple paths. With Windows, these
characters are : , \ , / , and ; .
The Path class also helps with accessing the user-specific temp folder
( GetTempPath ) and creating temporary ( GetTempFileName ) and random
filenames ( GetRandomFileName ). Pay attention that the method
GetTempFileName includes the folder, whereas GetRandomFileName just
returns the filename without any folder.
The sample code for WorkingWithFilesAndDirectories makes use of the
following namespaces:
System
System.Collections.Generic
System.IO
This sample application offers several command line arguments to
start the different functionality of the program. Just start the program
without command lines or check the source code to see all the
different options.
The Environment class defines a list of special folders. The following
code snippet returns the documents folder by passing the enumeration
value SpecialFolder.MyDocuments to the GetFolderPath method (code
file WorkingWithFilesAndDirectories/Program.cs ):


private static string GetDocumentsFolder() =>
Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
is a huge enumeration that gives values for
music, pictures, program files, app data, and many other folders.
Environment.SpecialFolder
Creating Files and Folders
Now let’s get into using the File , FileInfo , Directory , and
DirectoryInfo classes. First, the method CreateAFile creates the file
Sample1.txt and adds the string Hello, World! to the file. An easy way
to create a text file is to invoke the method WriteAllText of the File
class. This method takes a filename and the string that should be
written to the file. Everything is done with a single call (code file
WorkingWithFilesAndDirectories/Program.cs ):
const string Sample1FileName = "Sample1.md";
// ...
public static void CreateAFile()
{
string fileName = Path.Combine(GetDocumentsFolder(),
Sample1FileName);
File.WriteAllText(fileName, "Hello, World!");
}
To copy a file, you can use either the Copy method of the File class or
the CopyTo method of the FileInfo class:
var file = new FileInfo(fileName1);
file.CopyTo(fileName2);
File.Copy(fileName1", fileName2);
The first code snippet using FileInfo takes slightly longer to execute
because of the need to instantiate an object named file, but it leaves
file ready for you to perform further actions on the same file. When
you use the second example, there is no need to instantiate an object
to copy the file.
You can instantiate a FileInfo or DirectoryInfo class by passing to the
constructor a string containing the path to the corresponding file
system object. You have just seen the process for a file. For a folder,


the code looks similar:
var myFolder = new DirectoryInfo(directory1);
If the path represents an object that does not exist, an exception is not
thrown at construction; instead it’s thrown the first time you call a
method that actually requires the corresponding file system object to
be there. You can find out whether the object exists and is of the
appropriate type by checking the Exists property, which is
implemented by both of these classes:
var test = new FileInfo(@"C:\Windows");
Console.WriteLine(test.Exists);
**NOTE** that for this property to return true, the corresponding file
system object must be of the appropriate type. In other words, if you
instantiate a FileInfo object by supplying the path of a folder, or you
instantiate a DirectoryInfo object by giving it the path of a file, Exists
has the value false . Most of the properties and methods of these
objects return a value if possible——they won’t necessarily throw an
exception just because the wrong type of object has been called, unless
they are asked to do something that is impossible. For example, the
preceding code snippet might first display false (because C:\Windows
is a directory), but it still displays the time the folder was created
because a directory has that information. However, if you tried to open
the directory as if it were a file, using the FileInfo.Open method, you’d
get an exception.
You move and delete files or directories using the MoveTo and Delete
methods of the FileInfo and DirectoryInfo classes. The equivalent
methods on the File and Directory classes are Move and Delete . The
FileInfo and File classes also implement the methods CopyTo and
Copy , respectively. However, no methods exist to copy complete folders
——you need to do that by copying each file in the folder.
Using all of these methods is quite intuitive. You can find detailed
descriptions in the Microsoft documentation.
Accessing and Modifying File Properties


Let’s get some information about files. You can use both the File and
FileInfo classes to access file information. The File class defines static
method, whereas the FileInfo class offers instance methods. The
following code snippet shows how to use FileInfo to retrieve multiple
information. If you instead used the File class, the access would be
slower because every access would mean a check to determine whether
the user is allowed to get this information. With the FileInfo class, the
check happens only when calling the constructor.
The sample code creates a new FileInfo object and writes the result of
the properties Name , DirectoryName , IsReadOnly , Extension , Length ,
CreationTime , LastAccessTime , and Attributes to the console (code file
WorkingWithFilesAndDirectories/Program.cs ):
private static void FileInformation(string fileName)
{
var file = new FileInfo(fileName);
Console.WriteLine($"Name: {file.Name}");
Console.WriteLine($"Directory: {file.DirectoryName}");
Console.WriteLine($"Read only: {file.IsReadOnly}");
Console.WriteLine($"Extension: {file.Extension}");
Console.WriteLine($"Length: {file.Length}");
Console.WriteLine($"Creation time: {file.CreationTime:F}");
Console.WriteLine($"Access time: {file.LastAccessTime:F}");
Console.WriteLine($"File attributes: {file.Attributes}");
}
Passing the Program.cs filename of the current directory to this
method,
FileInformation("./Program.cs");
results in this output (on my machine):
Name: Program.cs
Directory:
C:\ProCSharpSources\files\ProfessionalCSharp7\FilesAndStreams\F
ilesAndStreamsSamples\WorkingWithFilesAndDirectories
Read only: False
Extension: .cs
Length: 7637
Creation time: Friday, September 1, 2017 12:48:51 PM
Access time: Friday, September 1, 2017 4:07:12 PM


File attributes: Archive
A few of the properties of the FileInfo class cannot be set; they only
define get accessors. It’s not possible to retrieve the filename, the file
extension, and the length of the file. The creation time and last access
time can be set. The method ChangeFileProperties writes the creation
time of a file to the console and later changes the creation time to a
date in the year 2025.
private static void ChangeFileProperties()
{
string fileName = Path.Combine(GetDocumentsFolder(),
Sample1FileName);
var file = new FileInfo(fileName);
if (!file.Exists)
{
Console.WriteLine($"Create the file {Sample1FileName}
before calling this method");
Console.WriteLine("You can do this by invoking this
program with the -c argument");
return;
}
Console.WriteLine($"creation time: {file.CreationTime:F}");
file.CreationTime = new DateTime(2025, 12, 24, 15, 0, 0);
Console.WriteLine($"creation time: {file.CreationTime:F}");
}
Running the program shows the initial creation time of the file as well
as the creation time after it has been changed. Creating files in the
future (at least specifying the creation time) is possible with this
technique.
creation time: Sunday, December 20, 2015 9:41:49 AM
creation time: Wednesday, December 24, 2025 3:00:00 PM
**NOTE**
Being able to manually modify these properties might seem
strange at first, but it can be quite useful. For example, if you have
a program that effectively modifies a file by simply reading it in,
deleting it, and creating a new file with the new contents, you


would probably want to modify the creation date to match the
original creation date of the old file.
Using File to Read and Write
With File.ReadAllText and File.WriteAllText you can read and write
a file using a single string. Instead of using one string, you can also use
file operations that use a string for every line in a file as shown here.
Instead of reading all lines to a single string, a string array is returned
from the method File.ReadAllLines . With this method you can do a
different handling based on every line, but still the complete file needs
to be read into memory (code file
WorkingWithFilesAndFolders/Program.cs ):
public static void ReadingAFileLineByLine(string fileName)
{
string[] lines = File.ReadAllLines(fileName);
int i = 1;
foreach (var line in lines)
{
Console.WriteLine($"{i++}. {line}");
}
//...
}
To read line by line without needing to wait until all lines have been
read, you can use the method File.ReadLines . This method returns
IEnumerable<string> , where you can already start looping through the
file before the complete file has been read:
public static void ReadingAFileLineByLine(string fileName)
{
//...
IEnumerable<string> lines = File.ReadLines(fileName);
i = 1;
foreach (var line in lines)
{
Console.WriteLine($"{i++}. {line}");
}
}
For writing a string collection, you can use the method


File.WriteAllLines . This method accepts
IEnumerable<string> type as parameter:
a filename and an
public static void WriteAFile()
{
string fileName = Path.Combine(GetDocumentsFolder(),
"movies.txt");
string[] movies =
{
"Snow White And The Seven Dwarfs",
"Gone With The Wind",
"Casablanca",
"The Bridge On The River Kwai",
"Some Like It Hot"
};
File.WriteAllLines(fileName, movies);
}
To append strings to an existing file, you use File.AppendAllLines:
string[] moreMovies =
{
"Psycho",
"Easy Rider",
"Star Wars",
"The Matrix"
};
File.AppendAllLines(fileName, moreMovies);
ENUMERATING FILES
For working with multiple files, you can use the Directory class.
Directory defines the method GetFiles that returns a string array of all
files in the directory. The method GetDirectories returns a string
array of all directories.
All of these methods define overloads that allow passing a search
pattern and a value of the SearchOption enumeration. SearchOption
enables you to walk through all subdirectories or to stay in the top-
level directory by using the value AllDirectories or
TopDirectoriesOnly . The search pattern doesn’t allow passing regular
expressions as are discussed in Chapter 9, “Strings and Regular
Expressions”; it passes only simple expressions using * for any


characters and ? for single characters.
When you walk through a huge directory (or subdirectories), the
methods GetFiles and GetDirectories need to have the complete
result before the result is returned. An alternative is to use the
methods EnumerateDirectories and EnumerateFiles . These methods
offer the same parameters for the search pattern and options, but they
immediately start returning a result with IEnumerable<string> .
Let’s get into an example: Within a directory and all its subdirectories,
all files that end with Copy are deleted in case another file exists with
the same name and size. You can simulate this easily by selecting all
files in a folder by pressing Ctrl+A on the keyboard, entering Ctrl+C on
the keyboard for copy, and entering Ctrl+V on the keyboard while the
mouse is still in the same folder to paste. The new files have the Copy
postfix applied.
The method DeleteDuplicateFiles iterates all files in the directory that
is passed with the first argument, walking through all subdirectories
using the option SearchOption.AllDirectories . Within the foreach
statement, the current file in the iteration is compared to the file in the
previous iteration. In cases where the filename is the same and only
the Copy postfix is different, and if the size of the files is the same as
well, the copied file is deleted by invoking FileInfo.Delete (code file
WorkingWithFilesAndFolders/Program.cs ):
private void DeleteDuplicateFiles(string directory, bool
checkOnly)
{
IEnumerable<string> fileNames =
Directory.EnumerateFiles(directory,
"*", SearchOption.AllDirectories);
string previousFileName = string.Empty;
foreach (string fileName in fileNames)
{
string previousName =
Path.GetFileNameWithoutExtension(previousFileName);
if (!string.IsNullOrEmpty(previousFileName) &&
previousName.EndsWith("Copy") &&
fileName.StartsWith(previousFileName.Substring(
0, previousFileName.LastIndexOf(" - Copy"))))
{
var copiedFile = new FileInfo(previousFileName);


var originalFile = new FileInfo(fileName);
if (copiedFile.Length == originalFile.Length)
{
Console.WriteLine($"delete {copiedFile.FullName}");
if (!checkOnly)
{
copiedFile.Delete();
}
}
}
previousFileName = fileName;
}
}
WORKING WITH STREAMS
Now let’s get into more powerful options that are available when you
work with files: streams. The idea of a stream has been around for a
very long time. A stream is an object used to transfer data. The data
can be transferred in one of two directions:
If the data is being transferred from some outside source into your
program, it is called reading from the stream.
If the data is being transferred from your program to some outside
source, it is called writing to the stream.
Very often, the outside source will be a file, but that is not always the
case. Other possibilities include the following:
Reading or writing data on the network using some network
protocol, where the intention is for this data to be picked up by or
sent from another computer
Reading from or writing to a named pipe
Reading from or writing to an area of memory
Some streams allow only writing, some streams allow only reading,
and some streams allow random access. Random access enables you to
position a cursor randomly within a stream——for example, to start
reading from the start of the stream to later move to the end of the
stream, and continue with a position in the middle of the stream.


Of these examples, Microsoft has supplied a .NET class for writing to
or reading from memory: the System.IO.MemoryStream object. The
System.Net.Sockets.NetworkStream object handles network data. The
Stream class does not make any assumptions of the nature of the data
source. It can be file streams, memory streams, network streams, or
any data source you can think of.
Some streams can also be chained. For example, the DeflateStream can
be used to compress data. This stream in turn can write to the
FileStream , MemoryStream , or NetworkStream . The CryptoStream enables
you to encrypt data. It’s also possible to chain the DeflateStream to the
CryptoStream to write in turn to the FileStream .
**NOTE**
Chapter 24, “Security,” explains how you can use the
CryptoStream .
Using streams, the outside source might even be a variable within your
own code. This might sound paradoxical, but the technique of using
streams to transmit data between variables can be a useful trick for
converting data between data types. The C language used something
similar——the sprintf function——to convert between integer data types
and strings or to format strings.
The advantage of having a separate object for the transfer of data,
rather than using the FileInfo or DirectoryInfo classes to do this, is
that separating the concept of transferring data from the particular
data source makes it easier to swap data sources. Stream objects
themselves contain a lot of generic code that concerns the movement
of data between outside sources and variables in your code. By keeping
this code separate from any concept of a particular data source, you
make it easier for this code to be reused in different circumstances.
Although it’s not that easy to directly read and write to streams, you
can use readers and writers. This is another separation of concerns.
Readers and writers can read and write to streams. For example, the


and StringWriter classes are part of the same inheritance
tree as two classes that you use later to read and write text files. The
classes will almost certainly share a substantial amount of code behind
the scenes. Figure 22-2 illustrates the hierarchy of stream-related
classes in the System.IO namespace.
StringReader
FIGURE 22-2
As far as reading and writing files goes, the classes that concern us
most are the following:
FileStream ——This
class is intended for reading and writing binary
data in a file.
and StreamWriter ——These classes are designed
specifically for reading from and writing to streams offering APIs
for text formats.
StreamReader
and BinaryWriter ——These classes are designed for
reading and writing to streams offering APIs for binary data.
BinaryReader
The difference between using these classes and directly using the
underlying stream objects is that a basic stream works in bytes. For
example, suppose that as part of the process of saving some document
you want to write the contents of a variable of type long to a binary file.
Each long occupies 8 bytes, and if you use an ordinary binary stream
you would have to explicitly write each of those 8 bytes of memory.


In C# code, you would have to perform some bitwise operations to
extract each of those 8 bytes from the long value. Using a BinaryWriter
instance, you can encapsulate the entire operation in an overload of
the BinaryWriter.Write method, which takes a long as a parameter,
and which places those 8 bytes into the stream (and if the stream is
directed to a file, into the file). A corresponding BinaryReader.Read
method extracts 8 bytes from the stream and recovers the value of the
long .
Working with File Streams
Let’s get into programming streams reading and writing files. A
FileStream instance is used to read or write data to or from a file. To
construct a FileStream , you need four pieces of information:
The file you want to access.
The mode, which indicates how you want to open the file. For
example, are you intending to create a new file or open an existing
file? If you are opening an existing file, should any write operations
be interpreted as overwriting the contents of the file or appending
to the file?
The access, which indicates how you want to access the file. For
example, do you want to read from or write to the file or do both?
The share access, which specifies whether you want exclusive
access to the file. Alternatively, are you willing to have other
streams access the file simultaneously? If so, should other streams
have access to read the file, to write to it, or to do both?
The first piece of information is usually represented by a string that
contains the full pathname of the file, and this chapter considers only
those constructors that require a string here. Besides those, however,
some additional constructors take a native Windows handle to a file
instead. The remaining three pieces of information are represented by
three .NET enumerations called FileMode , FileAccess , and FileShare .
The values of these enumerations are listed in the following table and
are self-explanatory:
ENUMERATION VALUES


FileMode Append , Create , CreateNew , Open , OpenOrCreate ,
Truncate
FileAccess Read , ReadWrite ,
FileShare
or
or Write
Delete , Inheritable , None , Read , ReadWrite , or
Write
**NOTE** that in the case of FileMode , exceptions can be thrown if you
request a mode that is inconsistent with the existing status of the file.
Append , Open , and Truncate throw an exception if the file does not
already exist, and CreateNew throws an exception if it does. Create and
OpenOrCreate cope with either scenario, but Create deletes any existing
file to replace it with a new, initially empty, one. The FileAccess and
FileShare enumerations are bitwise flags, so values can be combined
with the C# bitwise OR operator, | .
Creating a FileStream
The sample code for StreamSamples makes use of the following
namespaces:
System
System.Collections.Generic
System.Globalization
System.IO
System.Linq
System.Text
System.Threading.Tasks
There are a large number of constructors for the FileStream . The
following sample uses one with four parameters (code file
StreamSamples/Program.cs ):
The filename
The FileMode enumeration with the Open value to open an existing
file


The FileAccess enumeration with the Read value to read the file
The FileShare enumeration with a Read value to allow other
programs to read but not change the file at the same time
private void ReadFileUsingFileStream(string fileName)
{
const int bufferSize = 4096;
using (var stream = new FileStream(fileName, FileMode.Open,
FileAccess.Read, FileShare.Read))
{
ShowStreamInformation(stream);
Encoding encoding = GetEncoding(stream);
//...
Instead of using the constructor of the FileStream class to create a
FileStream object, you can create a FileStream directly using the File
class with the OpenRead method. The OpenRead method opens a file
(similar to FileMode.Open ), returns a stream that can be read
( FileAccess.Read ), and also allows other processes read access
( FileShare.Read ):
using (FileStream stream = File.OpenRead(filename))
{
//...
Getting Stream Information
The Stream class defines the properties CanRead , CanWrite , CanSeek , and
CanTimeout that you can read to get information about what can be
done with a stream. For reading and writing streams, the timeout
values ReadTimeout and WriteTimeout specify timeouts in milliseconds.
Setting these values can be important in networking scenarios to make
sure the user does not have to wait too long when reading or writing
the stream fails. The Position property returns the current position of
the cursor in the stream. Every time some data is read from the
stream, the position moves to the next byte that will be read. The
sample code writes information about the stream to the console (code
file StreamSamples/Program.cs ):
private void ShowStreamInformation(Stream stream)
{
Console.WriteLine($"stream can read: {stream.CanRead}, " +


$"can write: {stream.CanWrite}, can seek:
{stream.CanSeek}, " +
$"can timeout: {stream.CanTimeout}");
Console.WriteLine($"length: {stream.Length}, position:
{stream.Position}");
if (stream.CanTimeout)
{
Console.WriteLine($"read timeout: {stream.ReadTimeout} "
+
$"write timeout: {stream.WriteTimeout} ");
}
}
When you run the program with the file stream that has been opened,
you get the following output. The position is currently 0 as read has
not yet happened:
stream can read: True, can write: False, can seek: True, can
timeout: False
length: 1113, position: 0
Analyzing Text File Encodings
With text files, the next step is to read the first bytes of the stream——the
preamble. The preamble gives information about how the file is
encoded (the text format used). This is also known as byte order mark
(BOM).
You can read a stream by using ReadByte that reads just a byte from
the stream, or the Read method that fills a byte array. With the
GetEncoding sample method, an array of 5 bytes is created, and the
byte array is filled from the Read method. The second and third
parameters specify the offset within the byte array and the count of the
number of bytes that are available to fill. The Read method returns the
number of bytes read; the stream might be smaller than the buffer. In
case no more characters are available to read, the Read method returns
0 .
The sample code analyzes the first characters of the stream to return
the detected encoding and positions the stream after the encoding
characters (code file StreamSamples/Program.cs ):
private Encoding GetEncoding(Stream stream)
{


if (!stream.CanSeek) throw new ArgumentException(
"require a stream that can seek");
Encoding encoding = Encoding.ASCII;
byte[] bom = new byte[5];
int nRead = stream.Read(bom, offset: 0, count: 5);
if (bom[0] == 0xff && bom[1] == 0xfe && bom[2] == 0 &&
bom[3] == 0)
{
Console.WriteLine("UTF-32");
stream.Seek(4, SeekOrigin.Begin);
return Encoding.UTF32;
}
else if (bom[0] == 0xff && bom[1] == 0xfe)
{
Console.WriteLine("UTF-16, little endian");
stream.Seek(2, SeekOrigin.Begin);
return Encoding.Unicode;
}
else if (bom[0] == 0xfe && bom[1] == 0xff)
{
Console.WriteLine("UTF-16, big endian");
stream.Seek(2, SeekOrigin.Begin);
return Encoding.BigEndianUnicode;
}
else if (bom[0] == 0xef && bom[1] == 0xbb && bom[2] ==
0xbf)
{
Console.WriteLine("UTF-8");
stream.Seek(3, SeekOrigin.Begin);
return Encoding.UTF8;
}
stream.Seek(0, SeekOrigin.Begin);
return encoding;
}
The start of a file can begin with the characters FF and FE. The order
of these bytes gives information about how the document is stored.
Two-byte Unicode can be stored in little or big endian. With FF
followed by FE, it’s little endian, and when FE is followed by FF, it’s
big endian. This endianness goes back to mainframes by IBM that
used big endian for byte ordering, and PDP11 systems from Digital
Equipment that used little endian. Communicating across the network
with computers that have different endianness requires changing the
order of bytes on one side. Nowadays, the Intel CPU architecture uses


little endian, and the ARM architecture allows switching between little
and big endian.
What’s the other difference between these encodings? With ASCII, 7
bits are enough for every character. Originally based on the English
alphabet, ASCII offers lowercase, uppercase, and control characters.
Extended ASCII makes use of the 8th bit to allow switching to
language-specific characters. Switching is not easy as it requires
paying attention to the code map and also does not provide enough
characters for some Asian languages. UTF-16 (Unicode Text Format)
solves this by having 16 bits for every character. Because UTF-16 is still
not enough for historical glyphs, UTF-32 uses 32 bits for every
character. Although Windows NT 3.1 switched to UTF-16 for the
default text encoding (from a Microsoft extension of ASCII before),
nowadays the most-used text format is UTF-8. With the web, UTF-8
turned out to be the most-used text format since 2007 (this
superseded ASCII, which had been the most common character
encoding before). UTF-8 uses a variable length for character
definitions. One character is defined by using between 1 and 6 bytes.
UTF-8 is detected by this character sequence at the beginning of a file:
0xEF, 0xBB, 0xBF.
Reading Streams
After opening the file and creating the stream, the file is read using the
Read method. This is repeated until the method returns 0. A string is
created using the Encoder created from the GetEncoding method
defined earlier. Do not forget to close the stream using the Dispose
method. If possible, use the using statement——as is done with this code
sample——to dispose the stream automatically (code file
StreamSamples/Program.cs ):
public static void ReadFileUsingFileStream(string fileName)
{
const int BUFFERSIZE = 256;
using (var stream = new FileStream(fileName, FileMode.Open,
FileAccess.Read, FileShare.Read))
{
ShowStreamInformation(stream);
Encoding encoding = GetEncoding(stream);


byte[] buffer = new byte[bufferSize];
bool completed = false;
do
{
int nread = stream.Read(buffer, 0, BUFFERSIZE);
if (nread == 0) completed = true;
if (nread < BUFFERSIZE)
{
Array.Clear(buffer, nread, BUFFERSIZE - nread);
}
string s = encoding.GetString(buffer, 0, nread);
Console.WriteLine($"read {nread} bytes");
Console.WriteLine(s);
} while (!completed);
}
}
Writing Streams
How streams can be written is demonstrated by writing a simple string
to a text file. To create a stream that can be written to, the
File.OpenWrite method can be used. This time a temporary filename is
created with the help of Path.GetTempFileName . The default file
extension defined by the GetTempFileName is changed to txt with
Path.ChangeExtension (code file StreamSamples/Program.cs ):
public static void WriteTextFile()
{
string tempTextFileName =
Path.ChangeExtension(Path.GetTempFileName(),
"txt");
using (FileStream stream =
File.OpenWrite(tempTextFileName))
{
//...
When you’re writing a UTF-8 file, the preamble needs to be written to
the file. This can be done by sending the 3 bytes of the UTF-8
preamble to the stream with the WriteByte method:
stream.WriteByte(0xef);
stream.WriteByte(0xbb);
stream.WriteByte(0xbf);
There’s an alternative for doing this. You don’t need to remember the


bytes to specify the encoding. The Encoding class already has this
information. The GetPreamble method returns a byte array with the
preamble for the file. This byte array is written using the Write method
of the Stream class:
byte[] preamble = Encoding.UTF8.GetPreamble();
stream.Write(preamble, 0, preamble.Length);
Now the content of the file can be written. As the Write method
requires byte arrays to write, strings need to be converted. For
converting a string to a byte array with UTF-8,
Encoding.UTF8.GetBytes does the job before the byte array is written:
string hello = "Hello, World!";
byte[] buffer = Encoding.UTF8.GetBytes(hello);
stream.Write(buffer, 0, buffer.Length);
Console.WriteLine($"file {stream.Name} written");
You can open the temporary file using an editor such as Notepad, and
it will use the correct encoding.
Copying Streams
Now let’s combine reading and writing from streams by copying the
file content. With the next code snippet, the readable stream is opened
with File.OpenRead , and the writeable stream is opened with File
.OpenWrite . A buffer is read using the Stream.Read method and written
with Stream.Write (code file StreamSamples/Program.cs ):
public static void CopyUsingStreams(string inputFile, string
outputFile)
{
const int BUFFERSIZE = 4096;
using (var inputStream = File.OpenRead(inputFile))
using (var outputStream = File.OpenWrite(outputFile))
{
byte[] buffer = new byte[BUFFERSIZE];
bool completed = false;
do
{
int nRead = inputStream.Read(buffer, 0, BUFFERSIZE);
if (nRead == 0) completed = true;
outputStream.Write(buffer, 0, nRead);


} while (!completed);
}
}
To copy a stream, it’s not necessary to write the code to read and write
a stream. Instead, you can use the CopyTo method of the Stream class,
as shown here (code file StreamSamples/Program.cs ):
public static void CopyUsingStreams2(string inputFile, string
outputFile)
{
using (var inputStream = File.OpenRead(inputFile))
using (var outputStream = File.OpenWrite(outputFile))
{
inputStream.CopyTo(outputStream);
}
}
Using Random Access to Streams
Random access to streams provides an advantage in that——even with
large files——you can access a specific position within the file in a fast
way.
To see random access in action, the following code snippet creates a
large file. This code snippet creates the file sampledata.data with
records that are all the same length and contain a number, a text, and
a random date. The number of records that is passed to the method is
created with the help of the Enumerable.Range method. The Select
method creates an anonymous type that contains Number , Text , and
Date properties. Out of these records, a string with # pre- and postfix is
created, with a fixed length for every value and a ; separator between
each value. The WriteAsync method writes the record to the stream
(code file StreamSamples/Program.cs ):
const string SampleFilePath = "./samplefile.data";
public static async Task CreateSampleFile(int nRecords)
{
FileStream stream = File.Create(SampleFilePath);
using (var writer = new StreamWriter(stream))
{
var r = new Random();
var records = Enumerable.Range(0, nRecords).Select(x =>


new
{
Number = x,
Text = $"Sample text {r.Next(200)}",
Date = new DateTime(Math.Abs((long)((r.NextDouble() * 2
- 1) *
DateTime.MaxValue.Ticks)))
});
foreach (var rec in records)
{
string date = rec.Date.ToString("d",
CultureInfo.InvariantCulture);
string s =
$"#{rec.Number,8};{rec.Text,-20};{date}#
{Environment.NewLine}";
await writer.WriteAsync(s);
}
}
}
**NOTE**
Chapter 17, “Managed and Unmanaged Memory,” explains that
every object implementing IDisposable should be disposed. In the
previous code snippet, it looks like FileStream is not disposed.
However, that’s not the case. The StreamWriter takes control over
the used resource and disposes the stream when the StreamWriter
is disposed. To keep the stream opened for a longer period than
the StreamWriter , you can configure this with the constructor of
the StreamWriter . In that case, you need to dispose the stream
explicitly.
Now let’s position a cursor randomly within the stream to read
different records. The user is asked to enter a record number that
should be accessed. The byte in the stream that should be accessed is
based on the record number and the record size. The Seek method of
the Stream class now enables you to position the cursor within the
stream. The second argument specifies whether the position is based
on the beginning of the stream, the end of the stream, or the current


position (code file StreamSamples/Program.cs ):
public static void RandomAccessSample()
{
try
{
using (FileStream stream = File.OpenRead(SampleFilePath))
{
byte[] buffer = new byte[RECORDSIZE];
do
{
try
{
Console.Write("record number (or 'bye' to end): ");
string line = Console.ReadLine();
if (line.ToUpper().CompareTo("BYE") == 0) break;
if (int.TryParse(line, out int record))
{
stream.Seek((record - 1) * RECORDSIZE,
SeekOrigin.Begin);
stream.Read(buffer, 0, RECORDSIZE);
string s = Encoding.UTF8.GetString(buffer);
Console.WriteLine($"record: {s}");
}
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
} while (true);
Console.WriteLine("finished");
}
}
catch (FileNotFoundException)
{
Console.WriteLine("Create the sample file using the
option -sample first");
}
}
With this you can experiment with creating a file with 1.5 million
records or more. A file this size is slow when you open it using
Notepad, but it is extremely fast when you use random access.
Depending on your system and the CPU and disk type, you might use
higher or lower values for the tests.


**NOTE**
In case the records that should be accessed are not fixed size, it
still can be useful to use random access for large files. One way to
deal with this is to write the position of the records to the
beginning of the file. Another option is to read a larger block
where the record could be and find the record identifier and the
record limiters within the memory block.
Using Buffered Streams
For performance reasons, when you read or write to or from a file, the
output is buffered. This means that if your program asks for the next 2
bytes of a file stream, and the stream passes the request on to
Windows, then Windows will not connect to the file system and then
locate and read the file off the disk just to get 2 bytes. Instead,
Windows retrieves a large block of the file at one time and stores this
block in an area of memory known as a buffer. Subsequent requests
for data from the stream are satisfied from the buffer until the buffer
runs out, at which point Windows grabs another block of data from the
file.
Writing to files works in the same way. For files, this is done
automatically by the operating system, but you might have to write a
stream class to read from some other device that is not buffered. If so,
you can create a BufferedStream , which implements a buffer itself, and
pass the stream that should be buffered to the constructor. **NOTE**,
however, that BufferedStream is not designed for the situation in which
an application frequently alternates between reading and writing data.
USING READERS AND WRITERS
Reading and writing text files using the FileStream class requires
working with byte arrays and dealing with the encoding as described
in the previous section. There’s an easier way to do this: using readers
and writers. You can use the StreamReader and StreamWriter classes to


read and write to the FileStream , and you have an easier job not
dealing with byte arrays and encodings.
That’s because these classes work at a slightly higher level and are
specifically geared to reading and writing text. The methods that they
implement can automatically detect convenient points to stop reading
text, based on the contents of the stream. In particular:
These classes implement methods to read or write one line of text
at a time: StreamReader.ReadLine and StreamWriter.WriteLine . In
the case of reading, this means that the stream automatically
determines where the next carriage return is and stops reading at
that point. In the case of writing, it means that the stream
automatically appends the carriage return–line feed combination
to the text that it writes out.
By using the StreamReader and StreamWriter classes, you don’t need
to worry about the encoding used in the file.
The sample code for ReaderWriterSamples makes use of the following
namespaces:
System
System.Collections.Generic
System.Globalization
System.IO
System.Linq
System.Text
System.Threading.Tasks
The StreamReader Class
Let’s start with the StreamReader by converting the previous example
to read a file to use the StreamReader . It looks a lot easier now. The
constructor of the StreamReader receives the FileStream . You can check
for the end of the file by using the EndOfStream property, and you read
lines using the ReadLine method (code file


ReaderWriterSamples/Program.cs ):
public static void ReadFileUsingReader(string fileName)
{
var stream = new FileStream(fileName, FileMode.Open,
FileAccess.Read,
FileShare.Read);
using (var reader = new StreamReader(stream))
{
while (!reader.EndOfStream)
{
string line = reader.ReadLine();
Console.WriteLine(line);
}
}
}
It’s no longer necessary to deal with byte arrays and the encoding.
However, pay attention; the StreamReader by default uses the UTF-8
encoding. You can let the StreamReader use the encoding as it is
defined by the preamble in the file by specifying a different
constructor:
var reader = new StreamReader(stream,
detectEncodingFromByteOrderMarks: true);
You can also explicitly specify the encoding:
var reader = new StreamReader(stream, Encoding.Unicode);
Other constructors enable you to set the buffer to be used; the default
is 1024 bytes. Also, you can specify that the underlying stream should
not be closed on closing the reader. By default, when the reader is
closed (using the Dispose method), the underlying stream is closed as
well.
Instead of explicitly instantiating a new StreamReader , you can create a
StreamReader by using the OpenText method of the File class:
var reader = File.OpenText(fileName);
With the code snippet to read the file, the file was read line by line
using the ReadLine method. The StreamReader also allows reading the
complete file from the position of the cursor in the stream using


ReadToEnd :
string content = reader.ReadToEnd();
The StreamReader also allows the content to read to a char array. This
is similar to the Read method of the Stream class; it doesn’t read to a
byte array but instead to a char array. Remember, the char type uses
two bytes. This is perfect for 16-bit Unicode, but is not as useful with
UTF-8 where a single character can be between one and six bytes long:
int nChars = 100;
char[] charArray = new char[nChars];
int nCharsRead = reader.Read(charArray, 0, nChars);
The StreamWriter Class
The StreamWriter works in the same way as the StreamReader , except
that you use StreamWriter only to write to a file (or to another stream).
The following code snippet shows creating a StreamWriter passing a
FileStream . Then a passed string array is written to the stream (code
file ReaderWriterSamples/Program.cs ):
public static void WriteFileUsingWriter(string fileName,
string[] lines)
{
var outputStream = File.OpenWrite(fileName);
using (var writer = new StreamWriter(outputStream))
{
byte[] preamble = Encoding.UTF8.GetPreamble();
outputStream.Write(preamble, 0, preamble.Length);
writer.Write(lines);
}
}
Remember that the StreamWriter is using the UTF-8 format by default
to write the text content. You can define alternative contents by setting
an Encoding object in the constructor. Also, similarly to the constructor
of the StreamReader , the StreamWriter allows specifying the buffer size
and whether the underlying stream should not be closed on closing of
the writer.
The Write method of the StreamWriter defines 17 overloads that allow
passing strings and several .NET data types. Using the methods


passing the .NET data types, remember that all these are changed to
strings with the specified encoding. To write the data types in binary
format, you can use the BinaryWriter that’s shown next.
Reading and Writing Binary Files
To read and write binary files, one option is to directly use the stream
types; in this case, it’s good to use byte arrays for reading and writing.
Another option is to use readers and writers defined for this scenario:
BinaryReader and BinaryWriter . You use them similarly to the way you
use StreamReader and StreamWriter except BinaryReader and
BinaryWriter don’t use any encoding. Files are written in binary
format rather than text format.
Unlike the Stream type, BinaryWriter defines 18 overloads for the Write
method. The overloads accept different types, as shown in the
following code snippet that writes a double , an int , a long , and a
string (code file ReaderWriterSamples/Program.cs ):
public static void WriteFileUsingBinaryWriter(string binFile)
{
var outputStream = File.Create(binFile);
using (var writer = new BinaryWriter(outputStream))
{
double d = 47.47;
int i = 42;
long l = 987654321;
string s = "sample";
writer.Write(d);
writer.Write(i);
writer.Write(l);
writer.Write(s);
}
}
To read the file again, you can use a BinaryReader . This class defines
methods to read all the different types, such as ReadDouble , ReadInt32 ,
ReadInt64 , and ReadString , which are shown here:
public static void ReadFileUsingBinaryReader(string binFile)
{
var inputStream = File.Open(binFile, FileMode.Open);
using (var reader = new BinaryReader(inputStream))


{
double d = reader.ReadDouble();
int i = reader.ReadInt32();
long l = reader.ReadInt64();
string s = reader.ReadString();
Console.WriteLine($"d: {d}, i: {i}, l: {l}, s: {s}");
}
}
The order for reading the file must match exactly the order in which it
has been written. Creating your own binary format, you need to know
what and how it is stored and read accordingly. The older Microsoft
Word document was using a binary file format, whereas the newer
docx file extension is a zip file. How zip files can be read and written is
explained in the next section.
COMPRESSING FILES
.NET includes types to compress and decompress streams using
different algorithms. You can use DeflateStream , GZipStream , and
BrotliStream to compress and decompress streams; the ZipArchive
class enables you to create and read ZIP files.
Both DeflateStream and GZipStream use the same algorithm for
compression (in fact, GZipStream uses DeflateStream behind the
scenes), but GZipStream adds a cyclic redundancy check to detect data
corruption. Brotli is a relatively new open-source compression
algorithm from Google. The speed of Brotli is similar to deflate, but it
offers a better compression. Contrary to most other compression
algorithms, it uses a dictionary for often-used words for better
compression. Nowadays this algorithm is supported by most modern
browsers.
Using a zip file has the advantage that you can compress files to an
archive (with ZipArchive), and you can open this archive directly with
Windows Explorer; it’s been built in to Windows since 1998. You can’t
open a gzip archive with Windows Explorer; you need third-party tools
for gzip.


**NOTE**
The algorithm used by DeflateStream and GZipStream is the deflate
algorithm. This algorithm is defined by RFC 1951
( https://tools.ietf.org/html/rfc1951 ). This algorithm is widely
thought to be not covered by patents, which is why it is in
widespread use.
Brotli is available on GitHub at https://github.com/google/brotli
and defined by RFC 7932 ( https://tools.ietf.org/html/rfc7932).
The sample code for CompressFileSample makes use of the following
dependency and namespaces:
Dependency
System.IO.Compression.Brotli
Namespaces
System
System.Collections.Generic
System.IO
System.IO.Compression
System.Text
Using the Deflate Stream
As explained earlier, a feature from streams is that you can chain
them. To compress a stream, all that’s needed is to create
DeflateStream and pass another stream (in this example, the
outputStream to write a file) to the constructor, with the argument
CompressionMode.Compress for compression. Writing to this stream
either using the Write method or by using other features, such as the
CopyTo method as shown in this code snippet, is all that’s needed for


file compression (code file CompressFileSample/Program.cs ):
public static void CompressFile(string fileName, string
compressedFileName)
{
using (FileStream inputStream = File.OpenRead(fileName))
{
FileStream outputStream =
File.OpenWrite(compressedFileName);
using (var compressStream =
new DeflateStream(outputStream,
CompressionMode.Compress))
{
inputStream.CopyTo(compressStream);
}
}
}
To decompress the deflate-compressed file again, the following code
snippet opens the file using a FileStream and creates the
DeflateStream object with CompressionMode.Decompress passing the file
stream for decompression. The Stream.CopyTo method copies the
decompressed stream to a MemoryStream . This code snippet then makes
use of a StreamReader to read the data from the MemoryStream and write
the output to the console. The StreamReader is configured to leave the
assigned MemoryStream open (using the leaveOpen argument), so the
MemoryStream could also be used after closing the reader:
public static void DecompressFile(string fileName)
{
FileStream inputStream = File.OpenRead(fileName);
using (MemoryStream outputStream = new MemoryStream())
using (var compressStream = new DeflateStream(inputStream,
CompressionMode.Decompress))
{
compressStream.CopyTo(outputStream);
outputStream.Seek(0, SeekOrigin.Begin);
using (var reader = new StreamReader(outputStream,
Encoding.UTF8,
detectEncodingFromByteOrderMarks: true, bufferSize:
4096,
leaveOpen: true))
{
string result = reader.ReadToEnd();
Console.WriteLine(result);


}
// you could use the outputStream after the StreamReader
is closed
}
}
Using Brotli
Using BrotliStream , compression with Brotli is like using deflate. You
just need to add the NuGet package System.IO.Compression.Brotli and
instantiate the BrotliStream class (code file
CompressFileSample/Program.cs ):
public static void CompressFileWithBrotli(string fileName,
string compressedFileName)
{
using (FileStream inputStream = File.OpenRead(fileName))
{
FileStream outputStream =
File.OpenWrite(compressedFileName);
using (var compressStream =
new BrotliStream(outputStream,
CompressionMode.Compress))
{
inputStream.CopyTo(compressStream);
}
}
}
Decompression works accordingly using BrotliStream :
public static void DecompressFileWithBrotli(string fileName)
{
FileStream inputStream = File.OpenRead(fileName);
using (MemoryStream outputStream = new MemoryStream())
using (var compressStream = new BrotliStream(inputStream,
CompressionMode.Decompress))
{
compressStream.CopyTo(outputStream);
outputStream.Seek(0, SeekOrigin.Begin);
using (var reader = new StreamReader(outputStream,
Encoding.UTF8,
detectEncodingFromByteOrderMarks: true, bufferSize:
4096,
leaveOpen: true))
{


string result = reader.ReadToEnd();
Console.WriteLine(result);
}
}
}
Zipping Files
Today, the ZIP file format is the standard for many different file types.
Word documents ( docx ) as well as NuGet packages are all stored as a
ZIP file. With .NET, it’s easy to create a ZIP archive.
For creating a ZIP archive, you can create an object of ZipArchive . A
ZipArchive contains multiple ZipArchiveEntry objects. The ZipArchive
class is not a stream, but it uses a stream to read or write to (this is
similar to the reader and writer classes discussed earlier). The
following code snippet creates a ZipArchive that writes the compressed
content to the file stream opened with File.OpenWrite . What’s added
to the ZIP archive is defined by the directory passed.
Directory.EnumerateFiles enumerates all the files in the directory and
creates a ZipArchiveEntry object for every file. Invoking the Open
method creates a Stream object. With the CopyTo method of the Stream
that is read, the file is compressed and written to the ZipArchiveEntry
(code file CompressFileSample/Program.cs ):
public static void CreateZipFile(string directory, string
zipFile)
{
FileStream zipStream = File.OpenWrite(zipFile);
using (var archive = new ZipArchive(zipStream,
ZipArchiveMode.Create))
{
IEnumerable<string> files = Directory.EnumerateFiles(
directory, "*", SearchOption.TopDirectoryOnly);
foreach (var file in files)
{
ZipArchiveEntry entry =
archive.CreateEntry(Path.GetFileName(file));
using (FileStream inputStream = File.OpenRead(file))
using (Stream outputStream = entry.Open())
{
inputStream.CopyTo(outputStream);
}


}
}
}
WATCHING FILE CHANGES
With FileSystemWatcher , you can monitor file changes. Events are
fired on creating, renaming, deleting, and changing files. This can be
used in scenarios where you need to react on file changes——for
example, with a server when a file is uploaded, or in a case where a file
is cached in memory and the cache needs to be invalidated when the
file changes.
As FileSystemWatcher is easy to use, let’s directly get into a sample.
The sample code for FileMonitor makes use of the following
namespaces:
System
System.IO
The sample code starts watching files in the method WatchFiles . Using
the constructor of the FileSystemWatcher , you can supply the directory
that should be watched. You can also provide a filter to filter only
specific files that match with the filter expression. When you set the
property IncludeSubdirectories , you can define whether only the files
in the specified directory should be watched or whether files in
subdirectories should also be watched. With the Created , Changed ,
Deleted , and Renamed events, event handlers are supplied. All of these
events are of type FileSystemEventHandler with the exception of the
Renamed event that is of type RenamedEventHandler . RenamedEventHandler
derives from FileSystemEventHandler and offers additional
information about the event (code file FileMonitor/Program.cs ):
private static FileSystemWatcher s_watcher;
public static void WatchFiles(string path, string filter)
{
s_watcher = new FileSystemWatcher(path, filter)
{
IncludeSubdirectories = true
};


s_watcher.Created += OnFileChanged;
s_watcher.Changed += OnFileChanged;
s_watcher.Deleted += OnFileChanged;
s_watcher.Renamed += OnFileRenamed;
s_watcher.EnableRaisingEvents = true;
Console.WriteLine("watching file changes...");
}
The information that is received with a file change is of type
FileSystemEventArgs . It contains the name of the file that changed as
well as the kind of change that is an enumeration of type
WatcherChangeTypes :
private static void OnFileChanged(object sender,
FileSystemEventArgs e)
{
Console.WriteLine($"file {e.Name} {e.ChangeType}");
}
On renaming the file, additional information is received with the
RenamedEventArgs parameter. This type derives from
FileSystemEventArgs and defines additional information about the
original name of the file:
private static void OnFileRenamed(object sender,
RenamedEventArgs e)
{
Console.WriteLine($"file {e.OldName} {e.ChangeType} to
{e.Name}");
}
When you start the application by specifying a folder to watch and
* .txt as the filter, the following is the output after creating the file
sample1.txt , adding content, renaming it to sample2.txt , and finally
deleting it:
watching file changes...
file New Text Document.txt Created
file New Text Document.txt Renamed to sample1.txt
file sample1.txt Changed
file sample1.txt Changed
file sample1.txt Renamed to sample2.txt
file sample2.txt Deleted


WORKING WITH MEMORY MAPPED FILES
Memory mapped files enable you to access files or shared memory
from different processes. There are several scenarios and features with
this technology:
Fast random access to huge files using maps of the file
Sharing of files between different processes or tasks
Sharing of memory between different processes or tasks
Using accessors to directly read and write from memory positions
Using streams to read and write
The memory mapped files API allows you to use either a physical file
or shared memory——where the system’s page file is used as a backing
store. The shared memory can be bigger than the available physical
memory, so a backing store is needed. You can create a memory
mapped file to a specific file or shared memory. With either of these
options, you can assign a name for the memory map. Using a name
allows different processes to have access to the same shared memory.
After you’ve created the memory map, you can create a view. A view is
used to map a part of the complete memory mapped file to access it for
reading or writing.
The MemoryMappedFilesSample makes use of the following namespaces:
System
System.IO
System.IO.MemoryMappedFiles
System.Threading
System.Threading.Tasks
The sample application demonstrates working with a memory mapped
file using both view accessors and streams using multiple tasks. One
task creates the memory mapped file and writes data to it; the other
task reads data.
**NOTE**


The sample code makes use of tasks and events. Read Chapter 21,
“Tasks and Parallel Programming,” for more information about
tasks, and synchronization between tasks.
Some infrastructure is needed for creating the tasks and signaling
when the map is ready, and the data is written. The name of the map
and ManualResetEventSlim objects are defined as a member of the
Program class (code file MemoryMappedFilesSample/Program.cs ):
private ManualResetEventSlim _mapCreated =
new ManualResetEventSlim(initialState: false);
private ManualResetEventSlim _dataWrittenEvent =
new ManualResetEventSlim(initialState: false);
private const string MAPNAME = "SampleMap";
Tasks are started within the Main method with the Task.Run method:
public void Run()
{
Task.Run(() => WriterAsync());
Task.Run(() => Reader());
Console.WriteLine("tasks started");
Console.ReadLine();
}
Now let’s create readers and writers using accessors.
Using Accessors to Create Memory Mapped Files
To create a memory-based memory mapped file, the writer invokes the
MemoryMappedFile.CreateOrOpen method. This method either opens the
object with the name specified with the first parameter, or it creates a
new one if it doesn’t exist. To open existing files, you can use the
method OpenExisting . For accessing physical files, you can use the
method CreateFromFile .
Other parameters used in the sample code are the size of the memory
mapped file and the access needed. After the memory mapped file is
created, the event _mapCreated is signaled to give other tasks the


information that the memory mapped file is created and can be
opened. Invoking the method CreateViewAccessor returns a
MemoryMappedViewAccessor to access the shared memory. With the view
accessor, you can define an offset and size that is used by this task. Of
course, the maximum size that you can use is the size of the memory
mapped file itself. This view is used for writing; thus, the file access is
set to MemoryMappedFileAccess.Write .
Next, you can write primitive data types to the shared memory using
overloaded Write methods of the MemoryMappedViewAccessor . The Write
method always needs position information designating where the data
should be written to. After all the data is written, an event is signaled
to inform the reader that it is now possible to start reading (code file
MemoryMappedFilesSample/Program.cs ):
private async Task WriterAsync()
{
try
{
using (MemoryMappedFile mappedFile =
MemoryMappedFile.CreateOrOpen(
MAPNAME, 10000, MemoryMappedFileAccess.ReadWrite))
{
_mapCreated.Set(); // signal shared memory segment
created
Console.WriteLine("shared memory segment created");
using (MemoryMappedViewAccessor accessor =
mappedFile.CreateViewAccessor(
0, 10000, MemoryMappedFileAccess.Write))
{
for (int i = 0, pos = 0; i < 100; i++, pos += 4)
{
accessor.Write(pos, i);
Console.WriteLine($"written {i} at position
{pos}");
await Task.Delay(10);
}
_dataWrittenEvent.Set(); // signal all data written
Console.WriteLine("data written");
}
}
}
catch (Exception ex)
{


Console.WriteLine($"writer {ex.Message}");
}
}
The reader first waits for the map to be created before opening the
memory mapped file using MemoryMappedFile.OpenExisting . The
reader just needs read access to the map. After that, similar to the
writer before, a view accessor is created. Before reading data, you wait
for the _dataWrittenEvent to be set. Reading is similar to writing in
that you supply a position where the data should be accessed, but
different Read methods, such as ReadInt32 , are defined for reading the
different data types:
private void Reader()
{
try
{
Console.WriteLine("reader");
_mapCreated.Wait();
Console.WriteLine("reader starting");
using (MemoryMappedFile mappedFile =
MemoryMappedFile.OpenExisting(
MAPNAME, MemoryMappedFileRights.Read))
{
using (MemoryMappedViewAccessor accessor =
mappedFile.CreateViewAccessor(
0, 10000, MemoryMappedFileAccess.Read))
{
_dataWrittenEvent.Wait();
Console.WriteLine("reading can start now");
for (int i = 0; i < 400; i += 4)
{
int result = accessor.ReadInt32(i);
Console.WriteLine($"reading {result} from position
{i}");
}
}
}
}
catch (Exception ex)
{
Console.WriteLine($"reader {ex.Message}");
}
}


When you run the application, you might see output such as this:
reader
reader starting
tasks started
shared memory segment created
written 0 at position 0
written 1 at position 4
written 2 at position 8
...
written 99 at 396
data written
reading can start now
reading 0 from position 0
reading 1 from position 4
...
Using Streams to Create Memory Mapped Files
Instead of writing primitive data types with memory mapped files, you
can instead use streams. Streams enable you to use readers and
writers, as described earlier in this chapter. Now create a writer to use
a StreamWriter . The method CreateViewStream from the
MemoryMappedFile returns a MemoryMappedViewStream . This method is
very similar to the CreateViewAccessor method used earlier in defining
a view inside the map; with the offset and size, it is convenient to use
all the features of streams. The WriteLineAsync method is then used to
write a string to the stream. As the StreamWriter caches writes, the
stream position is not updated with every write; it’s updated only
when the writer writes blocks. For flushing the cache with every write,
you set the AutoFlush property of the StreamWriter to true (code file
MemoryMappedFilesSample/Program.cs ):
private async Task WriterUsingStreams()
{
try
{
using (MemoryMappedFile mappedFile =
MemoryMappedFile.CreateOrOpen(
MAPNAME, 10000, MemoryMappedFileAccess.ReadWrite))
{
_mapCreated.Set(); // signal shared memory segment
created


Console.WriteLine("shared memory segment created");
MemoryMappedViewStream stream =
mappedFile.CreateViewStream(
0, 10000, MemoryMappedFileAccess.Write);
using (var writer = new StreamWriter(stream))
{
writer.AutoFlush = true;
for (int i = 0; i < 100; i++)
{
string s = $"some data {i}";
Console.WriteLine($"writing {s} at
{stream.Position}");
await writer.WriteLineAsync(s);
}
}
_dataWrittenEvent.Set(); // signal all data written
Console.WriteLine("data written");
}
}
catch (Exception ex)
{
Console.WriteLine($"writer {ex.Message}");
}
}
The reader similarly creates a mapped view stream with
CreateViewStream , but this time for read access. Now it’s possible to
use StreamReader methods to read content from the shared memory:
private async Task ReaderUsingStreams()
{
try
{
Console.WriteLine("reader");
_mapCreated.Wait();
Console.WriteLine("reader starting");
using (MemoryMappedFile mappedFile =
MemoryMappedFile.OpenExisting(
MAPNAME, MemoryMappedFileRights.Read))
{
MemoryMappedViewStream stream =
mappedFile.CreateViewStream(
0, 10000, MemoryMappedFileAccess.Read);
using (var reader = new StreamReader(stream))
{
_dataWrittenEvent.Wait();
Console.WriteLine("reading can start now");


for (int i = 0; i < 100; i++)
{
long pos = stream.Position;
string s = await reader.ReadLineAsync();
Console.WriteLine($"read {s} from {pos}");
}
}
}
}
catch (Exception ex)
{
Console.WriteLine($"reader {ex.Message}");
}
}
When you run the application, you can see the data written and read.
When the data is being written, the position within the stream is
always updated because the AutoFlush property is set. When data is
being read, always 1024 byte blocks are read.
tasks started
reader
reader starting
shared memory segment created
writing some data 0 at 0
writing some data 1 at 13
writing some data 2 at 26
writing some data 3 at 39
writing some data 4 at 52
...
data written
reading can start now
read some data 0 from 0
read some data 1 from 1024
read some data 2 from 1024
read some data 3 from 1024
...
When communicating via memory mapped files, you have to
synchronize the reader and the writer, so the reader knows when data
is available. Pipes, which are discussed in the next section, give other
options in such a scenario.
COMMUNICATING WITH PIPES


For communication between threads and processes, and also fast
communication between different systems, you can use pipes. With
.NET, pipes are implemented as streams and thus you have an option
to not only send bytes into a pipe, but you can use all the stream
features, such as readers and writers.
Pipes are implemented as different kinds——as named pipes, where the
name can be used to connect to each end, and anonymous pipes.
Anonymous pipes cannot be used to communicate between different
systems; they can be used only for communication between a child and
parent process or for communication between different tasks.
The code for all the pipe samples makes use of the following
namespaces:
System
System.IO
System.IO.Pipes
System.Threading
System.Threading.Tasks
Let’s start with named pipes for communication between different
processes. With the first sample application, two console applications
are used. One acts as server and reads data from a pipe; the other one
writes messages to the pipe.
Creating a Named Pipe Server
You create the server by creating a new instance of
NamedPipeServerStream . NamedPipeServerStream derives from the base
class PipeStream that in turn derives from the Stream base class and
thus can use all the features of streams——for example, you can create a
CryptoStream or a GZipStream to write encrypted or compressed data
into the named pipe. The constructor requires a name for the pipe that
can be used by multiple processes communicating via the pipe.
The second argument that is used in the following code snippet defines
the direction of the pipe. The server stream is used for reading, and


thus the direction is set to PipeDirection.In . Named pipes can also be
bidirectional for reading and writing; you use PipeDirection.InOut .
Anonymous pipes can be only unidirectional. Next, the named pipe
waits until the writing party connects by calling the WaitForConnection
method. Next, within a loop (until the message “bye” is received), the
pipe server reads messages to a buffer array and writes the message to
the console (code file PipesReader/Program.cs ):
private static void PipesReader(string pipeName)
{
try
{
using (var pipeReader =
new NamedPipeServerStream(pipeName, PipeDirection.In))
{
pipeReader.WaitForConnection();
Console.WriteLine("reader connected");
const int BUFFERSIZE = 256;
bool completed = false;
while (!completed)
{
byte[] buffer = new byte[BUFFERSIZE];
int nRead = pipeReader.Read(buffer, 0, BUFFERSIZE);
string line = Encoding.UTF8.GetString(buffer, 0,
nRead);
Console.WriteLine(line);
if (line == "bye") completed = true;
}
}
Console.WriteLine("completed reading");
Console.ReadLine();
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
}
The following are some other options that you can configure with
named pipes:
You can set the enumeration PipeTransmissionMode to Byte or
Message . With bytes, a continuous stream is sent; with messages
every message can be retrieved.


With the pipe options, you can specify WriteThrough to immediately
write to the pipe and not to the cache.
You can configure buffer sizes for input and output.
You configure pipe security to designate who is allowed to read and
write to the pipe. Security is discussed in Chapter 24.
You can configure inheritability of the pipe handle, which is
important for communicating with child processes.
Because the NamedPipeServerStream is a Stream , you can use
StreamReader instead of reading from the byte array; this method
simplifies the code:
var pipeReader = new NamedPipeServerStream(pipeName,
PipeDirection.In);
using (var reader = new StreamReader(pipeReader))
{
pipeReader.WaitForConnection();
Console.WriteLine("reader connected");
bool completed = false;
while (!completed)
{
string line = reader.ReadLine();
Console.WriteLine(line);
if (line == "bye") completed = true;
}
}
Creating a Named Pipe Client
Now you need a client. As the server reads messages, the client writes
them.
You create the client by instantiating a NamedPipeClientStream object.
Because named pipes can communicate across the network, you need
a server name in addition to the pipe name and the direction of the
pipe. The client connects by invoking the Connect method. After the
connection succeeds, messages are sent to the server by invoking
WriteLine on the StreamWriter . By default, messages are not sent
immediately; they are cached. The message is pushed to the server by
invoking the Flush method. You can also immediately pass all the
messages without invoking the Flush method. For this, you have to


configure the option to write through the cache on creating the pipe
(code file PipesWriter/Program.cs ):
public static void PipesWriter(string serverName, string
pipeName)
{
var pipeWriter = new NamedPipeClientStream(serverName,
pipeName, PipeDirection.Out);
using (var writer = new StreamWriter(pipeWriter))
{
pipeWriter.Connect();
Console.WriteLine("writer connected");
bool completed = false;
while (!completed)
{
string input = ReadLine();
if (input == "bye") completed = true;
writer.WriteLine(input);
writer.Flush();
}
}
Console.WriteLine("completed writing");
}
For starting two projects from within Visual Studio, you can configure
multiple startup projects with Project ⇨ Set Startup Projects. When
you run the application, input from one console is echoed in the other
one.
Creating Anonymous Pipes
Let’s do something similar with anonymous pipes. With anonymous
pipes two tasks are created that communicate with each other. For
signaling the pipe creation, you use a ManualResetEventSlim object as
you did with the memory mapped files. In the Run method of the
Program class, two tasks are created that invoke the Reader and Writer
methods (code file AnonymousPipes/Program.cs ):
private string _pipeHandle;
private ManualResetEventSlim _pipeHandleSet;
static void Main()
{
var p = new Program();


p.Run();
Console.ReadLine();
}
public void Run()
{
_pipeHandleSet = new ManualResetEventSlim(initialState:
false);
Task.Run(() => Reader());
Task.Run(() => Writer());
Console.ReadLine();
}
The server side acts as a reader by creating an
AnonymousPipeServerStream and defining the PipeDirection.In . The
other side of the communication needs to know about the client
handle of the pipe. This handle is converted to a string from the
method GetClientHandleAsString and assigned to the _pipeHandle
variable. This variable will be used later by the client that acts as a
writer. After the initial process, the pipe server can be acted on as a
stream because it is a stream:
private void Reader()
{
try
{
var pipeReader = new
AnonymousPipeServerStream(PipeDirection.In,
HandleInheritability.None);
using (var reader = new StreamReader(pipeReader))
{
_pipeHandle = pipeReader.GetClientHandleAsString();
Console.WriteLine($"pipe handle: {_pipeHandle}");
_pipeHandleSet.Set();
bool end = false;
while (!end)
{
string line = reader.ReadLine();
Console.WriteLine(line);
if (line == "end") end = true;
}
Console.WriteLine("finished reading");
}
}
catch (Exception ex)
{


Console.WriteLine(ex.Message);
}
}
The client code waits until the variable _pipeHandleSet is signaled, and
thus can open the pipe handle referenced by the _pipeHandle variable.
Later processing continues with a StreamWriter :
private void Writer()
{
Console.WriteLine("anonymous pipe writer");
_pipeHandleSet.Wait();
var pipeWriter = new AnonymousPipeClientStream(
PipeDirection.Out, _pipeHandle);
using (var writer = new StreamWriter(pipeWriter))
{
writer.AutoFlush = true;
Console.WriteLine("starting writer");
for (int i = 0; i < 5; i++)
{
writer.WriteLine($"Message {i}");
Task.Delay(500).Wait();
}
writer.WriteLine("end");
}
}
When you run the application, the two tasks communicate and send
data between the tasks.
USING FILES AND STREAMS WITH THE
WINDOWS RUNTIME
With the Windows Runtime, you implement streams with native
types. Although they are implemented with native code, they look like
.NET types. However, there’s a difference you need to be aware of: For
streams, the Windows Runtime implements its own types in the
namespace Windows.Storage.Streams . Here you can find classes such
as FileInputStream , FileOutputStream , and RandomAccessStreams . All
these classes are based on interfaces, for example, IInputStream ,
IOutputStream , and IRandomAccessStream . You’ll also find the concept
of readers and writers. Windows Runtime readers and writers are the


types DataReader and DataWriter .
Let’s look at what’s different from the .NET streams you’ve seen so far
and how .NET streams and types can map to these native types.
Windows App Editor
Let’s create an editor starting with the Blank App (Universal
Windows) Visual Studio template.
To add commands for opening and saving a file, a CommandBar with
AppBarButton elements is added to the main page (code file
WindowsAppEditor/MainPage.xaml ):
<Page.BottomAppBar>
<CommandBar IsOpen="True">
<AppBarButton Icon="OpenFile" Label="Open" Click="{x:Bind
OnOpen}" />
<AppBarButton Icon="Save" Label="Save" Click="{x:Bind
OnSave}" />
</CommandBar>
</Page.BottomAppBar>
The TextBox added to the Grid fill receive the contents of the file:
<Grid Background="{ThemeResource
ApplicationPageBackgroundThemeBrush}">
<TextBox x:Name="text1" HorizontalTextAlignment="Left"
AcceptsReturn="True" />
</Grid>
The OnOpen handle first starts the dialog where the user can select a
file. Remember, you used the OpenFileDialog earlier. With Windows
apps, you can use pickers. To open files, the FileOpenPicker is the
preferred type. You can configure this picker to define the proposed
start location for the user. You set the SuggestedStartLocation to
PickerLocationId.DocumentsLibrary to open the user’s documents
folder. The PickerLocationId is an enumeration that defines various
special folders.
Next, the FileTypeFilter collection specifies the file types that should
be listed for the user. Finally, the method PickSingleFileAsync returns
the file selected from the user. To allow users to select multiple files,


you can use the method PickMultipleFilesAsync instead. This method
returns a StorageFile . StorageFile is defined in the namespace
Windows.Storage . This class is the equivalent of the FileInfo class for
opening, creating, copying, moving, and deleting files (code file
WindowsAppEditor/MainPage .xaml.cs ):
public async void OnOpen()
{
try
{
var picker = new FileOpenPicker()
{
ViewMode = PickerViewMode.Thumbnail,
SuggestedStartLocation =
PickerLocationId.DocumentsLibrary
};
picker.FileTypeFilter.Add(".txt");
picker.FileTypeFilter.Add(".md");
StorageFile file = await picker.PickSingleFileAsync();
//...
Now, open the file using OpenReadAsync . This method returns a stream
that implements the interface IRandomAccessStreamWithContentType ,
which derives from the interfaces IRandomAccessStream , IInputStream ,
IOuputStream , IContentProvider , and IDisposable .
IRandomAccessStream allows random access to a stream with the Seek
method, and it gives information about the size of a stream.
IInputStream defines the method ReadAsync to read from a stream.
IOutputStream is the opposite; it defines the methods WriteAsync and
FlushAsync . IContentTypeProvider defines the property ContentType
that gives information about the content of the file. Remember the
encodings of the text files? Now it would be possible to read the
content of the stream invoking the method ReadAsync . However, the
Windows Runtime also knows the reader’s and writer’s concepts that
have already been discussed. A DataReader accepts an IInputStream
with the constructor. The DataReader type defines methods to read
primitive data types such as ReadInt16 , ReadInt32 , and ReadDateTime .
You can read a byte array with ReadBytes , and a string with ReadString .
The ReadString method requires the number of characters to read. The
string is assigned to the Text property of the TextBox control to display


the content:
//...
if (file != null)
{
IRandomAccessStreamWithContentType stream = await
file.OpenReadAsync();
using (var reader = new DataReader(stream))
{
await reader.LoadAsync((uint)stream.Size);
text1.Text = reader.ReadString((uint)stream.Size);
}
}
}
catch (Exception ex)
{
var dlg = new MessageDialog(ex.Message, "Error");
await dlg.ShowAsync();
}
**NOTE**
Like the readers and the writers of the .NET Framework, the
DataReader and DataWriter manages the stream that is passed
with the constructor. On disposing the reader or writer, the
stream gets disposed as well. With .NET classes, to keep the
underlying stream open for a longer time you can set the
leaveOpen argument in the constructor. With the Windows
Runtime types, you can detach the stream from the readers and
writers by invoking the method DetachStream .
On saving the document, the OnSave method is invoked. First, the
FileSavePicker is used to allow the user to select the document——
similar to the FileOpenPicker . Next, the file is opened using
OpenTransactedWriteAsync . The NTFS file system supports
transactions; these are not covered from the .NET Framework but are
available with the Windows Runtime. OpenTransactedWriteAsync
returns a StorageStreamTransaction object that implements the
interface IStorageStreamTransaction . This object itself is not a stream


(although the name might lead you to believe this), but it contains a
stream that you can reference with the Stream property. This property
returns an IRandomAccessStream stream. As you can create a
DataReader , you can create a DataWriter to write primitive data types,
including strings as in this example. The StoreAsync method finally
writes the content from the buffer to the stream. The transaction
needs to be committed by invoking the CommitAsync method before
disposing the writer:
public async void OnSave()
{
try
{
var picker = new FileSavePicker()
{
SuggestedStartLocation =
PickerLocationId.DocumentsLibrary,
SuggestedFileName = "New Document"
};
picker.FileTypeChoices.Add("Plain Text", new List<string>
() { ".txt" });
StorageFile file = await picker.PickSaveFileAsync();
if (file != null)
{
using (StorageStreamTransaction tx =
await file.OpenTransactedWriteAsync())
{
IRandomAccessStream stream = tx.Stream;
stream.Seek(0);
using (var writer = new DataWriter(stream))
{
writer.WriteString(text1.Text);
tx.Stream.Size = await writer.StoreAsync();
await tx.CommitAsync();
}
}
}
}
catch (Exception ex)
{
var dlg = new MessageDialog(ex.Message, "Error");
await dlg.ShowAsync();
}
}


The DataWriter doesn’t add the preamble defining the kind of Unicode
file to the stream. You need to do that explicitly, as explained earlier in
this chapter. The DataWriter just deals with the encoding of the file by
setting the UnicodeEncoding and ByteOrder properties. The default
setting is UnicodeEncoding.Utf8 and ByteOrder.BigEndian . Instead of
working with the DataWriter , you can also take advantage of the
features of the StreamReader and StreamWriter as well as the .NET
Stream class, as shown in the next section.
Mapping Windows Runtime Types to .NET Types
Let’s start with reading the file. To convert a Windows Runtime stream
to a .NET stream for reading, you can use the extension method
AsStreamForRead . This method is defined in the namespace System.IO
(that must be opened) in the assembly
System.Runtime.WindowsRuntime . This method creates a new Stream
object that manages the IInputStream . Now, you can use it as a normal
.NET stream, as shown previously——for example, passing it to a
StreamReader and using this reader to access the file:
public async void OnOpenDotnet()
{
try
{
var picker = new FileOpenPicker()
{
ViewMode = PickerViewMode.Thumbnail,
SuggestedStartLocation =
PickerLocationId.DocumentsLibrary
};
picker.FileTypeFilter.Add(".txt");
picker.FileTypeFilter.Add(".md");
StorageFile file = await picker.PickSingleFileAsync();
if (file != null)
{
IRandomAccessStreamWithContentType wrtStream =
await file.OpenReadAsync();
Stream stream = wrtStream.AsStreamForRead();
using (var reader = new StreamReader(stream))
{
text1.Text = await reader.ReadToEndAsync();
}


}
}
catch (Exception ex)
{
var dlg = new MessageDialog(ex.Message, "Error");
await dlg.ShowAsync();
}
}
All the Windows Runtime stream types can easily be converted to
.NET streams and the other way around. The following table lists the
methods needed:
CONVERT FROM CONVERT TO
METHOD
IRandomAccessStream Stream
AsStream
IInputStream Stream
AsStreamForRead
IOutputStream Stream
AsStreamForWrite
Stream IInputStream
AsInputStream
Stream IOutputStream
AsOutputStream
Stream IRandomAccessStream AsRandomAccessStream
Now save the change to the file as well. The stream for writing is
converted with the extension method AsStreamForWrite . Now, this
stream can be written using the StreamWriter class. The code snippet
also writes the preamble for the UTF-8 encoding to the file:
public async void OnSaveDotnet()
{
try
{
var picker = new FileSavePicker()
{
SuggestedStartLocation =
PickerLocationId.DocumentsLibrary,
SuggestedFileName = "New Document"
};
picker.FileTypeChoices.Add("Plain Text", new List<string>
() { ".txt" });
StorageFile file = await picker.PickSaveFileAsync();
if (file != null)
{
StorageStreamTransaction tx = await
file.OpenTransactedWriteAsync();
using (var writer = new


StreamWriter(tx.Stream.AsStreamForWrite()))
{
byte[] preamble = Encoding.UTF8.GetPreamble();
await stream.WriteAsync(preamble, 0,
preamble.Length);
await writer.WriteAsync(text1.Text);
await writer.FlushAsync();
tx.Stream.Size = (ulong)stream.Length;
await tx.CommitAsync();
}
}
}
catch (Exception ex)
{
var dlg = new MessageDialog(ex.Message, "Error");
await dlg.ShowAsync();
}
}
SUMMARY
In this chapter, you examined how to use the .NET classes to access
the file system from your C# code. You have seen that in both cases the
base classes expose simple but powerful object models that make it
very easy to perform almost any kind of action in these areas. For the
file system, these actions are copying files; moving, creating, and
deleting files and folders; and reading and writing both binary and text
files.
You’ve seen how to compress files using both the deflate algorithm and
ZIP files. The FileSystemWatcher was used to get information when
files change. You’ve also seen how to communicate with the help of
shared memory as well as named and anonymous pipes. Finally,
you’ve seen how to map .NET streams to Windows Runtime streams to
take advantage of .NET features within Windows apps.
In some other chapters of the book you can see streams in action. For
example, Chapter 23, “Networking,” uses streams to send data across
the network. Reading and writing XML files and streaming large XML
files are shown in Bonus Chapter 2/JSON,” which you can find online.
The next chapter covers the foundation of networking and sending
streams across the network.