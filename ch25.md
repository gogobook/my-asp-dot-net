

ADO.NET and Transactions
WHAT’S IN THIS CHAPTER?
Connecting to the database
Executing commands
Calling stored procedures
The ADO.NET object model
Committing transactions with ADO.NET
Managing transactions with System.Transactions
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available in the GitHub repository
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the folder ADONET . The code for this chapter is divided into the
following major examples:
ConnectionSamples
CommandSamples
AsyncSamples
TransactionSamples


SystemTransactionSamples
ADO.NET OVERVIEW
This chapter discusses how to access a relational database like SQL
Server from your C# programs using ADO.NET. It shows you how to
connect to and disconnect from a database, how to use queries, and
how to add and update records. You learn the various command object
options and see how commands can be used for each of the options
presented by the SQL Server provider classes; how to call stored
procedures with command objects; and how to use transactions.
ADO.NET previously shipped different database providers: a provider
for SQL Server and one for Oracle, using OLEDB and ODBC. The
OLEDB technology is discontinued, so this provider shouldn’t be used
with new applications. Accessing the Oracle database, Microsoft’s
provider is discontinued as well because a provider from Oracle
( http://www.oracle.com/technetwork/topics/dotnet/products ) better
fits the needs. For other data sources (also for Oracle), many third-
party providers are available. Before using the ODBC provider, you
should use a provider specific for the data source you access. The code
samples in this chapter are based on SQL Server, but you can easily
change it to use different connection and command objects, such as
OracleConnection and OracleCommand when accessing the Oracle
database instead of SqlConnection and SqlCommand .
NOTE
This chapter does not cover the DataSet to have tables in memory,
although they are supported by .NET Core 2.0. Datasets enable
you to retrieve records from a database and store the content
within in-memory data tables with relations. Datasets have been
used a lot with earlier versions of .NET. Now, you can use Entity
Framework Core (EF Core) instead. EF Core is covered in Chapter
26, “Entity Framework Core.” This newer technology enables you
to have object relations instead of table-based relations.


Sample Database
The examples in this chapter use the Books database for SQL Server. A
backup file of this database is part of the source code download in the
directory CreateDatabase . Using the backup file, you can restore the
database backup using SQL Server Management Studio as shown in
Figure 25-1. As an alternative, you can also use the SQL script
CreateBooks.sql to create the database. In case you don’t have SQL
Server Management Studio on your system, you can download a free
version from https://docs.microsoft.com/sql/ssms/download-sql-
server-management-studio-ssms .
The SQL server used with this chapter is SQL Server LocalDb. This is a
database server that is installed as part of Visual Studio. You can use
any other SQL Server edition as well; you just need to change the
connection string accordingly.
NuGet Packages and Namespaces
The sample code for all the ADO.NET samples makes use of the
following dependencies and namespaces:
Dependencies
Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.Json
System.Data.SqlClient
Namespaces
Microsoft.Extensions.Configuration
System
System.Collections
System.Data
System.Data.SqlClient


System.IO
System.Threading.Tasks
FIGURE 25-1
USING DATABASE CONNECTIONS
To access the database, you need to provide connection parameters,
such as the machine on which the database is running and possibly
your login credentials. You make a connection to SQL Server using the
SqlConnection class.
The following code snippet illustrates how to create, open, and close a


connection to the Books database (code file
ConnectionSamples/Program.cs ):
public static void OpenConnection()
{
string connectionString = @"server=(localdb)\MSSQLLocalDB;"
+
"integrated security=SSPI;database=Books";
var connection = new SqlConnection(connectionString);
connection.Open();
// Do something useful
Console.WriteLine("Connection opened");
connection.Close();
}
NOTE
The SqlConnection class implements the IDisposable interface
with the Dispose method in addition to the Close method. Both do
the same, to release the connection. With this, you can use the
using statement to close the connection.
In the example connection string, the parameters used are as follows
(the parameters are delimited by a semicolon in the connection
string):
server=(localdb)\MSSQLLocalDB —This
denotes the database server
to connect to. SQL Server permits several separate database server
instances to be running on the same machine. Here, you are
connecting to the localdb Server and the MSSQLLocalDB SQL
Server instance that is created with the installation of SQL Server.
If you are using the local installation of SQL Server, change this
part to server=(local) . Instead of using the keyword server , you
can use Data Source instead. Connecting to SQL Azure, you can set
Data Source=servername.database.windows.net .
database=Books —This
describes the database instance to connect
to; each SQL Server process can expose several database instances.


Instead of the keyword database , you can instead use Initial
Catalog .
integrated security=SSPI —This
uses Windows Authentication to
connect to the database. In case you are using SQL Azure, you need
to set User Id and Password instead, or use the Azure Active
Directory.
NOTE
You can find great information about connection strings with
many different databases at http://www.connectionstrings.com .
The ConnectionSamples example opens a database connection using the
defined connection string and then closes that connection. After you
have opened the connection, you can issue commands against the data
source; when you are finished, you can close the connection.
Managing Connection Strings
Instead of hard-coding the connection string with the C# code, it is
better to read it from a configuration file. With .NET Core,
configuration files can be JSON or XML formats, or read from
environmental variables. With the following sample, the connection
string is read from a JSON configuration file (code file
ConnectionSamples/config.json ):
{
"Data": {
"DefaultConnection": {
"ConnectionString":
"Server=(localdb)\\MSSQLLocalDB;Database=Books;
Trusted_Connection=True;"
}
}
}
The JSON file can be read using the Configuration API defined in the
NuGet package Microsoft.Extensions.Configuration . To use JSON


configuration files, the NuGet package
Microsoft.Extensions.Configuration.Json is added as well. For
reading a configuration file, the ConfigurationBuilder is created. The
AddJsonFile extension method adds the JSON file config.json to read
configuration information from this file—if it is in the same path as the
program. To configure a different path, you can invoke the method
SetBasePath . Invoking the Build method of the ConfigurationBuilder
builds up the configuration from all the added configuration files and
returns an object implementing the IConfiguration interface. With
this, the configuration values can be retrieved, such as the
configuration value for Data:DefaultConnection:ConnectionString
(code file ConnectionSamples/Program.cs ):
public static void ConnectionUsingConfig()
{
var configurationBuilder = new ConfigurationBuilder()
.SetBasePath(Directory.GetCurrentDirectory())
.AddJsonFile("config.json");
IConfiguration config = configurationBuilder.Build();
string connectionString =
config["Data:DefaultConnection:ConnectionString"];
Console.WriteLine(connectionString);
}
Connection Pools
When two-tier applications were done several years ago it was a good
idea to open the connection on application start and close it only when
the application was closed. Nowadays, this is not a good idea. The
reason for this program architecture was that it takes some time to
open a connection. Now, closing a connection doesn’t close the
connection with the server. Instead, the connection is added to a
connection pool. When you open the connection again, it can be taken
from the pool, thus it is very fast to open a connection; it only takes
time to open the first connection.
Pooling can be configured with several options in the connection
string. Setting the option Pooling to false disables the connection
pool; by default, it’s enabled— Pooling = true . Min Pool Size and Max
Pool Size enable you to configure the number of connections in the


pool. By default, Min Pool Size has a value of 0 and Max Pool Size has
a value of 100 . Connection Lifetime defines how long a connection
should stay inactive in the pool before it is really released.
Connection Information
After creating a connection, you can register event handlers to get
some information about the connection. The SqlConnection class
defines the InfoMessage and StateChange events. The InfoMessage event
is fired every time an information or warning message is returned
from SQL Server. The StateChange event is fired when the state of the
connection changes—for example, the connection is opened or closed
(code file ConnectionSamples/Program.cs ):
public static void ConnectionInformation()
{
using (var connection = new
SqlConnection(GetConnectionString()))
{
connection.InfoMessage += (sender, e) =>
{
Console.WriteLine($"warning or info {e.Message}");
};
connection.StateChange += (sender, e) =>
{
Console.WriteLine($"current state: {e.CurrentState},
before: " +
$"{e.OriginalState}");
};
try
{
connection.StatisticsEnabled = true;
connection.FireInfoMessageEventOnUserErrors = true;
connection.Open();
Console.WriteLine("connection opened");
//... Read some records
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
}


}
When you run the application, you can see the StateChange event fired
and the Open and Closed state:
current state: Open, before: Closed
connection opened
... output reading records
current state: Closed, before: Open
In case an exception happens, by default the InfoMessage event is not
fired. You can change this behavior by setting the property
FireInfoMessageEventOnUserErrors . Then with an error, e.g. using the
Titl property instead of Title , you can see this information with the
application:
current state: Open, before: Closed
connection opened
warning or info: Invalid column name 'Titl'.
... output reading records
current state: Closed, before: Open
The SqlConnection class also offers statistic information. You just need
to set the StatisticsEnabled property, then you can retrieve the
statistics from the RetrieveStatistics method. This method returns
the statistic with an object implementing the IDictionary interface:
IDictionary statistics = connection.RetrieveStatistics();
ShowStatistics(statistics);
connection.ResetStatistics();
The method ShowStatistics iterates all keys of the received
IDictionary interface and displays all values:
private static void ShowStatistics(IDictionary statistics)
{
Console.WriteLine("Statistics");
foreach (var key in statistics.Keys)
{
Console.WriteLine($"{key}, value: {statistics[key]}");
}
Console.WriteLine();
}
Retrieving all records from the Books table shows this statistical


information from the connection:
BuffersReceived, value: 1
BuffersSent, value: 1
BytesReceived, value: 142
BytesSent, value: 124
CursorOpens, value: 0
IduCount, value: 0
IduRows, value: 0
PreparedExecs, value: 0
Prepares, value: 0
SelectCount, value: 0
SelectRows, value: 0
ServerRoundtrips, value: 1
SumResultSets, value: 0
Transactions, value: 0
UnpreparedExecs, value: 1
ConnectionTime, value: 140
ExecutionTime, value: 456
NetworkServerTime, value: 8
COMMANDS
The “Using Database Connections” section briefly touched on the idea
of issuing commands against a database. A command is, in its simplest
form, a string of text containing SQL statements to be issued to the
database. A command could also be a stored procedure, shown later in
this section.
A command can be constructed by passing the SQL statement as a
parameter to the constructor of the Command class, as shown in this
example (code file CommandSamples/Program.cs ):
public static void CreateCommand()
{
using (var connection = new
SqlConnection(GetConnectionString()))
{
string sql = "SELECT [Title], [Publisher], [ReleaseDate]
" +
"FROM [ProCSharp].[Books]";
var command = new SqlCommand(sql, connection);
connection.Open();
//...
}


}
A command can also be created by invoking the CreateCommand method
of the SqlConnection and assigning the SQL statement to the
CommandText property:
SqlCommand command = connection.CreateCommand();
command.CommandText = sql;
Commands often need parameters. For example, the following SQL
statement requires a Title parameter. Don’t be incited to use string
concatenation to build up parameters. Instead, always use the
parameter features of ADO.NET:
string sql = "SELECT [Title], [Publisher], [ReleaseDate] " +
"FROM [ProCSharp].[Books] WHERE lower([Title]) LIKE @Title";
var command = new SqlCommand(sql, connection);
When you add the parameter to the SqlCommand object, there’s a simple
way to use the Parameters property that returns a
SqlParameterCollection and the AddWithValue method:
command.Parameters.AddWithValue("Title", "Professional C#%");
A more efficient method that’s more programming work is to use
overloads of the Add method by passing the name and the SQL data
type:
command.Parameters.Add("TitleStart", SqlDbType.NVarChar, 50);
command.Parameters["Title"].Value = "Professional C#%";
It’s also possible to create a SqlParameter object and add this to the
SqlParameterCollection .
NOTE
Don’t be inclined to use string concatenation with SQL
parameters. This is often misused for SQL injection attacks. Using
SqlParameter objects inhibits such attacks.


After you have defined the command, you need to execute it. There are
several ways to issue the statement, depending on what, if anything,
you expect to be returned from that command. The SqlCommand class
provides the following ExecuteXX methods:
ExecuteNonQuery —Executes
the command but does not return any
output
ExecuteReader —Executes
IDataReader
the command and returns a typed
ExecuteScalar —Executes
the command and returns the value from
the first column of the first row of any result set
ExecuteNonQuery
The ExecuteNonQuery method is commonly used for UPDATE , INSERT , or
DELETE statements, for which the only returned value is the number of
records affected. This method can, however, return results if you call a
stored procedure that has output parameters. The sample code creates
a new record within the ProCSharp.Books table. Figure 25-2 shows the
design view of this table with Visual Studio 2017.


FIGURE 25-2
This table has an Id as primary key that is an identity column and thus
does not need to be supplied creating the record. The Title and Isbn
columns do not allow null (see Figure 25-2), but other columns do. In
the sample code, all the columns are filled with values. The method
ExecuteNonQuery defines the SQL INSERT statement, adds values for the
parameters, and invokes the ExecuteNonQuery method of the
SqlCommand class (code file CommandSamples/Program.cs ):
public static void ExecuteNonQuery
{
try
{
using (var connection = new
SqlConnection(GetConnectionString()))
{
string sql = "INSERT INTO [ProCSharp].[Books] " +
"([Title], [Publisher], [Isbn], [ReleaseDate]) " +
"VALUES (@Title, @Publisher, @Isbn, @ReleaseDate)";
var command = new SqlCommand(sql, connection);


command.Parameters.AddWithValue("Title",
"Professional C# 7 and .NET Core 2.0");
command.Parameters.AddWithValue("Publisher", "Wrox
Press");
command.Parameters.AddWithValue("Isbn", "978-
1119449270");
command.Parameters.AddWithValue("ReleaseDate", new
DateTime(2018, 4, 2));
connection.Open();
int records = command.ExecuteNonQuery();
Console.WriteLine($"{records} record(s) inserted");
}
}
catch (SqlException ex)
{
Console.WriteLine(ex.Message);
}
}
ExecuteNonQuery returns the number of rows affected by the command
as an int . When you run the method the first time, one record is
inserted. When you run the same method a second time, you get an
exception because of a unique index conflict. The Isbn has a unique
index defined and thus is allowed only once. To run the method a
second time, you need to delete the created record first.
ExecuteScalar
On many occasions it is necessary to return a single result from a SQL
statement, such as the count of records in a given table or the current
date/time on the server. You can use the ExecuteScalar method in
such situations:
public static void ExecuteScalar()
{
using (var connection = new
SqlConnection(GetConnectionString()))
{
string sql = "SELECT COUNT(*) FROM [ProCSharp].[Books]";
SqlCommand command = connection.CreateCommand();
command.CommandText = sql;
connection.Open();
object count = command.ExecuteScalar();


Console.WriteLine($"counted {count} book records");
}
}
The method returns an object, which you can cast to the appropriate
type if required. If the SQL you are calling returns only one column, it
is preferable to use ExecuteScalar over any other method of retrieving
that column. That also applies to stored procedures that return a
single value.
ExecuteReader
The ExecuteReader method executes the command and returns a data
reader object. The object returned can be used to iterate through the
record(s) returned. The ExecuteReader sample makes use of an SQL
query that is defined with the local function GetBookQuery in the
method ExecuteReader (code file CommandSamples/Program.cs ):
public static void ExecuteReader(string titleParameter)
{
string GetBookQuery() =>
"SELECT [Id], [Title], [Publisher], [ReleaseDate] "+
"FROM [ProCSharp].[Books] WHERE lower([Title]) LIKE
@Title " +
"ORDER BY [ReleaseDate] DESC";
//...
}
NOTE
Local functions are explained in Chapter 13, “Functional
Programming with C#.”
When you invoke the method ExecuteReader of the SqlCommand object, a
SqlDataReader is returned. Note that the SqlDataReader needs to be
disposed after it has been used. Also note that this time the
SqlConnection object is not explicitly disposed at the end of the
method. Passing the parameter CommandBehavior.CloseConnection to
the ExecuteReader method automatically closes the connection on


closing of the reader. If you don’t supply this setting, you still need to
close the connection.
For reading the records from the data reader, the Read method is
invoked within a while loop. The first call to the Read method moves
the cursor to the first record returned. When Read is invoked again, the
cursor is positioned to the next record—if there’s a record available.
The Read method returns false if no record is available at the next
position. When accessing the values of the columns, different GetXXX
methods are invoked, such as GetInt32 , GetString , and GetDateTime .
These methods are strongly typed as they return the specific type
needed, such as int , string , and DateTime . The index passed to these
methods corresponds to the columns retrieved with the SQL SELECT
statement, so the index stays the same even if the database structure
changes. With the strongly typed GetXXX methods you need to pay
attention to values where null is returned from the database; here the
GetXXX method throws an exception with a value type returned. With
the data retrieved, the ReleaseDate can be null . To avoid an exception
in this case, the C# conditional statement ?: is used to check whether
the value is null with the SqlDataReader.IsDbNull method. In that case,
null is assigned to a nullable DateTime . Only if the value is not null, the
DateTime is accessed with the GetDateTime method (code file
CommandSamples/Program.cs ):
public static void ExecuteReader(string title)
{
//...
var connection = new SqlConnection(GetConnectionString());
var command = new SqlCommand(GetBookQuery(), connection);
var parameter = new SqlParameter("Title",
SqlDbType.NVarChar, 50)
{
Value = $"{title}%"
};
command.Parameters.Add(parameter);
connection.Open();
using (SqlDataReader reader =
command.ExecuteReader(CommandBehavior.CloseConnection))
{
while (reader.Read())


{
int id = reader.GetInt32(0);
string bookTitle = reader.GetString(1);
string publisher = reader.GetString(2);
DateTime? releaseDate =
reader.IsDbNull(3) ? (DateTime?)null :
reader.GetDateTime(3);
DateTime from = reader.GetDateTime(4);
Console.WriteLine($"{id,5}. {bookTitle,-40}
{publisher,-15} " +
$"{releaseDate:d}");
}
}
}
When you run the application and pass the title Professional C# to the
ExecuteReader method, you see this output:
1015. Professional
4/2/2018
1. Professional
4/11/2016
2. Professional
2/9/2014
11. Professional
10/18/2012
9. Professional
3/8/2010
8. Professional
5/24/2008
18. Professional
6/12/2007
12. Professional
11/7/2005
6. Professional
6/2/2004
10. Professional
3/28/2002
1010. Professional
12/1/2001
1012. Professional
6/1/2001
C# 7 and .NET Core 2.0 Wrox Press
C# 6 and .NET Core 1.0 Wrox Press
C# 5.0 and .NET 4.5.1 Wrox Press
C# 2012 and .NET 4.5 Wrox Press
C# 4 and .NET 4 Wrox Press
C# 2008 Wrox Press
C# 2005 with .NET 3.0 Wrox Press
C# 2005 Wrox Press
C# 3rd Edition Wrox Press
C# 2nd Edition Wrox Press
C# Web Services Wrox Press
C# (Beta 2 Edition) Wrox Press
With the SqlDataReader , instead of using the typed methods GetXXX ,
you can use the untyped indexer that returns an object. With this, you
need to cast to the corresponding type:


int id = (int)reader[0];
string bookTitle = (string)reader[1];
string publisher = (string)reader[2];
DateTime? releaseDate = (DateTime?)reader[3];
The indexer of the SqlDataReader also allows a string to be used
instead of the int , passing the column name. This is the slowest
method of these different options, but it might fulfill your needs.
Compared to the time it costs to make a service call, the additional
time needed to access the indexer can be ignored:
int id = (int)reader["Id"];
string bookTitle = (string)reader["Title"];
string publisher = (string)reader["Publisher"];
DateTime? releaseDate = (DateTime?)reader["ReleaseDate"];
Calling Stored Procedures
Calling a stored procedure with a command object is just a matter of
defining the name of the stored procedure, adding a definition for each
parameter of the procedure, and then executing the command with
one of the methods presented in the previous section.
The following sample calls the stored procedure GetBooksByPublisher
to get all the books from a publisher. This stored procedure receives
one parameter to return records of the requested books:
CREATE PROCEDURE [ProCSharp].[GetBooksByPublisher]
@publisher nvarchar(50)
AS
SELECT [Id], [Title], [Publisher], [ReleaseDate] FROM
[ProCSharp].[Books]
WHERE [Publisher] = @publisher ORDER BY [ReleaseDate]
To invoke the stored procedure, the CommandText of the SqlCommand
object is set to the name of the stored procedure, and the CommandType
is set to CommandType.StoredProcedure . Other than that, the command
is invoked similarly to the way you’ve seen before. The parameter is
created using the CreateParameter method of the SqlCommand object,
but you can use other methods to create the parameter used earlier as
well. With the parameter, the SqlDbType , ParameterName , and Value
properties are filled. Because the stored procedure returns records, it


is invoked by calling the method ExecuteReader (code file
CommandSamples/Program.cs ):
private static void StoredProcedure(string publisher)
{
using (var connection = new
SqlConnection(GetConnectionString()))
{
SqlCommand command = connection.CreateCommand();
command.CommandText = "[ProCSharp].
[GetBooksByPublisher]";
command.CommandType = CommandType.StoredProcedure;
SqlParameter p1 = command.CreateParameter();
p1.SqlDbType = SqlDbType.NvarChar;
p1.ParameterName = "@Publisher";
p1.Value = publisher;
command.Parameters.Add(p1);
connection.Open();
using (SqlDataReader reader = command.ExecuteReader())
{
while (reader.Read())
{
int recursionLevel = (int)reader["Id"];
string title = (string)reader["Title"];
string pub = (string)reader["Publisher"];
DateTime releaseDate =
(DateTime)reader["ReleaseDate"];
Console.WriteLine($"{title} - {pub};
{releaseDate:d}";
}
}
}
}
When you run the application and pass the publisher Wrox Press , you
get the result as shown:
Professional C# (Beta 2 Edition) - Wrox Press; 6/1/2001
Beginning C# - Wrox Press; 9/15/2001
Professional C# Web Services - Wrox Press; 12/1/2001
Professional C# 2nd Edition - Wrox Press; 3/28/2002
Beginning Visual C# - Wrox Press; 8/20/2002
Professional .NET Network Programming - Wrox Press; 10/1/2002
ASP to ASP.NET Migration Handbook - Wrox Press; 2/1/2003
Professional C# 3rd Edition - Wrox Press; 6/2/2004
Professional C# 2005 - Wrox Press; 11/7/2005
Beginning Visual C# 2005 - Wrox Press; 11/7/2005


Professional C# 2005 with .NET 3.0 - Wrox Press; 6/12/2007
Beginning Visual C# 2008 - Wrox Press; 5/5/2008
Professional C# 2008 - Wrox Press; 5/24/2008
Professional C# 4 and .NET 4 - Wrox Press; 3/8/2010
Beginning Visual C# 2010 - Wrox Press; 4/5/2010
Real World .NET, C#, and Silverlight - Wrox Press; 11/22/2011
Professional C# 2012 and .NET 4.5 - Wrox Press; 10/18/2012
Beginning Visual C# 2012 Programming - Wrox Press; 12/4/2012
Professional C# 5.0 and .NET 4.5.1 - Wrox Press; 2/9/2014
Professional C# 6 and .NET Core 1.0 - Wrox Press; 4/11/2016
Professional C# 7 and .NET Core 2.0 - Wrox Press; 4/2/2018
Depending on the return of the stored procedure, you need to invoke
the stored procedure with ExecuteReader , ExecuteScalar , or
ExecuteNonQuery .
With a stored procedure that contains Output parameters, you need to
specify the Direction property of the SqlParameter . By default, the
direction is ParameterDirection.Input :
var pOut = new SqlParameter();
pOut.Direction = ParameterDirection.Output;
ASYNCHRONOUS DATA ACCESS
Accessing the database can take some time. Here you shouldn’t block
the user interface. The ADO.NET classes offer task-based
asynchronous programming by offering asynchronous methods in
addition to the synchronous ones. The following code snippet is like
the previous one using the SqlDataReader , but it makes use of Async
method calls. The connection is opened with SqlConnection.OpenAsync ,
the reader is returned from the method
SqlCommand.ExecuteReaderAsync , and the records are retrieved using
SqlDataReader.ReadAsync . With all these methods, the calling thread is
not blocked but can do other work before getting the result (code file
AsyncSamples/Program.cs ):
public static async Task Main()
{
await ReadAsync("Wrox Press");
}
public static async Task ReadAsync(int productId)


{
var connection = new SqlConnection(GetConnectionString());
string sql = "SELECT [Title], [Publisher], [ReleaseDate] "
+
"FROM [ProCSharp].[Books] WHERE lower([Title]) " +
"LIKE @Title ORDER BY [ReleaseDate]";
var command = new SqlCommand(sql, connection);
var titleParameter = new SqlParameter("Title",
SqlDbType.NVarChar, 50);
titleParameter.Value = title;
command.Parameters.Add(titleParameter);
await connection.OpenAsync();
using (SqlDataReader reader =
await
command.ExecuteReaderAsync(CommandBehavior.CloseConnection))
{
while (await reader.ReadAsync())
{
int id = reader.GetInt32(0);
string bookTitle = reader.GetString(1);
string publisher = reader[2].ToString();
DateTime? releaseDate =
reader.IsDBNull(3) ? (DateTime?)null :
reader.GetDateTime(3);
Console.WriteLine($"{id,5}. {bookTitle,-40}
{publisher,-15} " +
$"{releaseDate:d}");
}
}
}
NOTE
The asynchronous Main method requires at least C# 7.1.
Using the asynchronous method calls is not only advantageous with
Windows applications but also useful on the server side for making
multiple calls simultaneous. The asynchronous methods of the
ADO.NET API have overloads to support the CancellationToken for an


earlier stop of a long-running method.
NOTE
For more information about asynchronous method calls and the
CancellationToken , read Chapter 15, “Asynchronous
Programming.”
TRANSACTIONS WITH ADO.NET
By default, a single command is running within a transaction. If you
need to issue multiple commands, and either all of these or none
happen, you can start and commit transactions explicitly.
Transactions are described by the term ACID. ACID is a four-letter
acronym for atomicity, consistency, isolation, and durability:
Atomicity—Represents one unit of work. With a transaction,
either the complete unit of work succeeds, or nothing is changed.
Consistency—The state before the transaction was started and
after the transaction is completed must be valid. During the
transaction, the state may have interim values.
Isolation—Transactions that happen concurrently are isolated
from the state, which is changed during a transaction. Transaction
A cannot see the interim state of transaction B until the transaction
is completed.
Durability—After a transaction is completed, it must be stored in
a durable way. This means that if the power goes down or the
server crashes, the state must be recovered at reboot.
NOTE
Transactions and valid state can easily be described as a wedding


ceremony. A bridal couple is standing before a transaction
coordinator. The transaction coordinator asks the first of the
couple: “Do you want to marry this person on your side?” If the
first one agrees, the second is asked: “Do you want to marry this
person?” If the second one declines, the first receives a rollback. A
valid state with this transaction is only that both are married, or
none are. If both agree, the transaction is committed, and both
are in the married state. If one denies, the transaction is aborted,
and both stay in the unmarried state. An invalid state is that one
is married, and the other is not. The transaction guarantees that
the result is never in an invalid state.
With ADO.NET, transactions can be started by invoking the
BeginTransaction method of the SqlConnection . A transaction is always
associated with one connection; you can’t create ADO.NET
transactions over multiple connections. The method BeginTransaction
returns an SqlTransaction that in turn needs to be used with the
commands running under the same transaction (code file
TransactionSamples/Program.cs ):
public static void TransactionSample()
{
using (var connection = new
SqlConnection(GetConnectionString()))
{
await connection.OpenAsync();
SqlTransaction tx = connection.BeginTransaction();
//...
}
}
The code sample creates a record in the ProCSharp.Books table. Using
the SQL clause INSERT INTO , a record is added. The Books table defines
an auto-increment identifier that is returned with the second SQL
statement SELECT SCOPE_IDENTITY() that returns the created identifier.
After the SqlCommand object is instantiated, the connection is assigned
by setting the Connection property, and the transaction is assigned by
setting the Transaction property. With ADO.NET transactions, you
cannot assign the transaction to a command that uses a different
connection. However, you can also create commands with the same


connection that are not related to a transaction:
public static void TransactionSample()
{
//...
try
{
string sql = "INSERT INTO [ProCSharp].[Books] " +
"([Title], [Publisher], [Isbn], [ReleaseDate])" +
"VALUES (@Title, @Publisher, @Isbn, @ReleaseDate); " +
"SELECT SCOPE_IDENTITY()";
var command = new SqlCommand
{
CommandText = sql,
Connection = connection,
Transaction = tx
}
//...
}
NOTE
You might wonder why the OpenAsync and BeginTransaction
methods are defined outside of the try block. These calls can fail,
too. For example, if the OpenAsync method fails, the exception is
not caught in the local catch block, but instead a matching catch is
searched for outside of the TransactionSample method. It’s a good
way to deal with such exceptions separately. The tx variable
needs to be declared outside of the try block—otherwise it
wouldn’t be possible to use it in the catch .
After defining the parameters and filling the values, the command is
executed by invoking the method ExecuteScalarAsync . This time the
ExecuteScalarAsync method is used with the INSERT INTO clause
because the complete SQL statement ends by returning a single result:
The created identifier is returned from SELECT SCOPE_IDENTITY(). In
case you set a breakpoint after the WriteLine method and check the
result in the database, you will not see the new record in the database


although the created identifier is already returned. The reason is that
the transaction is not yet committed:
public static void TransactionSample()
{
//...
var p1 = new SqlParameter("Title", SqlDbType.NVarChar, 50);
var p2 = new SqlParameter("Publisher", SqlDbType.NVarChar,
50);
var p3 = new SqlParameter("Isbn", SqlDbType.NVarChar, 20);
var p4 = new SqlParameter("ReleaseDate", SqlDbType.Date);
command.Parameters.AddRange(new SqlParameter[] { p1, p2,
p3, p4 });
command.Parameters["Title"].Value = "Professional C# 8 and
.NET Core 3.0";
command.Parameters["Publisher"].Value = "Wrox Press";
command.Parameters["Isbn"].Value = "42-08154711";
command.Parameters["ReleaseDate"].Value = new
DateTime(2020, 9, 2);
object id = await command.ExecuteScalarAsync();
Console.WriteLine($"record added with id: {id}");
//...
}
Now another record can be created within the same transaction. With
the sample code, the same command is used that has the connection
and transaction still associated, just the values are changed before
invoking ExecuteScalarAsync again. You could also create a new
SqlCommand object that accesses a different table in the same database.
The transaction is committed invoking the Commit method of the
SqlTransaction object. After the commit, you can see the new records
in the database:
public static void TransactionSample()
{
//...
command.Parameters["Title"].Value = "Professional C# 9
and .NET Core 4.0";
command.Parameters["Publisher"].Value = "Wrox Press";
command.Parameters["Isbn"].Value = "42-08154711";
command.Parameters["ReleaseDate"].Value = new
DateTime(2022, 11, 2);


id = await command.ExecuteScalarAsync();
Console.WriteLine($"record added with id: {id}");
tx.Commit();
}
catch (Exception ex)
{
Console.WriteLine($"error {ex.Message}, rolling back");
tx.Rollback();
}
}
Did you check the Isbn number with both records? It’s the same.
Because the database table is specified with a unique index on the Isbn
number, writing the second records fail with an exception of type
SqlException and the exception information Cannot insert duplicate
key row in object 'ProCSharp.Books' with unique index
'IX_Books_Isbn'. The duplicate key value is (42-08154711). As a
result, the Rollback method makes an undo of all the SQL commands
in the same transaction. The state is reset as it was before the
transaction was started. This way, the first record is not written to the
database as well.
In case you run the program in debugging mode and have a breakpoint
active for too long, the transaction will be aborted because the
transaction timeout is reached. Transactions are not meant to have
user input while the transaction is active. It’s also not useful to
increase the transaction timeout for user input, because having a
transaction active causes locks within the database. Depending on the
records you read and write, either row locks, page locks, or table locks
can happen. You can influence the locks and thus performance of the
database by setting an isolation level for creating the transaction.
However, this also influences the ACID properties of the transaction—
for example, not everything is isolated.
The default isolation level that is applied to the transaction is
ReadCommitted . The following table shows the different options you can
set.
ISOLATION
LEVEL
DESCRIPTION


Transactions are not isolated from each other. With
this level, there is no wait for locked records from
other transactions. This way, uncommitted data can
be read from other transactions—dirty reads. This
level is usually only used for reading records for
which it does not matter if you read interim changes,
such as reports.
ReadCommitted
Waits for records with a write-lock from other
transactions. This way, a dirty read cannot happen.
This level sets a read-lock for the current record
read and a write-lock for the records being written
until the transaction is completed. During the
reading of a sequence of records, with every new
record that is read, the prior record is unlocked.
That’s why nonrepeatable reads can happen.
RepeatableRead Holds the lock for the records read until the
transaction is completed. This way, the problem of
nonrepeatable reads is avoided. Phantom reads can
still occur.
Serializable
Holds a range lock. While the transaction is running,
it is not possible to add a new record that belongs to
the same range from which the data is being read.
Snapshot
With this level a snapshot is done from the actual
data. This level reduces the locks as modified rows
are copied. That way, other transactions can still
read the old data without needing to wait for
releasing of the lock.
Unspecified
Indicates that the provider is using an isolation level
that is different from the values defined by the
IsolationLevel enumeration.
Chaos
This level is like ReadUncommitted , but in addition to
performing the actions of the ReadUncommitted value,
Chaos does not lock updated records.
ReadUncommitted
The following table summarizes the problems that can occur because
of setting the most commonly used transaction isolation levels.


ISOLATION
LEVEL
DIRTY
READS
ReadUncommitted Y
ReadCommitted
N
RepeatableRead N
Serializable
Y
NONREPEATABLE
READS
Y
Y
N
Y
PHANTOM
READS
Y
Y
Y
Y
TRANSACTIONS WITH SYSTEM.TRANSACTIONS
Another way to deal with transactions is by using
System.Transactions . These classes have been available since .NET
Framework 2.0 but have not been available with .NET Core 1.1. With
.NET Core 2.1, these types are back, and can be used from ADO.NET
(starting with version 4.5 of System.Data.SqlClient ) as well as Entity
Framework Core 2.1.
The System.Transactions namespace defines several classes for
transactions. Probably the most important class is Transaction . This
can be used to directly access ambient transactions, to give
information about the transaction, and to start a rollback if something
fails. The following table describes the properties and methods of the
Transaction class:
TRANSACTION
CLASS MEMBER DESCRIPTION
Current The property Current is a static property.
Transaction.Current returns an ambient
transaction if one exists. Ambient
transactions are discussed later in this
chapter.
The IsolationLevel property returns an
object of type IsolationLevel .
IsolationLevel is an enumeration that
defines what access other transactions have
to the interim result of the transaction.
Check the section “Transactions with
IsolationLevel


ADO.NET” earlier in this chapter for more
information about isolation levels.
TransactionInformation The TransactionInformation property
returns a TransactionInformation object,
which provides information about the
current state of the transaction, the time
when the transaction was created, and
transaction identifiers.
Rollback
With the Rollback method, you can abort a
transaction and undo everything that is part
of the transaction, setting all results to the
state before the transaction.
DependentClone
With the DependentClone method, you can
create a transaction that depends on the
current transaction.
TransactionCompleted
TransactionCompleted is an event that is fired
when the transaction is completed—either
successfully or unsuccessfully. With an event
handler object of type
TransactionCompletedEventHandler , you can
access the Transaction object and read its
state.
The sample application (a .NET Core Console App) showing the
features of System.Transactions makes use of the following
dependencies and namespaces:
Dependencies
Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.Json
System.Data.SqlClient
Namespaces
Microsoft.Extensions.Configuration


System
System.Data.SqlClient
System.IO
System.Linq
System.Threading.Tasks
System.Transactions
The code sample defines a Utilities class with some helper methods
that are used throughout the different samples. (code file
SystemTransactionSamples/Utilities.cs ):
public class Utilities
{
public static bool AbortTx()
{
Console.WriteLine("Abort the transaction (y/n)?");
return Console.ReadLine().ToLower().Equals("y");
}
public static void DisplayTransactionInformation(string
title,
TransactionInformation info)
{
if (info == null) throw new
ArgumentNullException(nameof(info));
Console.WriteLine(title);
Console.WriteLine($"Creation time:
{info.CreationTime:T}");
Console.WriteLine($"Status: {info.Status}");
Console.WriteLine($"Local Id: {info.LocalIdentifier}");
Console.WriteLine($"Distributed Id:
{info.DistributedIdentifier}");
Console.WriteLine();
}
}
NOTE


The sample code asks the user if the transaction should be
aborted. This is good for demonstration purposes, but you should
never have user interactions within a transaction in a real
application. Records are locked while a transaction is active. You
don’t want to hinder other users to work because one user has
locks opened because of these locks.
You also need to pay attention to the transaction timeout. If the
user input takes more time than the transaction timeout, the
transaction is aborted.
This sample makes use of the same database as the previous samples,
but there’s an important change. This time the Book type is defined to
map information from the Books table (code file
SystemTransactionSamples/Book.cs ):
public class Book
{
public int Id { get; set; }
public string Title { get; set; }
public string Publisher { get; set; }
public string Isbn { get; set; }
public DateTime? ReleaseDate { get; set; }
}
The BookData class maps the Book type to the database and implements
the AddBookAsync method to add a new record to the Books table. The
implementation looks like the implementation you’ve seen it before
when invoking the ExecuteNonQuery method to insert a new record, but
there is an important difference. This time, the
System.Transactions.Transaction is enlisted using the SqlConnection
method EnlistTransaction . This way the SqlConnection participates
with the outcome of this transaction (code file
SystemTransactionSamples/BookData.cs ):
public class BookData
{
public async Task AddBookAsync(Book book, Transaction tx)
{
using (SqlConnection connection = new
SqlConnection(GetConnectionString()))
{


string sql = "INSERT INTO [ProCSharp].[Books] ([Title],
[Publisher], " +
"[Isbn], [ReleaseDate]) " +
"VALUES (@Title, @Publisher, @Isbn, @ReleaseDate)";
await connection.OpenAsync();
if (tx != null)
{
connection.EnlistTransaction(tx);
}
var command = connection.CreateCommand();
command.CommandText = sql;
command.Parameters.AddWithValue("Title", book.Title);
command.Parameters.AddWithValue("Publisher",
book.Publisher);
command.Parameters.AddWithValue("Isbn", book.Isbn);
command.Parameters.AddWithValue("ReleaseDate",
book.ReleaseDate);
await command.ExecuteNonQueryAsync();
}
}
//...
}
Committable Transactions
The Transaction class cannot be committed programmatically; it does
not have a method to commit the transaction. The base class
Transaction just supports aborting the transaction. The only
transaction class that supports a commit is the class
CommittableTransaction .
In the CommittableTransactionAsync method, first a transaction of type
CommittableTransaction is created, and information is shown to the
console. Then a Book object is created, which is written to the database
from the AddBookAsync method. If you verify the record in the database
from outside the transaction, you cannot see the book added until the
transaction is completed. If the transaction fails, there is a rollback,
and the book is not written to the database.
After the AddBookAsync method is invoked, the AbortTx method is called
to ask the user whether the transaction should be aborted. If the user
aborts, an exception of type ApplicationException is thrown and, in


the catch block, a rollback is performed by calling the method Rollback
of the Transaction class. The record is not written to the database. If
the user does not abort, the Commit method commits the transaction,
and the final state of the transaction is committed (code file
SystemTransactionSamples/Program.cs ):
static async Task CommittableTransactionAsync()
{
var tx = new CommittableTransaction();
DisplayTransactionInformation("TX created",
tx.TransactionInformation);
try
{
var b = new Book
{
Title = "A Dog in The House",
Publisher = "Pet Show",
Isbn = RandomIsbn(),
ReleaseDate = new DateTime(2018, 11, 24)
};
var data = new BookData();
await data.AddBookAsync(b, tx);
if (AbortTx())
{
throw new ApplicationException("transaction abort by
the user");
}
tx.Commit();
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
Console.WriteLine();
tx.Rollback();
}
DisplayTransactionInformation("TX completed",
tx.TransactionInformation);
}
As shown in the following output of the application, the transaction is
active and has a local identifier. In addition, the user has chosen to
abort the transaction. After the transaction is finished, you can see the


aborted state:
TX created
Creation time: 7:29:36 PM
Status: Active
Local Id: c090c903-3f74-44b2-92a7-7607e33b787c:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Abort the transaction (y/n)?
y
transaction abort by the user
TX completed
Creation time: 7:29:36 PM
Status: Aborted
Local Id: c090c903-3f74-44b2-92a7-7607e33b787c:1
Distributed Id: 00000000-0000-0000-0000-000000000000
With the second output of the application that follows, the transaction
is not aborted by the user. The transaction has the status Committed,
and the data is written to the database:
TX created
Creation time: 7:30:59 PM
Status: Active
Local Id: e60feb38-e3b2-4ede-992d-f93296a363a4:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Abort the transaction (y/n)?
n
TX completed
Creation time: 7:30:59 PM
Status: Committed
Local Id: e60feb38-e3b2-4ede-992d-f93296a363a4:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Dependent Transactions
With dependent transactions, you can influence one transaction
among multiple tasks or threads. A dependent transaction depends on
another transaction and influences the outcome of the transaction.
The sample method DependentTransactions first creates a root
transaction using CommittableTransaction . This transaction object is
used to create a dependent transaction with the method


DependentClone .
This DependentTransaction is passed to a separate task
in the local function UsingDependentTransactionAsync . A dependent
transaction can be marked as completed as is done invoking the
Complete method.
The DependentClone method requires and argument of type
DependentCloneOption , which is an enumeration with the values
BlockCompleteUntilComplete and RollbackIfNotComplete . This option
is important if the root transaction completes before the dependent
transaction. Setting the option to RollbackIfNotComplete , the
transaction aborts if the dependent transaction didn’t invoke the
Complete method before the Commit method of the root transaction.
Setting the option to BlockCommitUntilComplete , the method Commit
waits (blocks) until the outcome is defined by all dependent
transactions.
Next, the Commit method of the CommittableTransaction class is
invoked if the user does not abort the transaction (code file
SystemTransactions/Program.cs ):
static void DependentTransactions()
{
async Task
UsingDependentTransactionAsync(DependentTransaction dtx)
{
dtx.TransactionCompleted += (sender, e) =>
DisplayTransactionInformation("Depdendent TX
completed",
e.Transaction.TransactionInformation);
DisplayTransactionInformation("Dependent Tx",
dtx.TransactionInformation);
await Task.Delay(2000);
dtx.Complete();
DisplayTransactionInformation("Dependent Tx send
complete",
dtx.TransactionInformation);
}
var tx = new CommittableTransaction();
DisplayTransactionInformation("Root Tx created",
tx.TransactionInformation);


try
{
DependentTransaction depTx = tx.DependentClone(
DependentCloneOption.BlockCommitUntilComplete);
Task t1 = Task.Run(() =>
UsingDependentTransactionAsync(depTx));
if (AbortTx())
{
throw new ApplicationException("transaction abort by
the user");
}
tx.Commit();
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
tx.Rollback();
}
DisplayTransactionInformation("TX completed",
tx.TransactionInformation);
}
The following output of the application shows the root transaction and
its identifier. Because of the option
DependentCloneOption.BlockCommitUntilComplete , the root transaction
waits in the Commit method until the outcome of the dependent
transaction is defined. As soon as the dependent transaction is
finished, the transaction is committed:
Root Tx created
Creation time: 7:50:32 PM
Status: Active
Local Id: 87268b8c-076d-4823-af58-944b861bd4fe:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Abort the transaction (y/n)?
Dependent Tx
Creation time: 7:50:32 PM
Status: Active
Local Id: 87268b8c-076d-4823-af58-944b861bd4fe:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Dependent Tx send complete


Creation time: 7:50:32 PM
Status: Active
Local Id: 87268b8c-076d-4823-af58-944b861bd4fe:1
Distributed Id: 00000000-0000-0000-0000-000000000000
n
Depdendent TX completed
Creation time: 7:50:32 PM
Status: Committed
Local Id: 87268b8c-076d-4823-af58-944b861bd4fe:1
Distributed Id: 00000000-0000-0000-0000-000000000000
TX completed
Creation time: 7:50:32 PM
Status: Committed
Local Id: 87268b8c-076d-4823-af58-944b861bd4fe:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Ambient Transactions
The biggest advantage of the classes in the System.Transactions
namespace is the ambient transaction feature. With ambient
transactions, there is no need to manually enlist a connection with a
transaction; this is done automatically from the resources supporting
ambient transactions.
An ambient transaction is associated with the current thread. You can
get and set the ambient transaction with the static property
Transaction.Current . APIs supporting ambient transactions check this
property to get an ambient transaction and to enlist with the
transaction. ADO.NET connections support ambient transactions.
You can create a CommittableTransaction object and assign it to the
property Transaction.Current to initialize the ambient transaction.
Another way (and typically the preferred way) is with the
TransactionScope class. The constructor of TransactionScope creates
an ambient transaction.
NOTE
If an ADO.NET connection should not enlist with an ambient


transaction, you can set the value Enlist=false with the
connection string.
For using the TransactionScope , another AddBook method is created
that just adds a record to the Books table without explicitly enlisting to
a transaction (code file SystemTransactionSamples/BookData.cs ):
public void AddBook(Book book)
{
using (SqlConnection connection = new
SqlConnection(GetConnectionString()))
{
string sql = "INSERT INTO [ProCSharp].[Books] ([Title],
[Publisher], " +
"[Isbn], [ReleaseDate]) " +
"VALUES (@Title, @Publisher, @Isbn, @ReleaseDate)";
connection.Open();
var command = connection.CreateCommand();
command.CommandText = sql;
command.Parameters.AddWithValue("Title", book.Title);
command.Parameters.AddWithValue("Publisher",
book.Publisher);
command.Parameters.AddWithValue("Isbn", book.Isbn);
command.Parameters.AddWithValue("ReleaseDate",
book.ReleaseDate);
command.ExecuteNonQuery();
}
}
Important methods of the TransactionScope are Complete and Dispose .
The Complete method sets the success bit for the scope, and the
Dispose method finishes the scope and commits or rolls back the
transaction if the scope is a root scope.
Because the TransactionScope class implements the IDisposable
interface, you can define the scope with the using statement. The
default constructor creates a new transaction. In the following code
snippet, immediately after creating the TransactionScope instance, a
lambda expression invoking DisplayTransactionInformation is
assigned to the TransactionCompleted event to get information when


the transaction is completed. Before this event fires, immediately after
the creation of the transaction, the property Transaction.Current is
accessed to display the current state of the transaction on the console.
After that, a new Book object is created, and the previously created
AddBook method is invoked. In case the user does not abort the
transaction, the Complete method of the TransactionScope is invoked.
The end of the using block invokes the Dispose method of the
TransactionScope . If the Complete method was invoked, and if every
other party participating in the transaction (for example, the SQL
connection) has the success bit set, the transaction is committed. In
case any party was not successful with the transaction that includes
the TransactionScope when Complete was not invoked, the transaction
is aborted (code file SystemTransactionSamples/Program.cs ):
static void AmbientTransactions()
{
using (var scope = new TransactionScope())
{
Transaction.Current.TransactionCompleted += (sender, e)
=>
DisplayTransactionInformation("TX completed",
e.Transaction.TransactionInformation);
DisplayTransactionInformation("Ambient TX created",
Transaction.Current.TransactionInformation);
var b = new Book
{
Title = "Cats in The House",
Publisher = "Pet Show",
Isbn = RandomIsbn(),
ReleaseDate = new DateTime(2019, 11, 24)
};
var data = new BookData();
data.AddBook(b);
if (!AbortTx())
{
scope.Complete();
}
else
{
Console.WriteLine("transaction abort by the user");
}


}
// scope.Dispose();
}
When you run the application, you can see an active ambient
transaction after an instance of the TransactionSope class is created.
The last output of the application is the output from the
TransactionCompleted event handler to display the finished transaction
state:
Ambient TX created
Creation time: 7:53:10 AM
Status: Active
Local Id: 0e28b708-9dd7-4b17-bf41-c09f963928cf:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Abort the transaction (y/n)?
n
TX completed
Creation time: 7:53:10 AM
Status: Committed
Local Id: 0e28b708-9dd7-4b17-bf41-c09f963928cf:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Nested Scopes with Ambient Transactions
With the TransactionScope class you can also nest scopes. The nested
scope can be directly inside an outer scope or within a method that is
invoked from the scope. A nested scope can use the same transaction
as the outer scope, suppress the transaction, or create a new
transaction that is independent from the outer scope. The requirement
for the scope is defined with a TransactionScopeOption enumeration
that is passed to the constructor of the TransactionScope class.
The following table describes the values and corresponding
functionality available with the TransactionScope enumeration.
TRANSACTIONSCOPE DESCRIPTION
MEMBER
Required
Required defines that the scope requires a
transaction. If the outer scope already
contains an ambient transaction, the inner


RequiresNew
Suppress
scope uses the existing transaction. If an
ambient transaction does not exist, a new
transaction is created. If both scopes share
the same transaction, every scope
influences the outcome of the transaction.
Only if all scopes set the success bit, the
transaction can commit. If one scope does
not invoke the Complete method before the
root scope is disposed, the transaction is
aborted.
RequiresNew always creates a new
transaction. If the outer scope already
defines a transaction, the transaction from
the inner scope is completely independent.
Both transactions can commit or abort
independently.
With Suppress , the scope does not contain
an ambient transaction, whether the outer
scope contains a transaction.
The next example defines two scopes. The inner scope is configured to
require a new transaction with the option
TransactionScopeOption.RequiresNew (code file
SystemTransactionSamples/Program.cs ):
static void NestedScopes()
{
using (var scope = new TransactionScope())
{
Transaction.Current.TransactionCompleted += (sender, e)
=>
DisplayTransactionInformation("TX completed",
e.Transaction.TransactionInformation);
DisplayTransactionInformation("Ambient TX created",
Transaction.Current.TransactionInformation);
var b = new Book
{
Title = "Dogs in The House",
Publisher = "Pet Show",


Isbn = RandomIsbn(),
ReleaseDate = new DateTime(2020, 11, 24)
};
var data = new BookData();
data.AddBook(b);
using (var scope2 = new
TransactionScope(TransactionScopeOption.RequiresNew))
{
Transaction.Current.TransactionCompleted += (sender, e)
=>
DisplayTransactionInformation("Inner TX completed",
e.Transaction.TransactionInformation);
DisplayTransactionInformation("Inner TX scope",
Transaction.Current.TransactionInformation);
var b1 = new Book
{
Title = "Dogs and Cats in The House",
Publisher = "Pet Show",
Isbn = RandomIsbn(),
ReleaseDate = new DateTime(2021, 11, 24)
};
var data1 = new BookData();
data1.AddBook(b1);
scope2.Complete();
}
scope.Complete();
}
When you run the application, you can see different transaction
identifiers of the outer scope and the inner scope where the inner
scope appends :2 to the GUID, and the outer scope :1 . These
transactions are independent of each other:
Ambient TX created
Creation time: 8:20:09 AM
Status: Active
Local Id: d4e3a180-49d6-4c16-b4c9-89a9c6d4ace9:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Inner TX scope
Creation time: 8:20:11 AM
Status: Active


Local Id: d4e3a180-49d6-4c16-b4c9-89a9c6d4ace9:2
Distributed Id: 00000000-0000-0000-0000-000000000000
Inner TX completed
Creation time: 8:20:11 AM
Status: Committed
Local Id: d4e3a180-49d6-4c16-b4c9-89a9c6d4ace9:2
Distributed Id: 00000000-0000-0000-0000-000000000000
TX completed
Creation time: 8:20:09 AM
Status: Committed
Local Id: d4e3a180-49d6-4c16-b4c9-89a9c6d4ace9:1
Distributed Id: 00000000-0000-0000-0000-000000000000
If you change the creation of the inner scope to use
TransactionScopeOption.Required , you can see the same transaction is
used with the outer and the inner scope:
Ambient TX created
Creation time: 8:23:52 AM
Status: Active
Local Id: 95181f71-0268-40f0-8f12-471a01a83638:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Inner TX scope
Creation time: 8:23:52 AM
Status: Active
Local Id: 95181f71-0268-40f0-8f12-471a01a83638:1
Distributed Id: 00000000-0000-0000-0000-000000000000
TX completed
Creation time: 8:23:52 AM
Status: Committed
Local Id: 95181f71-0268-40f0-8f12-471a01a83638:1
Distributed Id: 00000000-0000-0000-0000-000000000000
Inner TX completed
Creation time: 8:23:52 AM
Status: Committed
Local Id: 95181f71-0268-40f0-8f12-471a01a83638:1
Distributed Id: 00000000-0000-0000-0000-000000000000
SUMMARY
In this chapter, you’ve seen the core foundation of ADO.NET. You first


looked at the SqlConnection object to open a connection to SQL Server.
You’ve seen how to retrieve the connection string from a configuration
file.
This chapter explained how to use connections properly so that they
can be closed as early as possible, which preserves valuable resources.
All the connection classes implement the IDisposable interface, called
when the object is placed within a using statement. If there is one
thing you should take away from this chapter, it is the importance of
closing database connections as early as possible.
With commands you’ve seen passing parameters, getting a single
return value, and retrieving records using the SqlDataReader . You’ve
also seen how stored procedures can be invoked using the SqlCommand
object.
Like other parts of the framework where processing can take some
time, ADO.NET implements the task-based async pattern that was
shown as well. You’ve also seen how to create and use transactions
with ADO.NET.
With System.Transactions , you’ve seen a different way to deal with
transactions—transactions that can be independent of the SQL
connection whereas the SQL connection automatically enlists to the
transaction when ambient transactions are used.
The next chapter is about Entity Framework Core that offers an
abstraction to data access by offering a mapping between relations in
the database and object hierarchies and uses ADO.NET classes behind
the scenes when you’re accessing a relational database.