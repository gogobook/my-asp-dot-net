

Collections
WHAT’S IN THIS CHAPTER?
Understanding collection interfaces and types
Working with lists, queues, and stacks
Working with linked and sorted lists
Using dictionaries and sets
Evaluating performance
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
http://www.wrox.com on the Download Code tab. The source code is
also available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory Collections .
The code for this chapter is divided into the following major
examples:
List Samples
Queue Sample
Linked List Sample
Sorted List Sample


Dictionary Sample
Set Sample
OVERVIEW
Chapter 7, “Arrays,” covers arrays and the interfaces implemented by
the Array class. The size of arrays is fixed. If the number of elements is
dynamic, you should use a collection class instead of an array.
is a collection class that can be compared to arrays; but there
are also other kinds of collections: queues, stacks, linked lists,
dictionaries, and sets. The other collection classes have partly different
APIs to access the elements in the collection and often a different
internal structure for how the items are stored in memory. This
chapter covers these collection classes and their differences, including
performance differences.
List<T>
COLLECTION INTERFACES AND TYPES
Most collection classes are in the System.Collections and
System.Collections.Generic namespaces. Generic collection classes
are located in the System.Collections.Generic namespace. Collection
classes that are specialized for a specific type are located in the
System.Collections.Specialized namespace. Thread-safe collection
classes are in the System.Collections.Concurrent namespace.
Immutable collection classes are in the System.Collections.Immutable
namespace.
Of course, there are also other ways to group collection classes.
Collections can be grouped into lists, collections, and dictionaries
based on the interfaces that are implemented by the collection class.
**NOTE**
You can read detailed information about the interfaces
IEnumerable and IEnumerator in Chapter 7.


The following table describes the most important interfaces
implemented by collections and lists.
INTERFACE
IEnumerable<T>
ICollection<T>
IList<T>
ISet<T>
IDictionary<TKey,
TValue>
ILookup<TKey,
TValue>
DESCRIPTION
The interface IEnumerable is required by the
foreach statement. This interface defines the
method GetEnumerator , which returns an
enumerator that implements the IEnumerator
interface.
ICollection<T> is implemented by generic
collection classes. With this you can get the
number of items in the collection Count
property), and copy the collection to an array
( CopyTo method). You can also add and remove
items from the collection ( Add , Remove , Clear ).
The IList<T> interface is for lists where
elements can be accessed from their position.
This interface defines an indexer, as well as
ways to insert or remove items from specific
positions (Insert , RemoveAt methods). IList<T>
derives from ICollection<T> .
This interface is implemented by sets. Sets
allow combining different sets into a union,
getting the intersection of two sets, and
checking whether two sets overlap. ISet<T>
derives from ICollection<T> .
The interface IDictionary<TKey, TValue> is
implemented by generic collection classes that
have a key and a value. With this interface all
the keys and values can be accessed, items can
be accessed with an indexer of type key, and
items can be added or removed.
Like the IDictionary<TKey, TValue> interface,
lookups have keys and values. However, with
lookups the collection can contain multiple


values with one key.
IComparer<T>
The interface IComparer<T> is implemented by
a comparer and used to sort elements inside a
collection with the Compare method.
IEqualityComparer<T> IEqualityComparer<T> is implemented by a
comparer that can be used for keys in a
dictionary. With this interface the objects can
be compared for equality.
LISTS
For resizable lists, .NET offers the generic class List<T> . This class
implements the IList , ICollection , IEnumerable , IList<T> ,
ICollection<T> , and IEnumerable<T> interfaces.
The following examples use the members of the class Racer as
elements to be added to the collection to represent a Formula-1 racer.
This class has five properties: Id , FirstName , LastName , Country , and the
number of Wins . With the constructors of the class, the name of the
racer and the number of wins can be passed to set the members. The
method ToString is overridden to return the name of the racer. The
class Racer also implements the generic interface IComparable<T> for
sorting racer elements and IFormattable (code file
ListSamples/Racer.cs ):
public class Racer: IComparable<Racer>, IFormattable
{
public int Id { get; }
public string FirstName { get; }
public string LastName { get; }
public string Country { get; }
public int Wins { get; }
public Racer(int id, string firstName, string lastName,
string country)
:this(id, firstName, lastName, country, wins: 0)
{ }
public Racer(int id, string firstName, string lastName,
string country,int wins)
{


Id = id;
FirstName = firstName;
LastName = lastName;
Country = country;
Wins = wins;
}
public override string ToString() => $"{FirstName}
{LastName}";
public string ToString(string format, IFormatProvider
formatProvider)
{
if (format == null) format = "N";
switch (format.ToUpper())
{
case "N": // name
return ToString();
case "F": // first name
return FirstName;
case "L": // last name
return LastName;
case "W": // Wins
return $"{ToString()}, Wins: {Wins}";
case "C": // Country
return $"{ToString()}, Country: {Country}";
case "A": // All
return $"{ToString()}, Country: {Country} Wins:
{Wins}";
default:
throw new
FormatException(String.Format(formatProvider,
$"Format {format} is not supported"));
}
}
public string ToString(string format) => ToString(format,
null);
public int CompareTo(Racer other)
{
int compare = LastName?.CompareTo(other?.LastName) ?? -1;
if (compare == 0)
{
return FirstName?.CompareTo(other?.FirstName) ?? -1;
}
return compare;
}


}
Creating Lists
You can create list objects by invoking the default constructor. With
the generic class List<T> , you must specify the type for the values of
the list with the declaration. The following code shows how to declare
a List<T> with int and a list with Racer elements. ArrayList is a non-
generic list that accepts any Object type for its elements.
Using the default constructor creates an empty list. As soon as
elements are added to the list, the capacity of the list is extended to
allow 4 elements. If the fifth element is added, the list is resized to
allow 8 elements. If 8 elements are not enough, the list is resized again
to contain 16 elements. With every resize the capacity of the list is
doubled.
var intList = new List<int>();
var racers = new List<Racer>();
When the capacity of the list changes, the complete collection is
reallocated to a new memory block. With the implementation of
List<T> , an array of type T is used. With reallocation, a new array is
created, and Array.Copy copies the elements from the old array to the
new array. To save time, if you know the number of elements in
advance, that should be in the list; you can define the capacity with the
constructor. The following example creates a collection with a capacity
of 10 elements. If the capacity is not large enough for the elements
added, the capacity is resized to 20 and then to 40 elements——doubled
again:
List<int> intList = new List<int>(10);
You can get and set the capacity of a collection by using the Capacity
property:
intList.Capacity = 20;
The capacity is not the same as the number of elements in the
collection. The number of elements in the collection can be read with
the Count property. Of course, the capacity is always larger or equal to


the number of items. As long as no element was added to the list, the
count is 0:
Console.WriteLine(intList.Count);
If you are finished adding elements to the list and don’t want to add
any more, you can get rid of the unneeded capacity by invoking the
TrimExcess method; however, because the relocation takes time,
TrimExcess has no effect if the item count is more than 90 percent of
capacity:
intList.TrimExcess();
Collection Initializers
You can also assign values to collections using collection initializers.
The syntax of collection initializers is similar to array initializers,
which are explained in Chapter 7. With a collection initializer, values
are assigned to the collection within curly brackets at the time the
collection is initialized:
var intList = new List<int>() {1, 2};
var stringList = new List<string>() { "one", "two" };
**NOTE**
Collection initializers are not reflected within the IL code of the
compiled assembly. The compiler converts the collection
initializer to invoke the Add method for every item from the
initializer list.
Adding Elements
You can add elements to the list with the Add method, shown in the
following example. The generic instantiated type defines the
parameter type of the Add method:
var intList = new List<int>();


intList.Add(1);
intList.Add(2);
var stringList = new List<string>();
stringList.Add("one");
stringList.Add("two");
The variable racers is defined as type List<Racer>. With the new
operator, a new object of the same type is created. Because the class
List<T> was instantiated with the concrete class Racer , now only Racer
objects can be added with the Add method. In the following sample
code, five Formula-1 racers are created and added to the collection.
The first three are added using the collection initializer, and the last
two are added by explicitly invoking the Add method (code file
ListSamples/Program.cs ):
var graham = new Racer(7, "Graham", "Hill", "UK", 14);
var emerson = new Racer(13, "Emerson", "Fittipaldi",
"Brazil", 14);
var mario = new Racer(16, "Mario", "Andretti", "USA", 12);
var racers = new List<Racer>(20) {graham, emerson, mario};
racers.Add(new Racer(24, "Michael", "Schumacher", "Germany",
91));
racers.Add(new Racer(27, "Mika", "Hakkinen", "Finland", 20));
With the AddRange method of the List<T> class, you can add multiple
elements to the collection at once. The method AddRange accepts an
object of type IEnumerable<T> , so you can also pass an array as shown
here (code file ListSamples/Program.cs ):
racers.AddRange(new Racer[] {
new Racer(14, "Niki", "Lauda", "Austria", 25),
new Racer(21, "Alain", "Prost", "France", 51)});
**NOTE**
The collection initializer can be used only during declaration of
the collection. The AddRange method can be invoked after the
collection is initialized. In case you get the data dynamically after
creating the collection, you need to invoke AddRange .


If you know some elements of the collection when instantiating the
list, you can also pass any object that implements IEnumerable<T> to
the constructor of the class. This is very similar to the AddRange
method (code file ListSamples/Program.cs ):
var racers = new List<Racer>(
new Racer[] {
new Racer(12, "Jochen", "Rindt", "Austria", 6),
new Racer(22, "Ayrton", "Senna", "Brazil", 41) });
Inserting Elements
You can insert elements at a specified position with the Insert method
(code file ListSamples/Program.cs ):
racers.Insert(3, new Racer(6, "Phil", "Hill", "USA", 3));
The method InsertRange offers the capability to insert a number of
elements, similar to the AddRange method shown earlier.
If the index set is larger than the number of elements in the collection,
an exception of type ArgumentOutOfRangeException is thrown.
Accessing Elements
All classes that implement the IList and IList<T> interface offer an
indexer, so you can access the elements by using an indexer and
passing the item number. The first item can be accessed with an index
value 0. By specifying racers[3] , for example, you access the fourth
element of the list:
Racer r1 = racers[3];
When you use the Count property to get the number of elements, you
can do a for loop to iterate through every item in the collection, and
you can use the indexer to access every item (code file
ListSamples/Program.cs ):
for (int i = 0; i < racers.Count; i++)
{
Console.WriteLine(racers[i]);
}


**NOTE**
Indexed access to collection classes is available with ArrayList ,
StringCollection , and List<T> .
Because List<T> implements the interface IEnumerable , you can
iterate through the items in the collection using the foreach statement
as well (code file ListSamples/Program.cs ):
foreach (var r in racers)
{
Console.WriteLine(r);
}
**NOTE**
Chapter 7 explains how the foreach statement is resolved by the
compiler to make use of the IEnumerable and IEnumerator
interfaces.
Removing Elements
You can remove elements by index or pass the item that should be
removed. Here, the fourth element is removed from the collection:
racers.RemoveAt(3);
You can also directly pass a Racer object to the Remove method to
remove this element. Removing by index is faster, because here the
collection must be searched for the item to remove. The Remove
method first searches in the collection to get the index of the item with
the IndexOf method and then uses the index to remove the item.
IndexOf first checks whether the item type implements the interface
IEquatable<T> . If it does, the Equals method of this interface is invoked
to find the item in the collection that is the same as the one passed to


the method. If this interface is not implemented, the Equals method of
the Object class is used to compare the items. The default
implementation of the Equals method in the Object class does a
bitwise compare with value types, but compares only references with
reference types.
**NOTE**
Chapter 6, “Operators and Casts,” explains how you can override
the Equals method.
In the following example, the racer referenced by the variable graham is
removed from the collection. The variable graham was created earlier
when the collection was filled. Because the interface IEquatable<T>
and the Object.Equals method are not overridden with the Racer class,
you cannot create a new object with the same content as the item that
should be removed and pass it to the Remove method (code file
ListSamples/Program.cs ):
if (!racers.Remove(graham))
{
Console.WriteLine("object not found in collection");
}
The method RemoveRange removes a number of items from the
collection. The first parameter specifies the index where the removal
of items should begin; the second parameter specifies the number of
items to be removed:
int index = 3;
int count = 5;
racers.RemoveRange(index, count);
To remove all items with some specific characteristics from the
collection, you can use the RemoveAll method. This method uses the
Predicate<T> parameter when searching for elements, which is
discussed next. To remove all elements from the collection, use the
Clear method defined with the ICollection<T> interface.


Searching
There are different ways to search for elements in the collection. You
can get the index to the found item, or the item itself. You can use
methods such as IndexOf , LastIndexOf , FindIndex , FindLastIndex , Find ,
and FindLast . To just check whether an item exists, the List<T> class
offers the Exists method.
The method IndexOf requires an object as parameter and returns the
index of the item if it is found inside the collection. If the item is not
found, –1 is returned. Remember that IndexOf is using the
IEquatable<T> interface to compare the elements ( code file
ListSamples/Program.cs ):
int index1 = racers.IndexOf(mario);
With the IndexOf method, you can also specify that the complete
collection should not be searched, instead specifying an index where
the search should start and the number of elements that should be
iterated for the comparison.
Instead of searching a specific item with the IndexOf method, you can
search for an item that has some specific characteristics that you can
define with the FindIndex method. FindIndex requires a parameter of
type Predicate :
public int FindIndex(Predicate<T> match);
The Predicate<T> type is a delegate that returns a Boolean value and
requires type T as parameter. If the predicate returns true , there’s a
match, and the element is found. If it returns false , the element is not
found, and the search continues.
public delegate bool Predicate<T>(T obj);
With the List<T> class that is using Racer objects for type T , you can
pass the address of a method that returns a bool and defines a
parameter of type Racer to the FindIndex method. Finding the first
racer of a specific country, you can create the FindCountry class as
shown next. The FindCountryPredicate method has the signature and
return type defined by the Predicate<T> delegate. The Find method


uses the variable country to search for a country that you can pass with
the constructor of the class (code file ListSamples/FindCountry.cs ):
public class FindCountry
{
public FindCountry(string country) => _country = country;
private string _country;
public bool FindCountryPredicate(Racer racer) =>
racer?.Country == _country;
}
With the FindIndex method, you can create a new instance of the
FindCountry class, pass a country string to the constructor, and pass
the address of the Find method. In the following example, after
FindIndex completes successfully, index2 contains the index of the first
item where the Country property of the racer is set to Finland (code file
ListSamples/Program.cs ):
int index2 = racers.FindIndex(new
FindCountry("Finland").FindCountryPredicate);
Instead of creating a class with a handler method, you can use a
lambda expression here as well. The result is the same as before. Now
the lambda expression defines the implementation to search for an
item where the Country property is set to Finland :
int index3 = racers.FindIndex(r => r.Country == "Finland");
Like the IndexOf method, with the FindIndex method you can also
specify the index where the search should start and the count of items
that should be iterated through. To do a search for an index beginning
from the last element in the collection, you can use the FindLastIndex
method.
The method FindIndex returns the index of the found item. Instead of
getting the index, you can also go directly to the item in the collection.
The Find method requires a parameter of type Predicate<T> , much as
the FindIndex method. The Find method in the following example
searches for the first racer in the list that has the FirstName property
set to Niki . Of course, you can also do a FindLast search to find the last


item that fulfills the predicate.
Racer racer = racers.Find(r => r.FirstName == "Niki");
To get not only one but all the items that fulfill the requirements of a
predicate, you can use the FindAll method. The FindAll method uses
the same Predicate<T> delegate as the Find and FindIndex methods.
The FindAll method does not stop when the first item is found; instead
the FindAll method iterates through every item in the collection and
returns all items for which the predicate returns true .
With the FindAll method invoked in the next example, all racer items
are returned where the property Wins is set to more than 20. All racers
who won more than 20 races are referenced from the bigWinners list:
List<Racer> bigWinners = racers.FindAll(r => r.Wins > 20);
Iterating through the variable bigWinners with a foreach statement
gives the following result:
foreach (Racer r in bigWinners)
{
Console.WriteLine($"{r:A}");
}
Michael Schumacher, Germany Wins: 91
Niki Lauda, Austria Wins: 25
Alain Prost, France Wins: 51
The result is not sorted, but you’ll see that done next.
**NOTE**
Format specifiers and the IFormattable interface is discussed in
detail in Chapter 9, “Strings and Regular Expressions.”
Sorting
The List<T> class enables sorting its elements by using the Sort
method. Sort uses the quick sort algorithm whereby all elements are


compared until the complete list is sorted.
You can use several overloads of the Sort method. The arguments that
can be passed are a generic delegate Comparison<T> , the generic
interface IComparer<T> , and a range together with the generic interface
IComparer<T>:
public
public
public
public
void
void
void
void
List<T>.Sort();
List<T>.Sort(Comparison<T>);
List<T>.Sort(IComparer<T>);
List<T>.Sort(Int32, Int32, IComparer<T>);
Using the Sort method without arguments is possible only if the
elements in the collection implement the interface IComparable .
Here, the class Racer implements the interface IComparable<T> to sort
racers by the last name:
racers.Sort();
If you need to do a sort other than the default supported by the item
types, you need to use other techniques, such as passing an object that
implements the IComparer<T> interface.
The class RacerComparer implements the interface IComparer<T> for
Racer types. This class enables you to sort by the first name, last name,
country, or number of wins. The kind of sort that should be done is
defined with the inner enumeration type CompareType . The CompareType
is set with the constructor of the class RacerComparer . The interface
IComparer<Racer> defines the method Compare , which is required for
sorting. In the implementation of this method, the Compare and
CompareTo methods of the string and int types are used (code file
ListSamples/RacerComparer.cs ):
public class RacerComparer : IComparer<Racer>
{
public enum CompareType
{
FirstName,
LastName,
Country,
Wins
}
private CompareType _compareType;


public RacerComparer(CompareType compareType)
{
_compareType = compareType;
}
public int Compare(Racer x, Racer y)
{
if (x == null && y == null) return 0;
if (x == null) return -1;
if (y == null) return 1;
int result;
switch (_compareType)
{
case CompareType.FirstName:
return string.Compare(x.FirstName, y.FirstName);
case CompareType.LastName:
return string.Compare(x.LastName, y.LastName);
case CompareType.Country:
result = string.Compare(x.Country, y.Country);
if (result == 0)
return string.Compare(x.LastName, y.LastName);
else
return result;
case CompareType.Wins:
return x.Wins.CompareTo(y.Wins);
default:
throw new ArgumentException("Invalid Compare Type");
}
}
}
**NOTE**
The Compare method returns 0 if the two elements passed to it are
equal with the order. If a value less than 0 is returned, the first
argument is less than the second. With a value larger than 0, the
first argument is greater than the second. Passing null with an
argument, the method shouldn’t throw a NullReferenceException .
Instead, null should take its place before any other element; thus
–1 is returned if the first argument is null, and +1 if the second
argument is null.


You can now use an instance of the RacerComparer class with the Sort
method. Passing the enumeration RacerComparer.CompareType.Country
sorts the collection by the property Country :
racers.Sort(new
RacerComparer(RacerComparer.CompareType.Country));
Another way to do the sort is by using the overloaded Sort method,
which requires a Comparison<T> delegate:
public void List<T>.Sort(Comparison<T>);
Comparison<T> is a delegate to a method that has two parameters of
type T and a return type int . If the parameter values are equal, the
method must return 0 . If the first parameter is less than the second,
a
value less than zero must be returned; otherwise, a value greater than
zero is returned:
public delegate int Comparison<T>(T x, T y);
Now you can pass a lambda expression to the Sort method to do a sort
by the number of wins. The two parameters are of type Racer , and in
the implementation the Wins properties are compared by using the int
method CompareTo . Also in the implementation, r2 and r1 are used in
reverse order, so the number of wins is sorted in descending order.
After the method has been invoked, the complete racer list is sorted
based on the racer’s number of wins:
racers.Sort((r1, r2) => r2.Wins.CompareTo(r1.Wins));
You can also reverse the order of a complete collection by invoking the
Reverse method.
Read-Only Collections
After collections are created they are read/write, of course; otherwise,
you couldn’t fill them with any values. However, after the collection is
filled, you can create a read-only collection. The List<T> collection has
the method AsReadOnly that returns an object of type
ReadOnlyCollection<T> . The class ReadOnlyCollection<T> implements
the same interfaces as List<T> , but all methods and properties that


change the collection throw a NotSupportedException . Beside the
interfaces of List<T> , ReadOnlyCollection<T> also implements the
interfaces IReadOnlyCollection<T> and IReadOnlyList<T> . With the
members of these interfaces, the collection cannot be changed.
QUEUES
A queue is a collection whose elements are processed first in, first out
(FIFO), meaning the item that is put first in the queue is read first.
Examples of queues are standing in line at the airport, a human
resources queue to process employee applicants, print jobs waiting to
be processed in a print queue, and a thread waiting for the CPU in a
round-robin fashion. Sometimes the elements of a queue differ in their
priority. For example, in the queue at the airport, business passengers
are processed before economy passengers. In this case, multiple
queues can be used, one queue for each priority. At the airport this is
easily handled with separate check-in queues for business and
economy passengers. The same is true for print queues and threads.
You can have an array or a list of queues whereby one item in the array
stands for a priority. Within every array item there’s a queue, where
processing happens using the FIFO principle.
**NOTE**
Later in this chapter, a different implementation with a linked list
is used to define a list of priorities.
A queue is implemented with the Queue<T> class in the namespace
System.Collections.Generic . Internally, the Queue<T> class uses an
array of type T , similar to the List<T> type. It implements the
interfaces IEnumerable<T> and ICollection , but it doesn’t implement
ICollection<T> because this interface defines Add and Remove methods
that shouldn’t be available for queues.
The Queue<T> class does not implement the interface IList<T >, so you
cannot access the queue using an indexer. The queue just allows you to


add an item to it, which is put at the end of the queue (with the
Enqueue method), and to get items from the head of the queue (with
the Dequeue method).
Figure 10-1 shows the items of a queue. The Enqueue method adds
items to one end of the queue; the items are read and removed at the
other end of the queue with the Dequeue method. Invoking the Dequeue
method once more removes the next item from the queue.
FIGURE 10-1
Methods of the Queue<T> class are described in the following table.
SELECTED DESCRIPTION
QUEUE
<T>
MEMBERS
Count
Returns the number of items in the queue.
Enqueue
Adds an item to the end of the queue.
Dequeue
Reads and removes an item from the head of the queue.
If there are no more items in the queue when the
Dequeue method is invoked, an exception of type
InvalidOperationException is thrown.
Peek
Reads an item from the head of the queue but does not
remove the item.
TrimExcess
Resizes the capacity of the queue. The Dequeue method
removes items from the queue, but it doesn’t resize the
capacity of the queue. To get rid of the empty items at
the beginning of the queue, use the TrimExcess method.
When creating queues, you can use constructors similar to those used
with the List<T> type. The default constructor creates an empty queue,
but you can also use a constructor to specify the capacity. As items are


added to the queue, the capacity is increased to hold 4, 8, 16, and 32
items if the capacity is not defined. Like the List<T> class, the capacity
is always doubled as required. The default constructor of the non-
generic Queue class is different because it creates an initial array of 32
empty items. With an overload of the constructor, you can also pass
any other collection that implements the IEnumerable<T> interface that
is copied to the queue.
The following example demonstrating the use of the Queue<T> class is a
document management application. One thread is used to add
documents to the queue, and another thread reads documents from
the queue and processes them.
The items stored in the queue are of type Document . The Document class
defines a title and content (code file QueueSample/Document.cs ):
public class Document
{
public string Title { get; }
public string Content { get; }
public Document(string title, string content)
{
Title = title;
Content = content;
}
}
The DocumentManager class is a thin layer around the Queue<T> class. It
defines how to handle documents: adding documents to the queue
with the AddDocument method and getting documents from the queue
with the GetDocument method.
Inside the AddDocument method, the document is added to the end of
the queue using the Enqueue method. The first document from the
queue is read with the Dequeue method inside GetDocument . Because
multiple threads can access the DocumentManager concurrently, access
to the queue is locked with the lock statement.
**NOTE**


Threading and the lock statement are discussed in Chapter 21,
“Tasks and Parallel Programming.”
is a read-only Boolean property that returns true
if there are documents in the queue and false if not (code file
QueueSample/DocumentManager.cs ):
IsDocumentAvailable
public class DocumentManager
{
private readonly object _syncQueue = new object();
private readonly Queue<Document> _documentQueue = new
Queue<Document>();
public void AddDocument(Document doc)
{
lock (_syncQueue)
{
_documentQueue.Enqueue(doc);
}
}
public Document GetDocument()
{
Document doc = null;
lock (_syncQueue)
{
doc = _documentQueue.Dequeue();
}
return doc;
}
public bool IsDocumentAvailable => _documentQueue.Count >
0;
}
The class ProcessDocuments processes documents from the queue in a
separate task. The only method that can be accessed from the outside
is Start . In the Start method, a new task is instantiated. A
ProcessDocuments object is created to start the task, and the Run
method is defined as the start method of the task. The StartNew
method of the TaskFactory (which is accessed from the static Factory
property of the Task class) requires a delegate Action parameter where
the address of the Run method can be passed to. The StartNew method


of the TaskFactory immediately starts the task.
With the Run method of the ProcessDocuments class, an endless loop is
defined. Within this loop, the property IsDocumentAvailable is used to
determine whether there is a document in the queue. If so, the
document is taken from the DocumentManager and processed.
Processing in this example is writing information only to the console.
In a real application, the document could be written to a file, written to
the database, or sent across the network (code file
QueueSample/ProcessDocuments.cs ):
public class ProcessDocuments
{
public static Task Start(DocumentManager dm) =>
Task.Run(new ProcessDocuments(dm).Run);
protected ProcessDocuments(DocumentManager dm) =>
_documentManager = dm ?? throw new
ArgumentNullExcption(nameof(dm));
private DocumentManager _documentManager;
protected async Task Run()
{
while (true)
{
if (_documentManager.IsDocumentAvailable)
{
Document doc = _documentManager.GetDocument();
Console.WriteLine("Processing document {0}",
doc.Title);
}
await Task.Delay(new Random().Next(20));
}
}
}
In the Main method of the application, a DocumentManager object is
instantiated, and the document processing task is started. Then 1,000
documents are created and added to the DocumentManager (code file
QueueSample/Program.cs ):
public class Program
{
public static async Task Main()


{
var dm = new DocumentManager();
Task processDocuments = ProcessDocuments.Start(dm);
// Create documents and add them to the DocumentManager
for (int i = 0; i < 1000; i++)
{
var doc = new Document($"Doc {i.ToString()}",
"content");
dm.AddDocument(doc);
Console.WriteLine($"Added document {doc.Title}");
await Task.Delay(new Random().Next(20));
}
await processDocuments;
Console.ReadLine();
}
}
**NOTE**
With the QueueSample , the Main method is declared to return a Task .
This feature requires at least C# 7.1. You can read more about
asynchronous Main methods in Chapter 15, “Asynchronous
Programming.”
When you start the application, the documents are added to and
removed from the queue, and you get output like the following:
Added document Doc 279
Processing document Doc
Added document Doc 280
Processing document Doc
Added document Doc 281
Processing document Doc
Processing document Doc
Processing document Doc
Processing document Doc
Added document Doc 282
Processing document Doc
Added document Doc 283
Processing document Doc


















A real-life scenario using the task described with the sample
application might be an application that processes documents received
with a Web API service.
STACKS
A stack is another container that is very similar to the queue. You just
use different methods to access the stack. The item that is added last
to the stack is read first, so the stack is a last in, first out (LIFO)
container.
Figure 10-2 shows the representation of a stack where the Push method
adds an item to the stack, and the Pop method gets the item that was
added last.
FIGURE 10-2
Like the Queue<T> class, the Stack<T> class implements the interfaces
IEnumerable<T> and ICollection .
Members of the Stack<T> class are listed in the following table.


SELECTED
STACK<T>
MEMBERS DESCRIPTION
Count Returns the number of items in the stack.
Adds an item on top of the stack.
Removes and returns an item from the top of the
stack. If the stack is empty, an exception of type
InvalidOperationException is thrown.
Returns an item from the top of the stack but does
not remove the item.
Checks whether an item is in the stack and returns
true if it is.
Push
Pop
Peek
Contains
In this example, three items are added to the stack with the Push
method. With the foreach method, all items are iterated using the
IEnumerable interface. The enumerator of the stack does not remove
the items; it just returns them item by item (code file
StackSample/Program.cs ):
var alphabet = new Stack<char>();
alphabet.Push('A');
alphabet.Push('B');
alphabet.Push('C');
foreach (char item in alphabet)
{
Console.Write(item);
}
Console.WriteLine();
Because the items are read in order from the last item added to the
first, the following result is produced:
CBA
Reading the items with the enumerator does not change the state of
the items. With the Pop method, every item that is read is also removed
from the stack. This way, you can iterate the collection using a while
loop and verify the Count property if items still exist:
var alphabet = new Stack<char>();


alphabet.Push('A');
alphabet.Push('B');
alphabet.Push('C');
Console.Write("First iteration: ");
foreach (char item in alphabet)
{
Console.Write(item);
}
Console.WriteLine();
Console.Write("Second iteration: ");
while (alphabet.Count > 0)
{
Console.Write(alphabet.Pop());
}
Console.WriteLine();
The result gives CBA twice——once for each iteration. After the second
iteration, the stack is empty because the second iteration used the Pop
method:
First iteration: CBA
Second iteration: CBA
LINKED LISTS
is a doubly linked list, whereby one element references
the next and the previous one, as shown in Figure 10-3. This way you
can easily walk forward through the complete list by moving to the
next element, or backward by moving to the previous element.
LinkedList<T>
FIGURE 10-3
The advantage of a linked list is that if items are inserted anywhere in
the list, the linked list is very fast. When an item is inserted, only the
Next reference of the previous item and the Previous reference of the


next item must be changed to reference the inserted item. With the
List<T> class, when an element is inserted all subsequent elements
must be moved.
Of course, there’s also a disadvantage with linked lists. Items of linked
lists can be accessed only one after the other. It takes a long time to
find an item that’s somewhere in the middle or at the end of the list.
A linked list cannot just store the items inside the list; together with
every item, the linked list must have information about the next and
previous items. That’s why the LinkedList<T> contains items of type
LinkedListNode<T> . With the class LinkedListNode<T> , you can get to
the next and previous items in the list. The LinkedListNode<T> class
defines the properties List , Next , Previous , and Value . The List
property returns the LinkedList<T> object that is associated with the
node. Next and Previous are for iterating through the list and accessing
the next or previous item. Value returns the item that is associated
with the node. Value is of type T .
The LinkedList<T> class itself defines members to access the first
(First ) and last ( Last ) item of the list, to insert items at specific
positions ( AddAfter , AddBefore , AddFirst , AddLast ), to remove items
from specific positions ( Remove , RemoveFirst , RemoveLast ), and to find
elements where the search starts from either the beginning ( Find ) or
the end ( FindLast ) of the list.
The sample application to demonstrate linked lists uses a linked list
together with a list. The linked list contains documents as in the queue
example, but the documents have an additional priority associated
with them. The documents will be sorted inside the linked list
depending on the priority. If multiple documents have the same
priority, the elements are sorted according to the time when the
document was inserted.
Figure 10-4 describes the collections of the sample application.
LinkedList<Document> is the linked list containing all the Document
objects. The figure shows the title and priority of the documents. The
title indicates when the document was added to the list: The first
document added has the title "One" , the second document has the title
"Two" , and so on. You can see that the documents One and Four have


the same priority, 8, but because One was added before Four , it is
earlier in the list.
FIGURE 10-4
When new documents are added to the linked list, they should be
added after the last document that has the same priority. The


LinkedList<Document> collection contains elements of type
LinkedListNode<Document> . The class LinkedListNode<T> adds Next and
Previous properties to walk from one node to the next. For referencing
such elements, the List<T> is defined as
List<LinkedListNode<Document>> . For fast access to the last document
of every priority, the collection List<LinkedListNode> contains up to 10
elements, each referencing the last document of every priority. In the
upcoming discussion, the reference to the last document of every
priority is called the priority node.
Using the previous example, the Document class is extended to contain
the priority, which is set with the constructor of the class (code file
LinkedListSample/Document.cs ):
public class Document
{
public string Title { get; }
public string Content { get; }
public byte Priority { get; }
public Document(string title, string content, byte
priority)
{
Title = title;
Content = content;
Priority = priority;
}
}
The heart of the solution is the PriorityDocumentManager class. This
class is very easy to use. With the public interface of this class, new
Document elements can be added to the linked list, the first document
can be retrieved, and for testing purposes it also has a method to
display all elements of the collection as they are linked in the list.
The class PriorityDocumentManager contains two collections. The
collection of type LinkedList<Document> contains all documents. The
collection of type List<LinkedListNode<Document>> contains references
of up to 10 elements that are entry points for adding new documents
with a specific priority. Both collection variables are initialized with
the constructor of the class PriorityDocumentManager . The list
collection is also initialized with null (code file
LinkedListSample/PriorityDocumentManager.cs ):


public class PriorityDocumentManager
{
private readonly LinkedList<Document> _documentList;
// priorities 0.9
private readonly List<LinkedListNode<Document>>
_priorityNodes;
public PriorityDocumentManager()
{
_documentList = new LinkedList<Document>();
_priorityNodes = new List<LinkedListNode<Document>>(10);
for (int i = 0; i < 10; i++)
{
_priorityNodes.Add(new LinkedListNode<Document>(null));
}
}
Part of the public interface of the class is the method AddDocument .
AddDocument does nothing more than call the private method
AddDocumentToPriorityNode . The reason for having the implementation
inside a different method is that AddDocumentToPriorityNode may be
called recursively, as you will see soon:
public void AddDocument(Document d)
{
if (d == null) throw new ArgumentNullException(nameof(d));
AddDocumentToPriorityNode(d, d.Priority);
}
The first action that is done in the implementation of
AddDocumentToPriorityNode is a check to see if the priority fits in the
allowed priority range. Here, the allowed range is between 0 and 9. If a
wrong value is passed, an exception of type ArgumentException is
thrown.
Next, you check whether there’s already a priority node with the same
priority as the priority that was passed. If there’s no such priority node
in the list collection, AddDocumentToPriorityNode is invoked recursively
with the priority value decremented to check for a priority node with
the next lower priority.
If there’s no priority node with the same priority or any priority with a
lower value, the document can be safely added to the end of the linked
list by calling the method AddLast . In addition, the linked list node is


referenced by the priority node that’s responsible for the priority of the
document.
If there’s an existing priority node, you can get the position inside the
linked list where the document should be inserted. In the following
example, you must determine whether a priority node already exists
with the correct priority, or if there’s just a priority node that
references a document with a lower priority. In the first case, you can
insert the new document after the position referenced by the priority
node. Because the priority node always must reference the last
document with a specific priority, the reference of the priority node
must be set. It gets more complex if only a priority node referencing a
document with a lower priority exists. Here, the document must be
inserted before all documents with the same priority as the priority
node. To get the first document of the same priority, a while loop
iterates through all linked list nodes, using the Previous property, until
a linked list node is reached that has a different priority. This way, you
know the position where the document must be inserted, and the
priority node can be set:
private void AddDocumentToPriorityNode(Document doc, int
priority)
{
if (priority > 9 || priority < 0)
throw new ArgumentException("Priority must be between 0
and 9");
if (_priorityNodes[priority].Value == null)
{
––priority;
if (priority <= 0)
{
// check for the next lower priority
AddDocumentToPriorityNode(doc, priority);
}
else // now no priority node exists with the same
priority or lower
// add the new document to the end
{
_documentList.AddLast(doc);
_priorityNodes[doc.Priority] = _documentList.Last;
}
return;
}


else // a priority node exists
{
LinkedListNode<Document> prioNode =
_priorityNodes[priority];
if (priority == doc.Priority)
// priority node with the same priority exists
{
_documentList.AddAfter(prioNode, doc);
// set the priority node to the last document with the
same priority
_priorityNodes[doc.Priority] = prioNode.Next;
}
else // only priority node with a lower priority exists
{
// get the first node of the lower priority
LinkedListNode<Document> firstPrioNode = prioNode;
while (firstPrioNode.Previous != null &&
firstPrioNode.Previous.Value.Priority ==
prioNode.Value.Priority)
{
firstPrioNode = prioNode.Previous;
prioNode = firstPrioNode;
}
_documentList.AddBefore(firstPrioNode, doc);
// set the priority node to the new value
_priorityNodes[doc.Priority] = firstPrioNode.Previous;
}
}
}
Now only simple methods are left for discussion. DisplayAllNodes does
a foreach loop to display the priority and the title of every document to
the console.
The method GetDocument returns the first document (the document
with the highest priority) from the linked list and removes it from the
list:
public void DisplayAllNodes()
{
foreach (Document doc in documentList)
{
Console.WriteLine($"priority: {doc.Priority}, title
{doc.Title}");
}
}


// returns the document with the highest priority
// (that's first in the linked list)
public Document GetDocument()
{
Document doc = _documentList.First.Value;
_documentList.RemoveFirst();
return doc;
}
In the Main method, the PriorityDocumentManager is used to
demonstrate its functionality. Eight new documents with different
priorities are added to the linked list, and then the complete list is
displayed (code file LinkedListSample/Program.cs ):
public static void Main()
{
var pdm = new PriorityDocumentManager();
pdm.AddDocument(new Document("one", "Sample", 8));
pdm.AddDocument(new Document("two", "Sample", 3));
pdm.AddDocument(new Document("three", "Sample", 4));
pdm.AddDocument(new Document("four", "Sample", 8));
pdm.AddDocument(new Document("five", "Sample", 1));
pdm.AddDocument(new Document("six", "Sample", 9));
pdm.AddDocument(new Document("seven", "Sample", 1));
pdm.AddDocument(new Document("eight", "Sample", 1));
pdm.DisplayAllNodes();
}
With the processed result, you can see that the documents are sorted
first by priority and second by when the document was added:
priority:
priority:
priority:
priority:
priority:
priority:
priority:
priority:
9,
8,
8,
4,
3,
1,
1,
1,
title
title
title
title
title
title
title
title
six
one
four
three
two
five
seven
eight
SORTED LIST
If the collection you need should be sorted based on a key, you can use
SortedList<TKey, TValue> . This class sorts the elements based on a
key. You can use any type for the value and also for the key.


The following example creates a sorted list for which both the key and
the value are of type string . The default constructor creates an empty
list, and then two books are added with the Add method. With
overloaded constructors, you can define the capacity of the list and
pass an object that implements the interface IComparer<TKey> , which is
used to sort the elements in the list.
The first parameter of the Add method is the key (the book title); the
second parameter is the value (the ISBN). Instead of using the Add
method, you can use the indexer to add elements to the list. The
indexer requires the key as index parameter. If a key already exists, the
Add method throws an exception of type ArgumentException . If the
same key is used with the indexer, the new value replaces the old value
(code file SortedListSample/Program.cs ):
var books = new SortedList<string, string>();
books.Add("Professional WPF Programming", "978–0–470–04180–
2");
books.Add("Professional ASP.NET MVC 5", "978–1–118-79475–3");
books["Beginning C# 6 Programming"] = "978-1-119-09668-9";
books["Professional C# 6 and .NET Core 1.0"] = "978-1-119-
09660-3";
**NOTE**
allows only one value per key. If you
need multiple values per key you can use Lookup<TKey, TElement> .
SortedList<TKey, TValue>
You can iterate through the list using a foreach statement. Elements
returned by the enumerator are of type KeyValuePair<TKey, TValue> ,
which contains both the key and the value. The key can be accessed
with the Key property, and the value can be accessed with the Value
property:
foreach (KeyValuePair<string, string> book in books)
{
Console.WriteLine($"{book.Key}, {book.Value}");
}


The iteration displays book titles and ISBN numbers ordered by the
key:
Beginning C#
Professional
Professional
Professional
6 Programming, 978-1-119-09668-9
ASP.NET MVC 5, 978-1-118-79475-3
C# 6 and .NET Core 1.0, 978-1-119-09660-3
WPF Programming, 978-0-470-04180-2
You can also access the values and keys by using the Values and Keys
properties. The Values property returns IList<TValue> and the Keys
property returns IList<TKey> , so you can use these properties with a
foreach:
foreach (string isbn in books.Values)
{
Console.WriteLine(isbn);
}
foreach (string title in books.Keys)
{
Console.WriteLine(title);
}
The first loop displays the values, and next the keys:
978-1-119-09668-9
978-1-118-79475-3
978-1-119-09660-3
978-0-470-04180-2
Beginning C# 6 Programming
Professional ASP.NET MVC 5
Professional C# 6 and .NET Core 1.0
Professional WPF Programming
If you try to access an element with an indexer and passing a key that
does not exist, an exception of type KeyNotFoundException is thrown.
To avoid that exception, you can use the method ContainsKey , which
returns true if the key passed exists in the collection, or you can invoke
the method TryGetValue , which tries to get the value but doesn’t throw
an exception if it isn’t found:
string title = "Professional C# 8";
if (!books.TryGetValue(title, out string isbn))
{
Console.WriteLine($"{title} not found");
}


DICTIONARIES
A dictionary represents a sophisticated data structure that enables you
to access an element based on a key. Dictionaries are also known as
hash tables or maps. The main feature of dictionaries is fast lookup
based on keys. You can also add and remove items freely, a bit like a
List<T> , but without the performance overhead of having to shift
subsequent items in memory.
Figure 10-5 shows a simplified representation of a dictionary. Here
employee-id s such as B4711 are the keys added to the dictionary. The
key is transformed into a hash. With the hash a number is created to
associate an index with the values. The index then contains a link to
the value. The figure is simplified because it is possible for a single
index entry to be associated with multiple values, and the index can be
stored as a tree.
FIGURE 10-5
.NET offers several dictionary classes. The main class you use is
Dictionary<TKey, TValue> .


Dictionary Initializers
C# offers a syntax to initialize dictionaries at declaration. A dictionary
with a key of int and a value of string can be initialized as follows:
var dict = new Dictionary<int, string>()
{
[3] = "three",
[7] = "seven"
};
Here, two elements are added to the dictionary. The first element has a
key of 3 and a string value three ; the second element has a key of 7 and
a string value seven . This initializer syntax is easily readable and uses
the same syntax as accessing the elements in the dictionary.
Key Type
A type that is used as a key in the dictionary must override the method
GetHashCode of the Object class. Whenever a dictionary class needs to
determine where an item should be located, it calls the GetHashCode
method. The int that is returned by GetHashCode is used by the
dictionary to calculate an index of where to place the element. We
won’t go into this part of the algorithm; what you should know is that
it involves prime numbers, so the capacity of a dictionary is a prime
number.
The implementation of GetHashCode must satisfy the following
requirements:
The same object should always return the same value.
Different objects can return the same value.
It must not throw exceptions.
It should use at least one instance field.
The hash code should not change during the lifetime of the object.
Besides requirements that must be satisfied by the GetHashCode
implementation, it’s also good practice to satisfy these requirements:
It should execute as quickly as possible; it must be inexpensive to


compute.
The hash code value should be evenly distributed across the entire
range of numbers that an int can store.
**NOTE**
Good performance of the dictionary is based on a good
implementation of the method GetHashCode .
What’s the reason for having hash code values evenly distributed
across the range of integers? If two keys return hashes that have the
same index, the dictionary class needs to start looking for the nearest
available free location to store the second item——and it will have to do
some searching to retrieve this item later. This is obviously going to
hurt performance. In addition, if a lot of your keys are tending to
provide the same storage indexes for where they should be stored, this
kind of clash becomes more likely. However, because of the way that
Microsoft’s part of the algorithm works, this risk is minimized when
the calculated hash values are evenly distributed between
int.MinValue and int.MaxValue .
Besides having an implementation of GetHashCode , the key type also
must implement the IEquatable<T>.Equals method or override the
Equals method from the Object class. Because different key objects
may return the same hash code, the method Equals is used by the
dictionary comparing keys. The dictionary examines whether two keys,
such as A and B , are equal; it invokes A.Equals(B) . This means that you
must ensure that the following is always true: If A.Equals(B) is true,
then A.GetHashCode and B.GetHashCode must always return the same
hash code.
This may seem a subtle point, but it is crucial. If you contrived some
way of overriding these methods so that the preceding statement were
not always true, a dictionary that uses instances of this class as its keys
would not work properly. Instead, you’d find funny things happening.
For example, you might place an object in the dictionary and then


discover that you could never retrieve it, or you might try to retrieve an
entry and have the wrong entry returned.
**NOTE**
For this reason, the C# compiler displays a compilation **WARNING**
if you supply an override for Equals but don’t supply an override
for GetHashCode .
For System.Object this condition is true because Equals simply
compares references, and GetHashCode returns a hash that is based
solely on the address of the object. This means that hash tables based
on a key that doesn’t override these methods will work correctly.
However, the problem with this approach is that keys are regarded as
equal only if they are the same object. That means when you place an
object in the dictionary, you must hang on to the reference to the key;
you can’t simply instantiate another key object later with the same
value. If you don’t override Equals and GetHashCode , the type is not
very convenient to use in a dictionary.
Incidentally, System.String implements the interface IEquatable and
overloads GetHashCode appropriately. Equals provides value
comparison, and GetHashCode returns a hash based on the value of the
string. Strings can be used conveniently as keys in dictionaries.
Number types such as Int32 also implement the interface IEquatable
and overload GetHashCode . However, the hash code returned by these
types simply maps to the value. If the number you would like to use as
a key is not itself distributed around the possible values of an integer,
using integers as keys doesn’t fulfill the rule of evenly distributing key
values to get the best performance. Int32 is not meant to be used in a
dictionary.
If you need to use a key type that does not implement IEquatable and
does not override GetHashCode according to the key values you store in
the dictionary, you can create a comparer implementing the interface
IEqualityComparer<T> . IEqualityComparer<T> defines the methods


and Equals with an argument of the object passed, so you
can offer an implementation different from the object type itself. An
overload of the Dictionary<TKey, TValue> constructor allows passing
an object implementing IEqualityComparer<T> . If such an object is
assigned to the dictionary, this class is used to generate the hash codes
and compare the keys.
GetHashCode
Dictionary Example
The dictionary example in this section is a program that sets up a
dictionary of employees. The dictionary is indexed by EmployeeId
objects, and each item stored in the dictionary is an Employee object
that stores details of an employee.
The struct EmployeeId is implemented to define a key to be used in a
dictionary. The members of the class are a prefix character and a
number for the employee. Both these variables are read-only and can
be initialized only in the constructor to ensure that keys within the
dictionary shouldn’t change. When you have read-only variables it is
guaranteed that they can’t be changed. The fields are filled within the
constructor. The ToString method is overloaded to get a string
representation of the employee ID. As required for a key type,
EmployeeId implements the interface IEquatable and overloads the
method GetHashCode (code file DictionarySample/EmployeeId.cs ):
public class EmployeeIdException : Exception
{
public EmployeeIdException(string message) : base(message)
{ }
}
public struct EmployeeId : IEquatable<EmployeeId>
{
private readonly char _prefix;
private readonly int _number;
public EmployeeId(string id)
{
if (id == null) throw new
ArgumentNullException(nameof(id));
_prefix = (id.ToUpper())[0];
int numLength = id.Length - 1;
try


{
_number = int.Parse(id.Substring(1, numLength > 6 ? 6 :
numLength));
}
catch (FormatException)
{
throw new EmployeeIdException("Invalid EmployeeId
format");
}
}
public override string ToString() => _prefix.ToString() +
$"{number,6:000000}";
public override int GetHashCode() => (number ^ number <<
16) * 0x15051505;
public bool Equals(EmployeeId other) =>
(prefix == other?.prefix && number == other?.number);
public override bool Equals(object obj) =>
Equals((EmployeeId)obj);
public static bool operator ==(EmployeeId left, EmployeeId
right) =>
left.Equals(right);
public static bool operator !=(EmployeeId left, EmployeeId
right) =>
!(left == right);
}
The Equals method that is defined by the IEquatable<T> interface
compares the values of two EmployeeId objects and returns true if both
values are the same. Instead of implementing the Equals method from
the IEquatable<T> interface, you can also override the Equals method
from the Object class:
public bool Equals(EmployeeId other) =>
prefix == other.prefix && number == other.number;
With the number variable, a value from 1 to around 190,000 is
expected for the employees. This doesn’t fill the range of an integer.
The algorithm used by GetHashCode shifts the number 16 bits to the
left, then does an XOR (exclusive OR) with the original number, and


finally multiplies the result by the hex value 15051505. The hash code
is evenly distributed across the range of an integer:
public override int GetHashCode() => (number ^ number << 16)
* 0x1505_1505;
**NOTE**
On the Internet, you can find a lot more complex algorithms that
have a better distribution across the integer range. You can also
use the GetHashCode method of a string to return a hash.
The Employee class is a simple entity class containing the name, salary,
and ID of the employee. The constructor initializes all values, and the
method ToString returns a string representation of an instance. The
implementation of ToString uses a format string to create the string
representation for performance reasons (code file
DictionarySample/Employee.cs ):
public class Employee
{
private string _name;
private decimal _salary;
private readonly EmployeeId _id;
public Employee(EmployeeId id, string name, decimal salary)
{
_id = id;
_name = name;
_salary = salary;
}
public override string ToString() =>
$"{id.ToString()}: {name, -20} {salary:C}";
}
In the Main method of the sample application, a new Dictionary<TKey,
TValue> instance is created, where the key is of type EmployeeId and
the value is of type Employee . The constructor allocates a capacity of 31
elements. Remember that capacity is based on prime numbers.
However, when you assign a value that is not a prime number, you


don’t need to worry. The Dictionary<TKey, TValue> class itself takes
the next prime number that follows the integer passed to the
constructor to allocate the capacity. After creating the employee
objects and IDs, they are added to the newly created dictionary using
the new dictionary initializer syntax. Of course, you can also invoke
the Add method of the dictionary to add objects instead (code file
DictionarySample/Program.cs ):
static void Main()
{
var idJimmie = new EmployeeId("C48");
var jimmie = new Employee(idJimmie, "Jimmie Johnson",
150926.00m);
var idJoey = new EmployeeId("F22");
var joey = new Employee(idJoey, "Joey Logano", 45125.00m);
var idKyle = new EmployeeId("T18");
var kyle = new Employee(idKyle, "Kyle Bush", 78728.00m);
var idCarl = new EmployeeId("T19");
var carl = new Employee(idCarl, "Carl Edwards", 80473.00m);
var idMatt = new EmployeeId("T20");
var matt = new Employee(idMatt, "Matt Kenseth",
113970.00m);
var employees = new Dictionary<EmployeeId, Employee>(31)
{
[idJimmie] = jimmie,
[idJoey] = joey,
[idKyle] = kyle,
[idCarl] = carl,
[idMatt] = matt
};
foreach (var employee in employees.Values)
{
Console.WriteLine(employee);
}
//...
After the entries are added to the dictionary, inside a while loop
employees are read from the dictionary. The user is asked to enter an
employee number to store in the variable userInput , and the user can


exit the application by entering X. If the key is in the dictionary, it is
examined with the TryGetValue method of the Dictionary<TKey,
TValue> class. TryGetValue returns true if the key is found and false
otherwise. If the value is found, the value associated with the key is
stored in the employee variable. This value is written to the console.
**NOTE**
You can also use an indexer of the Dictionary<TKey, TValue> class
instead of TryGetValue to access a value stored in the dictionary.
However, if the key is not found, the indexer throws an exception
of type KeyNotFoundException .
while (true)
{
Console.Write("Enter employee id (X to exit)> ");
var userInput =ReadLine();
userInput = userInput.ToUpper();
if (userInput == "X") break;
EmployeeId id;
try
{
id = new EmployeeId(userInput);
if (!employees.TryGetValue(id, out Employee employee))
{
Console.WriteLine($"Employee with id {id} does not
exist");
}
else
{
Console.WriteLine(employee);
}
}
catch (EmployeeIdException ex)
{
Console.WriteLine(ex.Message);
}
}
Running the application produces the following output:


C000048: Jimmie Johnson
$150,926.00
F000022: Joey Logano
$45,125.00
T000018: Kyle Bush
$78,728.00
T000019: Carl Edwards
$80,473.00
T000020: Matt Kenseth
$113,970.00
Enter employee id (X to exit)> T18
T000018: Kyle Bush
$78,728.00
Enter employee id (X to exit)> C48
C000048: Jimmie Johnson
$150,926.00
Enter employee id (X to exit)> X
Press any key to continue . . .
Lookups
Dictionary<TKey, TValue> supports only one value per key. The class
Lookup<TKey, TElement> resembles a Dictionary<TKey, TValue> but
maps keys to a collection of values. This class is implemented in the
assembly System.Core and defined with the namespace System.Linq .
cannot be created as a normal dictionary.
Instead, you must invoke the method ToLookup , which returns a
Lookup<TKey, TElement> object. The method ToLookup is an extension
method that is available with every class implementing
IEnumerable<T> . In the following example, a list of Racer objects is
filled. Because List<T> implements IEnumerable<T> , the ToLookup
method can be invoked on the racers list. This method requires a
delegate of type Func<TSource, TKey> that defines the selector of the
key. Here, the racers are selected based on their country by using the
lambda expression r => r.Country . The foreach loop accesses only the
racers from Australia by using the indexer (code file
LookupSample/Program.cs ):
Lookup<TKey, TElement>
var racers = new List<Racer>();
racers.Add(new Racer("Jacques", "Villeneuve", "Canada", 11));
racers.Add(new Racer("Alan", "Jones", "Australia", 12));
racers.Add(new Racer("Jackie", "Stewart", "United Kingdom",
27));
racers.Add(new Racer("James", "Hunt", "United Kingdom", 10));
racers.Add(new Racer("Jack", "Brabham", "Australia", 14));
var lookupRacers = racers.ToLookup(r => r.Country);
foreach (Racer r in lookupRacers["Australia"])


{
Console.WriteLine(r);
}
**NOTE**
You can read more about extension methods in Chapter 12,
“Language Integrated Query.” Lambda expressions are explained
in Chapter 8, “Delegates, Lambdas, and Events.”
The output shows the racers from Australia:
Alan Jones
Jack Brabham
Sorted Dictionaries
is a binary search tree in which the
items are sorted based on the key. The key type must implement the
interface IComparable<TKey> . If the key type is not sortable, you can
also create a comparer implementing IComparer<TKey> and assign the
comparer as a constructor argument of the sorted dictionary.
SortedDictionary<TKey, TValue>
Earlier in this chapter you read about SortedList<TKey, TValue> .
SortedDictionary<TKey, TValue> and SortedList<TKey, TValue> have
similar functionality, but because SortedList<TKey, TValue> is
implemented as a list that is based on an array, and
SortedDictionary<TKey, TValue> is implemented as a dictionary, the
classes have different characteristics:
SortedList<TKey, TValue> u ses less
SortedDictionary<TKey, TValue> .
SortedDictionary<TKey, TValue>
memory than
has faster insertion and removal
of elements.
When populating the collection with already sorted data,
SortedList<TKey, TValue> is faster if capacity changes are not
needed.


**NOTE**
SortedList consumes less memory than SortedDictionary .
SortedDictionary is faster with inserts and the removal of
unsorted data.
SETS
A collection that contains only distinct items is known by the term set.
.NET Core includes two sets, HashSet<T> and SortedSet<T> , that both
implement the interface ISet<T> . HashSet<T> contains an unordered
list of distinct items; with SortedSet<T> the list is ordered.
The ISet<T> interface offers methods to create a union of multiple
sets, to create an intersection of sets, or to provide information if one
set is a superset or subset of another.
In the following sample code, three new sets of type string are created
and filled with Formula-1 cars. The HashSet<T> class implements the
ICollection<T> interface. However, the Add method is implemented
explicitly and a different Add method is offered by the class, as you can
see here. The Add method differs by the return type; a Boolean value is
returned to provide the information if the element was added. If the
element was already in the set, it is not added, and false is returned
(code file SetSample/Program.cs ):
var companyTeams = new HashSet<string>()
{ "Ferrari", "McLaren", "Mercedes" };
var traditionalTeams = new HashSet<string>() { "Ferrari",
"McLaren" };
var privateTeams = new HashSet<string>()
{ "Red Bull", "Toro Rosso", "Force India", "Sauber" };
if (privateTeams.Add("Williams"))
{
Console.WriteLine("Williams added");
}


if (!companyTeams.Add("McLaren"))
{
Console.WriteLine("McLaren was already in this set");
}
The result of these two Add methods is written to the console:
Williams added
McLaren was already in this set
The methods IsSubsetOf and IsSupersetOf compare a set with a
collection that implements the IEnumerable<T> interface and returns a
Boolean result. Here, IsSubsetOf verifies whether every element in
traditionalTeams is contained in companyTeams , which is the case;
IsSupersetOf verifies whether traditionalTeams has any additional
elements compared to companyTeams :
if (traditionalTeams.IsSubsetOf(companyTeams))
{
Console.WriteLine("traditionalTeams is subset of
companyTeams");
}
if (companyTeams.IsSupersetOf(traditionalTeams))
{
Console.WriteLine("companyTeams is a superset of
traditionalTeams");
}
The output of this verification is shown here:
traditionalTeams is a subset of companyTeams
companyTeams is a superset of traditionalTeams
Williams is a traditional team as well, which is why this team is added
to the traditionalTeams collection:
traditionalTeams.Add("Williams");
if (privateTeams.Overlaps(traditionalTeams))
{
Console.WriteLine("At least one team is the same with
traditional " +
"and private teams");
}


Because there’s an overlap, this is the result:
At least one team is the same with traditional and private
teams.
The variable allTeams that references a new SortedSet<string> is filled
with a union of companyTeams , privateTeams , and traditionalTeams by
calling the UnionWith method:
var allTeams = new SortedSet<string>(companyTeams);
allTeams.UnionWith(privateTeams);
allTeams.UnionWith(traditionalTeams);
Console.WriteLine();
Console.WriteLine("all teams");
foreach (var team in allTeams)
{
Console.WriteLine(team);
}
Here, all teams are returned but every team is listed just once because
the set contains only unique values; and because the container is a
SortedSet<string> , the result is ordered:
Ferrari
Force India
Lotus
McLaren
Mercedes
Red Bull
Sauber
Toro Rosso
Williams
The method ExceptWith removes all private teams from the allTeams
set:
allTeams.ExceptWith(privateTeams);
WriteLine();
WriteLine("no private team left");
foreach (var team in allTeams)
{
Console.WriteLine(team);
}
The remaining elements in the collection do not contain any private


teams:
Ferrari
McLaren
Mercedes
PERFORMANCE
Many collection classes offer the same functionality as others; for
example, SortedList offers nearly the same features as
SortedDictionary . However, often there’s a big difference in
performance. Whereas one collection consumes less memory, the
other collection class is faster with retrieval of elements. The MSDN
documentation often provides performance hints about methods of
the collection, giving you information about the time the operation
requires in big-O notation:
O(1)
O(log n)
O(n)
O(1) means that the time this operation needs is constant no matter
how many items are in the collection. For example, the ArrayList has
an Add method with O(1) behavior. No matter how many elements are
in the list, it always takes the same amount of time when adding a new
element to the end of the list. The Count property provides the number
of items, so it is easy to find the end of the list.
O(n) means it takes the worst-case time of N to perform an operation
on the collection. The Add method of ArrayList can be an O(n)
operation if a reallocation of the collection is required. Changing the
capacity causes the list to be copied, and the time for the copy
increases linearly with every element.
O(log n) means that the time needed for the operation increases with
every element in the collection, but the increase of time for each
element is not linear but logarithmic. SortedDictionary<TKey, TValue>
has O(log n) behavior for inserting operations inside the collection;
SortedList<TKey, TValue> has O(n) behavior for the same


functionality. Here, SortedDictionary<TKey, TValue> is a lot faster
because it is more efficient to insert elements into a tree structure than
into a list.
The following table lists collection classes and their performance for
different actions such as adding, inserting, and removing items. Using
this table, you can select the best collection class for the purpose of
your use. The left column lists the collection class. The Add column
gives timing information about adding items to the collection. The
List<T> and the HashSet<T> classes define Add methods to add items to
the collection. With other collection classes, use a different method to
add elements to the collection; for example, the Stack<T> class defines
a Push method, and the Queue<T> class defines an Enqueue method. You
can find this information in the table as well.
If there are multiple big-O values in a cell, the reason is that if a
collection needs to be resized, resizing takes a while. For example, with
the List<T> class, adding items needs O(1). If the capacity of the
collection is not large enough and the collection needs to be resized,
the resize requires O(n) time. The larger the collection, the longer the
resize operation takes. It’s best to avoid resizes by setting the capacity
of the collection to a value that can hold all the elements.
If the table cell contains n/a, the operation is not applicable with this
collection type.
COLLECTION ADD
INSERT REMOVE ITEM SORT FIND
List<T>
O(1) or
O(n)
O(n)
O(1) O (n O(n)
O(n) if
log n),
the
worst
collection
case
must be
O(n ^
resized
2)
Stack<T>
Push ,
n/a
Pop , O(1)
n/a
n/a
n/a
O(1), or
O(n) if
the stack
must be
resized


Queue<T>
HashSet<T>
SortedSet<T>
LinkedList<T>
Enqueue ,
O(1), or
O(n) if
the
queue
must be
resized
O(1) or
O(n) if
the set
must be
resized
O(1) or
O(n) if
the set
must be
resized
AddLast
O(1)
n/a
Dequeue ,
n/a n/a n/a
Add O(1) O(1)
or O(n) n/a n/a n/a
Add O(1) O(1)
or O(n) n/a n/a n/a
O(1) n/a n/a O(n)
O(1) O(1) n/a n/a
O(log n) O(log n/a
n)
O(log n/a
n) to
read/
write,
O(log
n) if
the
key is
in the
list,
O(n) n/a
O(1)
Add
After
O(1)
n/a
O(1) or
O(n)
S ortedDictionar
y ​ < O(log
TK
n) n/a
Dictionary
<TKey, TValue>
TValue>
SortedList
<TKey, TValue>
O(n) for n/a
unsorted
data,
O(log n)
for end of
list, O(n)
if resize
is needed
O(n)


n/a
if the
key is
not in
the
list
SUMMARY
This chapter looked at working with different kinds of generic
collections. Arrays are fixed in size, but you can use lists for
dynamically growing collections. For accessing elements on a first-in,
first-out basis, there’s a queue; and you can use a stack for last-in,
first-out operations. Linked lists allow for fast insertion and removal
of elements but are slow for searching. With keys and values, you can
use dictionaries, which are fast for searching and inserting elements.
Sets are useful for unique items and can be ordered ( SortedSet<T> ) or
not ordered ( HashSet<T> ).
Chapter 11, “Special Collections,” gives you details about some special
collection classes.