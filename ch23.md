

Networking
WHAT’S IN THIS CHAPTER?
Using HttpClient
Manipulating IP addresses and performing DNS lookups
Creating a server with WebListener
Socket programming with TCP, UDP, and socket classes
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
http://www.wrox.com on the Download Code tab. The source code is
also available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory Networking .
The code for this chapter is divided into the following major
examples:
HttpClientSample
WinAppHttpClient
HttpServer
Utilities
DnsLookup


HttpClientUsingTcp
TcpServer
WinAppTcpClient
UdpReceiver
UdpSender
SocketServer
SocketClient
NETWORKING
This chapter takes a practical approach to networking, mixing
examples with a discussion of relevant theory and networking
concepts as appropriate. This chapter is not a guide to computer
networking but an introduction to using the .NET for network
communication.
This chapter shows you how to create both clients and servers using
network protocols. It starts with the simplest case: sending an HTTP
request to a server and storing the information that’s sent back in the
response.
Then you see how to create an HTTP server, using utility classes to
split up and create URIs and resolve hostnames to IP addresses. You
are also introduced to sending and receiving data via TCP and UDP
and find out how to make use of the Socket class.
The two namespaces of most interest for networking are System.Net
and System.Net.Sockets . The System.Net namespace is generally
concerned with higher-level operations, such as downloading and
uploading files, and making web requests using HTTP and other
protocols, whereas System.Net.Sockets contains classes to perform
lower-level operations. You will find these classes useful when you
want to work directly with sockets or protocols, such as TCP/IP. The
methods in these classes closely mimic the Windows socket (Winsock)
API functions derived from the Berkeley sockets interface. You will
also find that some of the objects that this chapter works with are


found in the System.IO namespace.
THE HTTPCLIENT CLASS
The HttpClient class is used to send an HTTP request and receive the
response from the request. It is in the System.Net.Http namespace.
The classes in the System.Net.Http namespace help make it easy to
consume web services for both clients and server.
The HttpClient class derives from the HttpMessageInvoker class. This
base class implements the SendAsync method. The SendAsync method is
the workhorse of the HttpClient class. As you see later in this section,
there are several derivatives of this method to use. As the name
implies, the SendAsync method call is asynchronous. This enables you
to write a fully asynchronous system for calling web services.
**WARNING**
The HttpClient class implements the IDisposable interface. As a
general guideline, objects implementing IDisposable should be
disposed after its use. This is also true for the HttpClient class.
However, the Dispose method of the HttpClient does not
immediately release the associated socket; it is released after a
timeout. This timeout can take 20 seconds. With this timeout,
using many HttpClient object instances can lead to the program
running out of sockets. The solution: The HttpClient class is built
for reuse. You can use this class with many requests and not
create a new instance every time.
Making an Asynchronous Get Request
In the download code examples for this chapter is HttpClientSample . It
calls a web service asynchronously in different ways. To call using the
different ways demonstrated by the sample, you use command-line
arguments.


The sample code makes use of the following namespaces:
System
System.Linq
System.Net
System.Net.Http
System.Net.Http.Headers
System.Threading
System.Threading.Tasks
The first code snippet instantiates an HttpClient object and assigns it
to the private field _httpClient for reuse. The HttpClient object is
thread-safe, so a single HttpClient object can be used to handle
multiple requests. Each instance of HttpClient maintains its own
thread pool, so requests between HttpClient instances are isolated.
Invoking the GetAsync makes an HTTP GET request to the server. You
pass in the address of the method you’re going to call. The GetAsync
call is overloaded to take either a string or a URI object. The example
calls into Microsoft’s OData sample site http://services.odata.org ,
but you could alter that address to call any number of REST web
services.
The call to GetAsync returns an HttpResponseMessage object. The
HttpResponseMessage class represents a response including headers,
status, and content. Checking the IsSuccessfulStatusCode property of
the response tell you whether the request was successful. With a
successful call, the content returned is retrieved as a string using the
ReadAsStringAsync method (code file
HttpClientSample/HttpClientSamples.cs ):
private const string NorthwindUrl =
"http://services.data.org/Northwind/Northwind.svc/Regions";
private const string IncorrectUrl =
"http://services.data.org/Northwind1/Northwind.svc/Regions";


private HttpClient _httpClient;
public HttpClient HttpClient =>
_httpClient ?? (_httpClient = new HttpClient());
private async Task GetDataSimpleAsync()
{
HttpResponseMessage response = await
HttpClient.GetAsync(NorthwindUrl);
if(response.IsSuccessStatusCode)
{
Console.WriteLine($"Response Status Code:
{(int)response.StatusCode} " +
$"{response.ReasonPhrase}");
string responseBodyAsText = await
response.Content.ReadAsStringAsync();
Console.WriteLine($"Received payload of
{responseBodyAsText.Length} characters");
Console.WriteLine();
Console.WriteLine(responseBodyAsText);
}
}
}
Executing this code with the command-line argument - s should
produce the following output:
Response Status Code: 200 OK
Received payload of 3379 characters
<?xml version="1.0" encoding="utf-8"?>
<!– ... –>
**NOTE**
Because the HttpClient class used the GetAsync method call with
the await keyword, the calling thread returned and could do some
other work. When the result is available from the GetAsync method
a thread continues with the method, and the response is written to
the response variable. The await keyword is explained in Chapter
15, “Asynchronous Programming.” Creating and using tasks is
explained in Chapter 21, “Tasks and Parallel Programming.”


Throwing Exceptions
Invoking the GetAsync method of the HttpClient class by default
doesn’t generate an exception if the method fails. This could be easily
changed by invoking the EnsureSuccessStatusCode method with the
HttpResponseMessage . This method checks whether
IsSuccessStatusCode is false and throws an exception otherwise (code
file HttpClientSample/HttpClientSamples.cs ):
private async Task GetDataWithExceptionsAsync()
{
try
{
HttpResponseMessage response = await
HttpClient.GetAsync(IncorrectUrl);
response.EnsureSuccessStatusCode();
ConsoleWriteLine($"Response Status Code:
{(int)response.StatusCode} " +
$"{response.ReasonPhrase}");
string responseBodyAsText = await
response.Content.ReadAsStringAsync();
Console.WriteLine($"Received payload of
{responseBodyAsText.Length} characters");
Console.WriteLine();
Console.WriteLine(responseBodyAsText);
}
catch (Exception ex)
{
Console.WriteLine($"{ex.Message}");
}
}
Passing Headers
You didn’t set or change any of the headers when you made the
request, but the DefaultRequestHeaders property on HttpClient
enables you to do just that. You can add headers to the collection using
the Add method. After you set a header value, the header and header
value are sent with every request that this instance of HttpClient
sends.
By default, the response content will be in XML format. You can
change this by adding an Accept header to the request to use JSON.


Add the following line just before the call to GetAsync and the content
is returned in JSON format:
client.DefaultRequestHeaders.Add("Accept",
"application/json;odata=verbose");
Adding and removing the header and running the example will result
in the content in both XML and JSON formats.
The HttpRequestHeaders object returned from the DefaultHeaders
property has several helper properties to many of the standard
headers. You can read the values of the headers from these properties,
but they are read only. To set a value, you need to use the Add method.
In the code snippet, the HTTP Accept header is added. Depending on
the Accept header received by the server, the server can return
different data formats based on the client’s needs. When you send the
Accept header application/json , the client informs the server that it
accepts data in JSON format. Header information is shown with the
ShowHeaders method that is also invoked when receiving the response
from the server (code file HttpClientSample/HttpClientSamples.cs ):
public Task GetDataWithHeadersAsync()
{
try
{
HttpClient.DefaultRequestHeaders.Add("Accept",
"application/json;odata=verbose");
ShowHeaders("Request Headers:",
HttpClient.DefaultRequestHeaders);
HttpResponseMessage response = await
client.GetAsync(NorthwindUrl);
HttpClient.EnsureSuccessStatusCode();
ShowHeaders("Response Headers:", response.Headers);
//...
}
}
Contrary to the previous sample, the ShowHeaders method was added,
taking an HttpHeaders object as a parameter. HttpHeaders is the base
class for HttpRequestHeaders and HttpResponseHeaders . The specialized
classes both add helper properties to access headers directly. The
HttpHeader object is defined as a KeyValuePair<string,


This means that each header can have more
than one value in the collection. Because of this, it’s important that if
you want to change a value in a header, you need to remove the
original value and add the new value.
IEnumerable<string>>.
The ShowHeaders function is pretty simple. It iterates all headers in
HttpHeaders . The enumerator returns KeyValuePair<string,
IEnumerable<string>> elements and shows a stringified version of the
values for every key:
public void ShowHeaders(string title, HttpHeaders headers)
{
Console.WriteLine(title);
foreach (var header in headers)
{
string value = string.Join(" ", header.Value);
Console.WriteLine($"Header: {header.Key} Value:
{value}");
}
Console.WriteLine();
}
Running this code will now display any headers for the request:
Request Headers:
Header: Accept Value: application/json; odata=verbose
Response Headers:
Header: Cache-Control Value: private
Header: Date Value: Thu, 31 Aug 2017 09:58:09 GMT
Header: Server Value: Microsoft-IIS/8.0
Header: Set-Cookie Value:
ARRAffinity=a5ee7717b148daedb0164e6e19088a5a78c47693a6
0e57422887d7e011fb1e5e;Path=/;Domain=services.odata.org
Header: Vary Value: *
Header: X-Content-Type-Options Value: nosniff
Header: DataServiceVersion Value: 2.0;
Header: X-AspNet-Version Value: 4.0.30319
Header: X-Powered-By Value: ASP.NET
Header: Access-Control-Allow-Origin Value: *
Header: Access-Control-Allow-Methods Value: GET
Header: Access-Control-Allow-Headers Value: Accept, Origin,
Content-Type,
MaxDataServiceVersion
Header: Access-Control-Expose-Headers Value:
DataServiceVersion


Because the client now requests JSON data, the server returns JSON,
and you can also see this information:
Response Status Code: 200 OK
Received payload of 1551 characters
{"d":{"results":[{"__metadata":
{"id":"http://services.odata.org/Northwind/
Northwind.svc/Regions(1) ", "uri":
Accessing the Content
The previous code snippets have shown you how to access the Content
property to retrieve a string. The Content property in the response
returns an HttpContent object. In order to get the data from the
HttpContent object you need to use one of the methods supplied. In the
example, the ReadAsStringAsync method was used. It returns a string
representation of the content. As the name implies, this is an async
call. Instead of using the async keyword, the Result property could be
used as well. Calling the Result property blocks the call until it’s
finished and then continues with execution.
Other methods to get the data from the HttpContent object are
ReadAsByteArrayAsync , which returns a byte array of the data, and
ReadAsStreamAsync , which returns a stream. You can also load the
content into a memory buffer using LoadIntoBufferAsync .
The Headers property returns the HttpContentHeaders object. This
works exactly the same way the request and response headers do in
the previous example.
**NOTE**
Instead of using the GetAsync and ReadAsStringAsync methods of
the HttpClient and HttpContent classes, the HttpClient class also
offers the method GetStringAsync that returns a string without the
need to invoke two methods. However, when using this method,
you don’t have that much control over the error status and other
information.


**NOTE**
**NOTE** Streams are explained in Chapter 22, “Files and Streams.”
Customizing Requests with HttpMessageHandler
The HttpClient class can take an HttpMessageHandler as a parameter to
its constructor. This makes it possible for you to customize the
request. You can pass an instance of the HttpClientHandler . There are
numerous properties that can be set for things such as
ClientCertificates , Pipelining , CachePolicy , ImpersonationLevel , and
so on.
With the next code snippet, a SampleMessageHandler is instantiated and
passed to the HttpClient constructor: (code file
HttpClientSample/HttpClientSamples.cs ):
private HttpClient _httpClientWithMessageHandler;
public HttpClient HttpClientWithMessageHandler =>
_httpClientWithMessageHandler ??
(_httpClientWithMessageHandler =
new HttpClient(new SampleMessageHandler("error")));
The purpose of this handler type, SampleMessageHandler , is to take a
string as a parameter and either display it in the console, or, if the
message is “ error ,” set the response’s status code to Bad Request . If
you create a class that derives from HttpClientHandler , you can
override a few properties and the method SendAsync . SendAsync is
typically overridden because the request to the server can be
influenced. If the _displayMessage is set to “ error ”, an
HttpResponseMessage with a bad request is returned. The method needs
a Task returned. For the error case, asynchronous methods do not
need to be called; that’s why the error is simply returned with
Task.FromResult (code file
HttpClientSample/SampleMessageHandler.cs ):
public class SampleMessageHandler : HttpClientHandler
{


private string _message;
public SampleMessageHandler(string message) =>
_message = message;
protected override Task<HttpResponseMessage> SendAsync(
HttpRequestMessage request, CancellationToken
cancellationToken)
{
Console.WriteLine($"In SampleMessageHandler {_message}");
if(_message == "error")
{
var response = new
HttpResponseMessage(HttpStatusCode.BadRequest);
return Task.FromResult<HttpResponseMessage>(response);
}
return base.SendAsync(request, cancellationToken);
}
}
There are many reasons to add a custom handler. The handler pipeline
is set so that multiple handlers can be added. Besides the default, there
is the DelegatingHandler , which executes some code and then
“delegates” the call back to the inner or next handler. The
HttpClientHandler is the last handler in line and sends the request to
the addressee. Figure 23-1 shows the pipeline. Each DelegatingHandler
added would call the next or inner handler finally ending at the
HttpClientHandler -based handler.
Creating an HttpRequestMessage Using
SendAsync
Behind the scenes, the GetAsync method of the HttpClient class
invokes the SendAsync method. Instead of using the GetAsync method,
you can also use the SendAsync method to send an HTTP request. With
SendAsync you have even more control over defining the request. The
constructor of the HttpRequestMessage class is overloaded to pass a
value of the HttpMethod . The GetAsync method creates an HTTP request
with HttpMethod.Get . Using HttpMethod , you can not only send GET,
POST, PUT, and DELETE requests but you can also send also HEAD,
OPTIONS, and TRACE. With the HttpRequestMessage object in place,
you can invoke the SendAsync method with the HttpClient (code file


HttpClientSample/HttpClientSamples.cs ):
private async Task GetDataAdvancedAsync()
{
var request = new HttpRequestMessage(HttpMethod.Get,
NorthwindUrl);
HttpResponseMessage response = await
client.SendAsync(request);
//...
}
Figure 23-1


**NOTE**
This chapter only makes HTTP GET requests with the HttpClient
class. The HttpClient class also allows sending HTTP POST, PUT,
and DELETE requests using the PostAsync , PutAsync , and
DeleteAsync methods. These methods are used in Chapter 32,
“ASP.NET Web API,” where these requests are done to invoke
corresponding action methods in the web service.
After the HttpRequestMessage object is created, the header and content
can be supplied by using the Headers and Content properties. With the
Version property, the HTTP version can be specified.
**NOTE**
HTTP/1.0 was specified in the year 1996 followed by 1.1 just a few
years later. With 1.0, the connection was always closed after the
server returned the data; with 1.1, a keep-alive header was added
where the client was able to put his or her wish to keep the
connection alive as the client might make more requests to receive
not only the HTML code, but also CSS and JavaScript files and
images. After HTTP/1.1 was defined in 1999, it took 16 years until
HTTP/2 was done in the year 2015. What are the advantages of
version 2? HTTP/2 allows multiple concurrent requests on the
same connection, header information is compressed, the client
can define which of the resources is more important, and the
server can send resources to the client via server push. HTTP/2
supporting server push means WebSockets will practically be
obsolete as soon as HTTP/2 is supported everywhere. All the
newer versions of browsers, as well as IIS running on Windows
10 and Windows Server 2016, support HTTP/2. With .NET Core,
HTTP/2 is planned (at the time of this writing) with a future
milestone; see https://github.com/dotnet/corefx/issues/23134 .


Using HttpClient with Windows Runtime
At the time of writing this book, the HttpClient class used with console
applications doesn’t support HTTP/2. However, the HttpClient class
used with the Universal Windows Platform has a different
implementation that is based on features of the Windows 10 API. With
this, HttpClient supports HTTP/2, and even uses this version by
default.
The next code sample shows a Universal Windows app that makes an
HTTP request to a link that is entered in a TextBox and shows the
result, as well as giving information about the HTTP version. The
following code snippet shows the major elements of the XAML code,
and Figure 23-2 shows the user interface of the running app (code file
WinAppHttpClient/MainPage.xaml ):
<StackPanel Orientation="Horizontal">
<TextBox Header="Url" Text="{x:Bind Url, Mode=TwoWay}"
MinWidth="200"
Margin="5" />
<Button Content="Send" Click="{x:Bind OnSendRequest}"
Margin="10,5,5,5"
VerticalAlignment="Bottom" />
</StackPanel>
<TextBox Header="Version" Text="{x:Bind Version,
Mode=OneWay}" Grid.Row="1"
Margin="5" IsReadOnly="True" />
<TextBox AcceptsReturn="True" IsReadOnly="True"
Text="{x:Bind Result, Mode=OneWay}" Grid.Row="2"
ScrollViewer.HorizontalScrollBarVisibility="Auto"
ScrollViewer.VerticalScrollBarVisibility="Auto" />


Figure 23-2
**NOTE**
XAML code and dependency properties are explained in Chapter
33, “Windows Apps,” and compiled binding is covered in Chapter
34, “Patterns with XAML Apps.”
The properties Url , Version , and Result are implemented as
dependency properties for making automatic updates to the UI. The
following code snippet shows the Url property (code file
WinAppHttpClient/MainPage.xaml.cs ):
public string Url
{
get => (string)GetValue(UrlProperty);
set => SetValue(UrlProperty, value);


}
public static readonly DependencyProperty UrlProperty =
DependencyProperty.Register("Url", typeof(string),
typeof(MainPage),
new PropertyMetadata(string.Empty));
The HttpClient class is used in the OnSendRequest method. This
method is invoked when clicking the Send button in the UI. As in the
previous sample, the SendAsync method is used to make the HTTP
request. To see that the request is indeed making a request using the
HTTP/2 version, you can check the request.Version property from the
debugger. The version answered from the server coming from
response.Version is written to the Version property that is bound in
the UI. Nowadays, most servers just support the HTTP 1.1 version. As
mentioned previously, HTTP/2 is supported by Windows Server 2016:
private async void OnSendRequest()
{
try
{
using (var client = new HttpClient())
{
var request = new HttpRequestMessage(HttpMethod.Get,
Url);
HttpResponseMessage response = await
client.SendAsync(request);
Version = response.Version.ToString();
response.EnsureSuccessStatusCode();
Result = await response.Content.ReadAsStringAsync();
}
}
catch (Exception ex)
{
await new MessageDialog(ex.Message).ShowAsync();
}
}
Running the application, you make a request to
https://http2.akamai.com/demo to see HTTP/2 returned.
WORKING WITH THE WEBLISTENER CLASS
Using Internet Information Server (IIS) as an HTTP server is usually a


great approach because you have access to a lot of features, such as
scalability, health monitoring, a graphical user interface for
administration, and a lot more. However, you can also easily create
your own simple HTTP server. Since the .NET Framework 2.0, you
have been able to use the HttpListener , but now since .NET Core 1.0
there’s a new one: the WebListener class.
The sample code of the HttpServer makes use of the following
dependency and namespaces:
Dependency
Microsoft.Net.Http.Server
Namespaces
Microsoft.Net.Http.Server
System
System.Collections.Generic
System.Linq
System.Net
System.Reflection
System.Text
System.Threading.Tasks
The sample code for the HTTP server is a Console Application
(Package) that allows passing a list of URL prefixes that defines where
the server listens. An example of such a prefix is
http://localhost:8082/samples where the server listens only to
requests on port 8082 on the localhost if the path starts with samples.
No matter what path follows, the server handles the request. To not
only support requests from localhost, you can use the + character, such
as http://+:8082/samples . This way the server is also accessible from
all its hostnames. In case you are not starting Visual Studio from
elevated mode, the user running the listener needs allowance. You can
do this by running a command prompt in elevated mode and adding


the URL using this netsh command:
>netsh http add urlacl url=http://+:8082/samples
user=Everyone
The sample code checks the arguments if at least one prefix is passed
and invokes the StartServer method afterward (code file
HttpServer/Program.cs ):
static async Task Main(string[] args)
{
if (args.Length < 1)
{
ShowUsage();
return;
}
await StartServerAsync(args);
Console.ReadLine();
}
private static void ShowUsage()
{
Console.WriteLine("Usage: HttpServer Prefix [Prefix2]
[Prefix3] [Prefix4]");
}
The heart of the program is the StartServer method. Here, the
WebListener class is instantiated, and the prefixes as defined from the
command argument list are added. Calling the Start method of the
WebListener class registers the port on the system. Next, after calling
the GetContextAsync method, the listener waits for a client to connect
and send data. As soon as a client sends an HTTP request, the request
can be read from the HttpContext object that is returned from
GetContextAsync . For both the request that is coming from the client
and the answer that is sent, the HttpContext object is used. The Request
property returns a Request object. The Request object contains the
HTTP header information. With an HTTP POST request, the Request
also contains the body. The Response property returns a Response
object, which allows you to return header information (using the
Headers property), status code ( StatusCode property), and the response
body (the Body property):
public static async Task StartServerAsync(params string[]


prefixes)
{
try
{
Console.WriteLine($"server starting at");
var listener = new WebListener();
foreach (var prefix in prefixes)
{
listener.UrlPrefixes.Add(prefix);
Console.WriteLine($"\t{prefix}");
}
listener.Start();
do
{
using (RequestContext context = await
listener.GetContextAsync())
{
context.Response.Headers.Add("content-type",
new string[] { "text/html" });
context.Response.StatusCode = (int)HttpStatusCode.OK;
byte[] buffer = GetHtmlContent(context.Request);
await context.Response.Body.WriteAsync(buffer, 0,
buffer.Length);
}
} while (true);
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
}
The sample code returns an HTML file that is retrieved using the
GetHtmlContent method. This method makes use of the htmlFormat
format string with two placeholders in the heading and the body. The
GetHtmlContent method fills in the placeholders using the
string.Format method. To fill the HTML body, two helper methods are
used that retrieve the header information from the request and all the
property values of the Request object—— GetHeaderInfo and
GetRequestInfo :
private static string htmlFormat =
"<!DOCTYPE html><html><head><title>{0}</title></head>" +
"<body>{1}</body></html>";
private static byte[] GetHtmlContent(Request request)


{
string title = "Sample WebListener";
var sb = new StringBuilder("<h1>Hello from the
server</h1>");
sb.Append("<h2>Header Info</h2>");
sb.Append(string.Join(" ",
GetHeaderInfo(request.Headers)));
sb.Append("<h2>Request Object Information</h2>");
sb.Append(string.Join(" ", GetRequestInfo(request)));
string html = string.Format(htmlFormat, title,
sb.ToString());
return Encoding.UTF8.GetBytes(html);
}
The GetHeaderInfo method retrieves the keys and values from the
HeaderCollection to return a div element that contains every key and
value:
private static IEnumerable<string>
GetHeaderInfo(HeaderCollection headers) =>
headers.Keys.Select(key =>
$"<div>{key}: {string.Join(",",
headers.GetValues(key))}</div>");
The GetRequestInfo method makes use of reflection to get all the
properties of the Request type, and returns the property names as well
as its values:
private static IEnumerable<string> GetRequestInfo(Request
request) =>
request.GetType().GetProperties().Select(
p => $"<div>{p.Name}: {p.GetValue(request)}</div>");
**NOTE**
The GetHeaderInfo and GetRequestInfo methods make use of
expression-bodied member functions, LINQ, and reflection.
Expression-bodied member functions are explained in Chapter 3,
“Objects and Types.” Chapter 12, “Language Integrated Query,”
explains LINQ. Chapter 16, “Reflection, Metadata, and Dynamic
Programming,” includes reflection as an important topic.


Running the server and using a browser such as Google Chrome to
access the server using a URL such as
http://[hostname]:8082/samples/Hello?sample=text results in output
as shown in Figure 23-3.
**NOTE**
To access localhost from the Edge browser, you need to enable
localhost loopback, which you can do via about :flags. On some
Windows 10 builds there are issues accessing localhost from the
Edge browser event if localhost loopback is enabled. In such cases
use other browsers, such as Internet Explorer.


Figure 23-3
WORKING WITH UTILITY CLASSES
After dealing with HTTP requests and responses using classes that
abstract the HTTP protocol like HttpClient and WebListener , let’s have
a look at some utility classes that make web programming easier when
dealing with URIs and IP addresses.
On the Internet, you identify servers as well as clients by IP address or
host name (also referred to as a Domain Name System (DNS) name).
Generally speaking, the host name is the human-friendly name that
you type in a web browser window, such as www.wrox.com or
www.cninnovation.com . An IP address is the identifier that computers
use to recognize each other. IP addresses are the identifiers used to
ensure that web requests and responses reach the appropriate
machines. It is even possible for a computer to have more than one IP
address.
An IP address can be a 32-bit or 128-bit value, depending on whether
Internet Protocol version 4 (IPv4) or Internet Protocol version 6
(IPv6) is used. An example of a 32-bit IP address is 192.168.1.100 .
Because there are now so many computers and other devices vying for
a spot on the Internet, IPv6 was developed. IPv6 can potentially
provide a maximum number of about 3 × 10 38 unique addresses. .NET
enables your applications to work with both IPv4 and IPv6.
For host names to work, you must first send a network request to
translate the host name into an IP address——a task that’s carried out by
one or more DNS servers. A DNS server stores a table that maps host
names to IP addresses for all the computers it knows about, as well as
the IP addresses of other DNS servers to look up host names it does
not know about. Your local computer should always know about at
least one DNS server. Network administrators configure this
information when a computer is set up.
Before sending out a request, your computer first asks the DNS server
to give it the IP address corresponding to the host name you have
typed in. When it is armed with the correct IP address, the computer


can address the request and send it over the network. All this work
normally happens behind the scenes while the user is browsing the
web.
.NET supplies a number of classes that are able to assist with the
process of looking up IP addresses and finding information about host
computers.
The sample code makes use of the following namespaces:
System
System.Net
URIs
and UriBuilder are two classes in the System namespace, and both
are intended to represent a URI. Uri enables you to parse, combine,
and compare URIs, and UriBuilder enables you to build a URI given
the strings for the component parts.
Uri
The following code snippet demonstrates features of the Uri class. The
constructor allows passing relative and absolute URLs. This class
defines several read-only properties to access parts of a URL such as
the scheme, hostname, port number, query strings, and the segments
of an URL (code file Utilities/Program.cs ):
public static void UriSample(string url)
{
var page = new Uri(url);
Console.WriteLine($"scheme: {page.Scheme}");
Console.WriteLine($"host: {page.Host}, type:
{page.HostNameType}, " +
$"idn host: {page.IdnHost}");
Console.WriteLine($"port: {page.Port}");
Console.WriteLine($"path: {page.AbsolutePath}");
Console.WriteLine($"query: {page.Query}");
foreach (var segment in page.Segments)
{
Console.WriteLine($"segment: {segment}");
}
//...
}


When you run the application and pass this URL and this string that
contains a path and a query string
http://www.amazon.com/Professional-C-6-0-Christian-
Nagel/dp/111909660X/ref=sr_1_4?ie=UTF8&amqid=1438459506&sr=8-
4&keywords=professional+c%23+6 , you get the following output:
scheme: http
host: www.amazon.com, type: Dns, idn host: www.amazon.com
port: 80
path: /Professional-C-6-0-Christian-
Nagel/dp/111909660X/ref=sr_1_4
query: ?ie=UTF8&qid=1438459506&sr=8-
4&keywords=professional+c%23+6
segment: /
segment: Professional-C-6-0-Christian-Nagel/
segment: dp/
segment: 111909660X/
segment: ref=sr_1_4
Unlike the Uri class, the UriBuilder defines read-write properties, as
shown in the following code snippet. You can create an UriBuilder
instance, assign these properties, and get a URL returned from the Uri
property:
public static void UriSample(string url)
{
// ...
var builder = new UriBuilder();
builder.Host = "www.cninnovation.com";
builder.Port = 80;
builder.Path = "training/MVC";
Uri uri = builder.Uri;
Console.WriteLine(uri);
}
Instead of using properties with the UriBuilder , this class also offers
several overloads of the constructor where the parts of an URL can be
passed as well.
IPAddress
represents an IP address. The address itself is available as a
byte array using the GetAddressBytes property and may be converted
to a dotted decimal format with the ToString method. IPAddress also
IPAddress


implements static Parse and TryParse methods that effectively perform
the reverse conversion of ToString ——converting from a dotted decimal
string to an IPAddress . The code sample also accesses the
AddressFamily property and converts an IPv4 address to IPv6, and vice
versa (code file Utilities/Program.cs ):
public static void IPAddressSample(string ipAddressString)
{
IPAddress address;
if (!IPAddress.TryParse(ipAddressString, out address))
{
Console.WriteLine($"cannot parse {ipAddressString}");
return;
}
byte[] bytes = address.GetAddressBytes();
for (int i = 0; i < bytes.Length; i++)
{
Console.WriteLine($"byte {i}: {bytes[i]:X}");
}
Console.WriteLine($"family: {address.AddressFamily}, " +
$"map to ipv6: {address.MapToIPv6()}, map to ipv4:
{address.MapToIPv4()}");
// ...
Passing the address 65.52.128.33 to the method results in this output:
byte 0: 41
byte 1: 34
byte 2: 80
byte 3: 21
family: InterNetwork, map to ipv6: ::ffff:65.52.128.33, map
to ipv4: 65.52.128.3


The IPAddress class also defines static properties to create special
addresses such as loopback, broadcast, and anycast:
public static void IPAddressSample(string ipAddressString)
{
//...
Console.WriteLine($"IPv4 loopback address:
{IPAddress.Loopback}");
Console.WriteLine($"IPv6 loopback address:
{IPAddress.IPv6Loopback}");
Console.WriteLine($"IPv4 broadcast address:
{IPAddress.Broadcast}");


Console.WriteLine($"IPv4 any address: {IPAddress.Any}");
Console.WriteLine($"IPv6 any address:
{IPAddress.IPv6Any}");
}
With a loopback address, the network hardware is bypassed. This is
the IP address that represents the hostname localhost.
The broadcast address is an address that addresses every node in a
local network. Such an address is not available with IPv6, as this
concept is not used with the newer version of the Internet Protocol.
After the initial definition of IPv4, multicasting was added for IPv6.
With multicasting, a group of nodes is addressed instead of all nodes.
With IPv6, multicasting completely replaces broadcasting. Both
broadcast and multicast are shown in code samples later in this
chapter when using UDP.
With an anycast one-to-many routing is used as well, but the data
stream is only transmitted to the node closest in the network. This is
useful for load balancing. With IPv4, the Border Gateway Protocol
(BGP) routing protocol is used to find the shortest path in the
network; with IPv6 this feature is inherent.
When you run the application, you can see the following addresses for
IPv4 and IPv6:
IPv4
IPv6
IPv4
IPv4
IPv6
loopback address: 127.0.0.1
loopback address: ::1
broadcast address: 255.255.255.255
any address: 0.0.0.0
any address: ::
IPHostEntry
The IPHostEntry class encapsulates information related to a particular
host computer. This class makes the host name available via the
HostName property (which returns a string), and the AddressList
property returns an array of IPAddress objects. You are going to use
the IPHostEntry class in the next example.
Dns


The Dns class can communicate with your default DNS server to
retrieve IP addresses.
The DnsLookup sample code makes use of the following namespaces:
System
System.Net
System.Threading.Tasks
The sample application is implemented as a Console Application
(package) that loops to ask the user for hostnames (you can also add
an IP address instead) to get an IPHostEntry via
Dns.GetHostEntryAsync . From the IPHostEntry , the address list is
accessed using the AddressList property. All the addresses of the host,
as well as the AddressFamily , are written to the console (code file
DnsLookup/Program.cs ):
static void Main()
{
do
{
Console.Write("Hostname:\t");
string hostname = ReadLine();
if (hostname.CompareTo("exit") == 0)
{
Console.WriteLine("bye!");
return;
}
OnLookupAsync(hostname).Wait();
Console.WriteLine();
} while (true);
}
public static async Task OnLookupAsync(string hostname)
{
try
{
IPHostEntry ipHost = await
Dns.GetHostEntryAsync(hostname);
Console.WriteLine($"Hostname: {ipHost.HostName}");
foreach (IPAddress address in ipHost.AddressList)
{
Console.WriteLine($"Address Family:


{address.AddressFamily}");
Console.WriteLine($"Address: {address}");
}
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
}
Run the application and enter a few hostnames to see output such as
the following. With the hostname www.orf.at , you can see that this
hostname defines multiple IP addresses.
Hostname: www.cninnovation.com
Hostname: www.cninnovation.com
Address Family: InterNetwork
Address: 65.52.128.33
Hostname: www.orf.at
Hostname: www.orf.at
Address Family: InterNetwork
Address: 194.232.104.150
Address Family: InterNetwork
Address: 194.232.104.139
Address Family: InterNetwork
Address: 194.232.104.140
Address Family: InterNetwork
Address: 194.232.104.142
Address Family: InterNetwork
Address: 194.232.104.141
Address Family: InterNetwork
Address: 194.232.104.149
Hostname: exit
bye!
**NOTE**
The Dns class is somewhat limited——for example, you can’t define
to use a server that’s different than the default DNS server. Also,
the Aliases property of the IPHostEntry is not populated from the
method GetHostEntryAsync . It’s only populated from obsolete
methods of the Dns class, and these don’t populate this property


fully. For a full use of DNS lookups, it’s better to use a third-party
library.
Now it’s time to move to some lower-level protocols such as TCP and
UDP.
USING TCP
The HTTP protocol is based on the Transmission Control Protocol
(TCP). With TCP, the client first needs to open a connection to the
server before sending commands. With HTTP, textual commands are
sent. The HttpClient and WebListener classes hide the details of the
HTTP protocol. When you are using TCP classes and you send HTTP
requests, you need to know more about the HTTP protocol. The TCP
classes don’t offer functionality for the HTTP protocol; you have to do
this on your own. On the other side, the TCP classes give more
flexibility because you can use these classes also with other protocols
based on TCP.
The TCP classes offer simple methods for connecting and sending data
between two endpoints. An endpoint is the combination of an IP
address and a port number. Existing protocols have well-defined port
numbers——for example, HTTP uses port 80, whereas SMTP uses port
25. The Internet Assigned Numbers Authority, IANA ( www.iana.org ),
assigns port numbers to these well-known services. Unless you are
implementing a well-known service, you should select a port number
higher than 1,024.
TCP traffic makes up the majority of traffic on the Internet today. It is
often the protocol of choice because it offers guaranteed delivery, error
correction, and buffering. The TcpClient class encapsulates a TCP
connection and provides a number of properties to regulate the
connection, including buffering, buffer size, and timeouts. Reading
and writing is accomplished by requesting a NetworkStream object via
the GetStream method.
The TcpListener class listens for incoming TCP connections with the
Start method. When a connection request arrives, you can use the
AcceptSocket method to return a socket for communication with the


remote machine, or you can use the AcceptTcpClient method to use a
higher-level TcpClient object for communication. The easiest way to
see how the TcpListener and TcpClient classes work together is to go
through some examples.
Creating an HTTP Client Using TCP
First, create a Console Application (Package) that will send an HTTP
request to a web server. You’ve previously done this with the
HttpClient class, but with the TcpClient class you need to take a
deeper look into the HTTP protocol.
The HttpClientUsingTcp sample code makes use of the following
namespaces:
System
System.IO
System.Net.Sockets
System.Text
System.Threading.Tasks
The application accepts one command-line argument to pass the name
of the server. With this, the method RequestHtmlAsync is invoked to
make an HTTP request to the server. It returns a string with the Result
property of the Task (code file HttpClientUsingTcp/Program.cs ):
static void Main(string[] args)
{
if (args.Length != 1)
{
ShowUsage();
}
Task<string> t1 = RequestHtmlAsync(args[0]);
Console.WriteLine(t1.Result);
Console.ReadLine();
}
private static void ShowUsage()
{
Console.WriteLine("Usage: HttpClientUsingTcp hostname");


}
Now let’s look at the most important parts of the RequestHtmlAsync
method. First, a TcpClient object is instantiated. Second, with the
method ConnectAsync , a TCP connection to the host is made at port 80,
the default port for HTTP. Third, a stream to read and write using this
connection is retrieved via the GetStream method:
private const int ReadBufferSize = 1024;
public static async Task<string> RequestHtmlAsync(string
hostname)
{
try
{
using (var client = new TcpClient())
{
await client.ConnectAsync(hostname, 80);
NetworkStream stream = client.GetStream();
//...
}
}
}
The stream can now be used to write a request to the server and read
the response. HTTP is a text-based protocol; that’s why it’s easy to
define the request in a string. To make a simple request to the server,
the header defines the HTTP method GET followed by the path of the
URL / and the HTTP version HTTP/1.1 . The second line defines the
Host header with the hostname and port number, and the third line
defines the Connection header. Typically, with the Connection header
the client requests keep-alive to ask the server to keep the connection
open as the client expects to make more requests. Here we’re just
making a single request to the server, so the server should close the
connection, thus close is set to the Connection header. To end the
header information, you need to add an empty line to the request by
using \r\n . The header information is sent with UTF-8 encoding by
calling the WriteAsync method of the NetworkStream . To immediately
send the buffer to the server, the FlushAsync method is invoked.
Otherwise the data might be kept in the local cache:
//...
string header = "GET / HTTP/1.1\r\n" +


$"Host: {hostname}:80\r\n" +
"Connection: close\r\n" +
"\r\n";
byte[] buffer = Encoding.UTF8.GetBytes(header);
await stream.WriteAsync(buffer, 0, buffer.Length);
await stream.FlushAsync();
Now you can continue the process by reading the answer from the
server. As you don’t know how big the answer will be, you create a
MemoryStream that grows dynamically. The answer from the server is
temporarily written to a byte array using the ReadAsync method, and
the content of this byte array is added to the MemoryStream . After all the
data is read from the server, a StreamReader takes control to read the
data from the stream into a string and return it to the caller:
var ms = new MemoryStream();
buffer = new byte[ReadBufferSize];
int read = 0;
do
{
read = await stream.ReadAsync(buffer, 0, ReadBufferSize);
ms.Write(buffer, 0, read);
Array.Clear(buffer, 0, buffer.Length);
} while (read > 0);
ms.Seek(0, SeekOrigin.Begin);
var reader = new StreamReader(ms);
return reader.ReadToEnd();
}
//...
When you pass a website to the program, you see a successful request
with HTML content shown in the console.
Now it’s time to create a TCP listener with a custom protocol.
Creating a TCP Listener
Creating your own protocol based on TCP needs requires some
advance thought about the architecture. You can define your own
binary protocol where every bit is saved on the data transfer, but it’s
more complex to read; alternatively, you can use a text-based format
such as HTTP or FTP. Should a session stay open or be closed with
every request? Does the server need to keep state for a client, or is all


the data sent with every request?
The custom server will support some simple functionality, such as
echo and reverse a message that is sent. Another feature of the custom
server is that the client can send state information and retrieve it again
using another call. The state is stored temporarily in a session state.
Although it’s a simple scenario, you get the idea of what’s needed to set
this up.
The TcpServer sample code is implemented as a Console App (.NET
Core) and makes use of the following namespaces:
System
System.Collections
System.Collections.Concurrent
System.Linq
System.Net.Sockets
System.Text
System.Threading
System.Threading.Tasks
static TcpServer.CustomProtocol
The custom TCP listener supports a few requests, as shown in the
following table.
REQUEST
DESCRIPTION
HELO::v1.0
This command needs to be sent after initiating the
connection. Other commands will not be accepted.
ECHO::message The ECHO command returns the message to the caller.
REV::message
The REV command reserves the message and returns
it to the caller.
BYE
The BYE command closes the connection.
SET::key=value
The SET command sets the server-side state that can


be retrieved with the GET command.
GET::key
The first line of the request is a session-identifier prefixed by ID . This
needs to be sent with every request except the HELO request. This is
used as a state identifier.
All the constants of the protocol are defined in the static class
CustomProtocol (code file TcpServer/CustomProtocol.cs ):
public static class CustomProtocol
{
public const string SESSIONID = "ID";
public const string COMMANDHELO = "HELO";
public const string COMMANDECHO = "ECO";
public const string COMMANDREV = "REV";
public const string COMMANDBYE = "BYE";
public const string COMMANDSET = "SET";
public const string COMMANDGET = "GET";
public const string STATUSOK = "OK";
public const string STATUSCLOSED = "CLOSED";
public const string STATUSINVALID = "INV";
public const string STATUSUNKNOWN = "UNK";
public const string STATUSNOTFOUND = "NOTFOUND";
public const string STATUSTIMEOUT = "TIMOUT";
public const string SEPARATOR = "::";
public static readonly TimeSpan SessionTimeout =
TimeSpan.FromMinutes(2);
}
The Run method (which is invoked from the Main method) starts a
timer that cleans up all the session state every minute. The major
functionality of the Run method is the start of the server by invoking
the method RunServerAsync (code file TcpServer/Program.cs ):
static void Main()
{
var p = new Program();
p.Run();
}
public void Run()
{
using (var timer = new Timer(TimerSessionCleanup, null,
TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1)))


{
RunServerAsync().Wait();
}
}
The most important part of the server regarding the TcpListener class
is in the method RunServerAsync . The TcpListener is instantiated using
the constructor the IP address and port number where the listener can
be accessed. Calling the Start method, the listener starts listening for
client connections. The AcceptTcpClientAsync waits until a client
connects. As soon as a client is connected, a TcpClient instance is
returned that allows communication with the client. This instance is
passed to the RunClientRequest method, where the request is dealt
with.
private async Task RunServerAsync()
{
try
{
var listener = new TcpListener(IPAddress.Any,
portNumber);
Console.WriteLine($"listener started at port
{portNumber}");
listener.Start();
while (true)
{
Console.WriteLine("waiting for client...");
TcpClient client = await
listener.AcceptTcpClientAsync();
Task t = RunClientRequest(client);
}
}
catch (Exception ex)
{
Console.WriteLine($"Exception of type
{ex.GetType().Name}, Message: {ex.Message}");
}
}
To read and write from and to the client, the GetStream method of the
TcpClient returns a NetworkStream . First you need to read the request
from the client. You do this by using the ReadAsync method. The
ReadAsync method fills a byte array. This byte array is converted to a
string using the Encoding class. The information received is written to


the console and passed to the ParseRequest helper method. Depending
on the result of the ParseRequest method, an answer for the client is
created and returned to the client using the WriteAsync method.
private Task RunClientRequestAsync(TcpClient client)
{
return Task.Run(async () =>
{
try
{
using (client)
{
Console.WriteLine("client connected");
using (NetworkStream stream = client.GetStream())
{
bool completed = false;
do
{
byte[] readBuffer = new byte[1024];
int read = await stream.ReadAsync(readBuffer, 0,
readBuffer.Length);
string request =
Encoding.ASCII.GetString(readBuffer, 0, read);
Console.WriteLine($"received {request}");
byte[] writeBuffer = null;
string response = string.Empty;
ParseResponse resp = ParseRequest(request, out
string sessionId,
out string result);
switch (resp)
{
case ParseResponse.OK:
string content = $"{STATUSOK}::{SESSIONID}::
{sessionId}";
if (!string.IsNullOrEmpty(result))
{
content += $"{SEPARATOR}{result}";
}
response = $"{STATUSOK}{SEPARATOR}{SESSIONID}
{SEPARATOR}" +
$"{sessionId}{SEPARATOR}{content}";
break;
case ParseResponse.CLOSE:
response = $"{STATUSCLOSED}";
completed = true;
break;


case ParseResponse.TIMEOUT:
response = $"{STATUSTIMEOUT}";
break;
case ParseResponse.ERROR:
response = $"{STATUSINVALID}";
break;
default:
break;
}
writeBuffer = Encoding.ASCII.GetBytes(response);
await stream.WriteAsync(writeBuffer, 0,
writeBuffer.Length);
await stream.FlushAsync();
Console.WriteLine($"returned
{Encoding.ASCII.GetString(
writeBuffer, 0, writeBuffer.Length)}");
} while (!completed);
}
}
}
catch (Exception ex)
{
Console.WriteLine($"Exception in client request
handling " +
"of type {ex.GetType().Name}, Message:
{ex.Message}");
}
Console.WriteLine("client disconnected");
});
}
The ParseRequest method parses the request and filters out the session
identifier. The first call to the server ( HELO ) is the only call where a
session identifier is not passed from the client; here it is created using
the SessionManager . With the second and later requests,
requestColl[0] must contain ID , and requestColl[1] must contain
the session identifier. Using this identifier, the TouchSession method
updates the current time of the session identifier if the session is still
valid. If it is not valid, a timeout is returned. For the functionality of
the service, the ProcessRequest method is invoked:
private ParseResponse ParseRequest(string request, out string
sessionId,
out string response)
{


sessionId = string.Empty;
response = string.Empty;
string[] requestColl = request.Split(
new string[] { SEPARATOR },
StringSplitOptions.RemoveEmptyEntries);
if (requestColl[0] == COMMANDHELO) // first request
{
sessionId = _sessionManager.CreateSession();
}
else if (requestColl[0] == SESSIONID) // any other valid
request
{
sessionId = requestColl[1];
if (!_sessionManager.TouchSession(sessionId))
{
return ParseResponse.TIMEOUT;
}
if (requestColl[2] == COMMANDBYE)
{
return ParseResponse.CLOSE;
}
if (requestColl.Length >= 4)
{
response = ProcessRequest(requestColl);
}
}
else
{
return ParseResponse.ERROR;
}
return ParseResponse.OK;
}
The ProcessRequest method contains a switch statement to handle the
different requests. This method in turn makes use of the
CommandActions class to echo or reverse the message received. To store
and retrieve the session state, the SessionManager is used:
private string ProcessRequest(string[] requestColl)
{
if (requestColl.Length < 4)
throw new ArgumentException("invalid length
requestColl");
string sessionId = requestColl[1];
string response = string.Empty;
string requestCommand = requestColl[2];


string requestAction = requestColl[3];
switch (requestCommand)
{
case COMMANDECHO:
response = _commandActions.Echo(requestAction);
break;
case COMMANDREV:
response = _commandActions.Reverse(requestAction);
break;
case COMMANDSET:
response = _sessionManager.ParseSessionData(sessionId,
requestAction);
break;
case COMMANDGET:
response = $"{_sessionManager.GetSessionData(sessionId,
requestAction)}";
break;
default:
response = STATUSUNKNOWN;
break;
}
return response;
}
The CommandActions class defines simple methods Echo and Reverse
that return the action string or return the string reversed (code file
TcpServer/CommandActions.cs ):
public class CommandActions
{
public string Reverse(string action) => string.Join("",
action.Reverse());
public string Echo(string action) => action;
}
After checking the main functionality of the server with the Echo and
Reverse methods, it’s time to get into the session management. What’s
needed on the server is an identifier and the time the session was last
accessed for the purpose of removing the oldest sessions (code file
TcpServer/SessionManager.cs ):
public struct Session
{
public string SessionId { get; set; }
public DateTime LastAccessTime { get; set; }
}


The SessionManager contains thread-safe dictionaries that store all
sessions and session data. When you’re using multiple clients, the
dictionaries can be accessed from multiple threads simultaneously.
That’s why thread-safe dictionaries from the namespace
System.Collections.Concurrent are used. The CreateSession method
creates a new session and adds it to the _sessions dictionary:
public class SessionManager
{
private readonly ConcurrentDictionary<string, Session>
_sessions =
new ConcurrentDictionary<string, Session>();
private readonly ConcurrentDictionary<string,
Dictionary<string, string>>
_sessionData =
new ConcurrentDictionary<string, Dictionary<string,
string>>();
public string CreateSession()
{
string sessionId = Guid.NewGuid().ToString();
if (_sessions.TryAdd(sessionId,
new Session
{
SessionId = sessionId,
LastAccessTime = DateTime.UtcNow
}))
{
return sessionId;
}
else
{
return string.Empty;
}
}
//...
}
The CleanupAllSessions method is called every minute from a timer
thread to remove all sessions that haven’t been used recently. This
method in turn invokes CleanupSession , which removes a single
session. CleanupSession is also invoked when the client sends the BYE
message:
public void CleanupAllSessions()


{
foreach (var session in _sessions)
{
if (session.Value.LastAccessTime + SessionTimeout >=
DateTime.UtcNow)
{
CleanupSession(session.Key);
}
}
}
public void CleanupSession(string sessionId)
{
if (_sessionData.TryRemove(sessionId, out
Dictionary<string, string> removed))
{
Console.WriteLine($"removed {sessionId} from session
data");
}
if (_sessions.TryRemove(sessionId, out Session header))
{
Console.WriteLine($"removed {sessionId} from sessions");
}
}
The TouchSession method updates the LastAccessTime of the session,
and returns false if the session is no longer valid:
public bool TouchSession(string sessionId)
{
if (!_sessions.TryGetValue(sessionId, out Session
oldHeader))
{
return false;
}
Session updatedHeader = oldHeader;
updatedHeader.LastAccessTime = DateTime.UtcNow;
_sessions.TryUpdate(sessionId, updatedHeader, oldHeader);
return true;
}
For setting session data, the request needs to be parsed. The action
that is received for session data contains key and value separated by
the equal sign, such as x=42 . This is parsed from the ParseSessionData
method, which in turn calls the SetSessionData method:


public string ParseSessionData(string sessionId, string
requestAction)
{
string[] sessionData = requestAction.Split('=');
if (sessionData.Length != 2) return STATUSUNKNOWN;
string key = sessionData[0];
string value = sessionData[1];
SetSessionData(sessionId, key, value);
return $"{key}={value}";
}
either adds or updates the session state in the
dictionary. The GetSessionData retrieves the value, or returns
NOTFOUND :
SetSessionData
public string GetSessionData(string sessionId, string key)
{
if (!_sessionData.TryGetValue(sessionId, out
Dictionary<string, string> data))
{
data = new Dictionary<string, string>();
data.Add(key, value);
_sessionData.TryAdd(sessionId, data);
}
else
{
if (data.TryGetValue(key, out string val))
{
data.Remove(key);
}
data.Add(key, value);
}
}
public string GetSessionData(string sessionId, string key)
{
if (_sessionData.TryGetValue(sessionId, out
Dictionary<string, string> data))
{
if (data.TryGetValue(key, out string value))
{
return value;
}
}
return STATUSNOTFOUND;
}


After compiling the listener, you can start the program. Now you need
a client to connect to the server.
Creating a TCP Client
The client for the example is a UWP app with the name
WinAppTCPClient . This application allows connecting to the TCP server
as well as sending all the different commands that are supported by
the custom protocol.
**NOTE**
For using UWP with the TcpClient class, you need a version that
supports .NET Standard 2.0, which starts with the Fall Creators
Update of Windows 10. The downloadable code samples also
include a WPF sample project.
The user interface of the application is shown in Figure 23-4. The left-
upper part allows connecting to the server. In the top-left part, a
ComboBox lists all commands, and the Send button sends the command
to the server. In the middle section, the session identifier and the
status of the request sent will be shown. The controls in the lower part
show the information received from the server and allow you to clear
this information.


Figure 23-4
The classes CustomProtocolCommand and CustomProtocolCommands are
used for data binding in the user interface. With
CustomProtocolCommand , the Name property shows the name of the
command while the Action property is the data that is entered by the
user to send with the command. The class CustomProtocolCommands
contains a list of the commands that are bound to the ComboBox (code
file WinAppTcpClient/CustomProtocolCommands.cs ):
public class CustomProtocolCommand
{
public CustomProtocolCommand(string name)
: this(name, null) { }
public CustomProtocolCommand(string name, string action)
{
Name = name;


Action = action;
}
public string Name { get; }
public string Action { get; set; }
public override string ToString() => Name;
}
public class CustomProtocolCommands :
IEnumerable<CustomProtocolCommand>
{
private readonly List<CustomProtocolCommand> _commands =
new List<CustomProtocolCommand>();
public CustomProtocolCommands()
{
string[] commands = { "HELO", "BYE", "SET", "GET", "ECO",
"REV" };
foreach (var command in commands)
{
_commands.Add(new CustomProtocolCommand(command));
}
_commands.Single(c => c.Name == "HELO").Action = "v1.0";
}
public IEnumerator<CustomProtocolCommand> GetEnumerator()
=>
_commands.GetEnumerator();
IEnumerator IEnumerable.GetEnumerator() =>
_commands.GetEnumerator();
}
The class MainPage contains properties that are bound to the XAML
code and methods that are invoked based on user interactions. This
class creates an instance of the TcpClient class and several properties
that are bound to the user interface (code file
WinAppTcpClient/MainPage.xaml.cs ):
public partial class MainPage : Page, INotifyPropertyChanged,
IDisposable
{
private TcpClient _client = new TcpClient();
private readonly CustomProtocolCommands _commands =
new CustomProtocolCommands();


public MainWindow() => InitializeComponent();
private string _remoteHost = "localhost";
public string RemoteHost
{
get => _remoteHost;
set => SetProperty(ref _remoteHost, value);
}
private int _serverPort = 8800;
public int ServerPort
{
get => _serverPort;
set => SetProperty(ref _serverPort, value);
}
private string _sessionId;
public string SessionId
{
get => return _sessionId;
set => SetProperty(ref _sessionId, value);
}
private CustomProtocolCommand _activeCommand;
public CustomProtocolCommand ActiveCommand
{
get => _activeCommand;
set => SetProperty(ref _activeCommand, value);
}
private string _log;
public string Log
{
get => _log;
set => SetProperty(ref _log, value);
}
private string _status;
public string Status
{
get => return _status;
set => SetProperty(ref _status, value);
}
//...
}


The method OnConnect is called when the user clicks the Connect
button. The connection to the TCP server is made, invoking the
ConnectAsync method of the TcpClient class. In case the connection is
in a stale mode, and the OnConnect method is invoked once more, a
SocketException is thrown where the ErrorCode is set to 0x2748 . A C#
exception filter is used here to handle this case of the SocketException
and create a new TcpClient , so invoking OnConnect once more likely
succeeds (code file WinAppTcpClient/MainPage.xaml.cs ):
private async void OnConnect(object sender, RoutedEventArgs
e)
{
try
{
await _client.ConnectAsync(RemoteHost, ServerPort);
}
catch (SocketException ex) when (ex.ErrorCode == 0x2748)
{
_client.Dispose();
_client = new TcpClient();
await new MessageDialog("please retry
connect").ShowAsync();
}
catch (Exception ex)
{
await new MessageDialog(ex.Message).ShowAsync();
}
}
Sending requests to the TCP server is handled by the method
OnSendCommand . The code here is very similar to the sending and
receiving code on the server. The GetStream method returns a
NetworkStream , and this is used to write ( WriteAsync ) data to the server
and read ( ReadAsync ) data from the server (code file
WinAppTcpClient/MainPage.xaml.cs ):
private async void OnSendCommand(object sender,
RoutedEventArgs e)
{
try
{
if (!VerifyIsConnected()) return;
NetworkStream stream = _client.GetStream();
byte[] writeBuffer =


Encoding.ASCII.GetBytes(GetCommand());
await stream.WriteAsync(writeBuffer, 0,
writeBuffer.Length);
await stream.FlushAsync();
byte[] readBuffer = new byte[1024];
int read = await stream.ReadAsync(readBuffer, 0,
readBuffer.Length);
string messageRead = Encoding.ASCII.GetString(readBuffer,
0, read);
Log += messageRead + Environment.NewLine;
ParseMessage(messageRead);
}
catch (Exception ex)
{
await new MessageDialog(ex.Message).ShowAsync();
}
}
To build up the data that can be sent to the server, the GetCommand
method is invoked from within OnSendCommand . GetCommand in turn
invokes the method GetSessionHeader to build up the session
identifier, and then takes the ActiveCommand property (of type
CustomProtocolCommand ) that contains the selected command name and
the entered data:
private string GetCommand() =>
$"{GetSessionHeader()}{ActiveCommand?.Name}::
{ActiveCommand?.Action}";
private string GetSessionHeader()
{
if (string.IsNullOrEmpty(SessionId)) return string.Empty;
return $"ID::{SessionId}::";
}
The ParseMessage method is used after the data is received from the
server. This method splits up the message to set the Status and
SessionId properties:
private void ParseMessage(string message)
{
if (string.IsNullOrEmpty(message)) return;
string[] messageColl = message.Split(
new string[] { "::" },
StringSplitOptions.RemoveEmptyEntries);


Status = messageColl[0];
SessionId = GetSessionId(messageColl);
}
When you run the application, you can connect to the server, select
commands, set values for echo and reverse returns, and see all the
messages coming from the server, as shown in Figure 23-5.
TCP Versus UDP
The next protocol covered is UDP (User Datagram Protocol). UDP is a
simple protocol with little overhead. Before sending and receiving data
with TCP, a connection needs to be made. This is not necessary with
UDP. With UDP, just start sending or receiving. Of course, that means
that UDP has less overhead than TCP, but it is also more unreliable.
When you send data with UDP, you don’t get information when this
data is received. UDP is often used for situations in which the speed
and performance requirements outweigh the reliability requirements
——for example, video streaming. UDP also offers broadcasting
messages to a group of nodes. On the other hand, TCP offers a number
of features to confirm the delivery of data. TCP provides error
correction and retransmission in the case of lost or corrupted packets.
Last, but hardly least, TCP buffers incoming and outgoing data and
guarantees that a sequence of packets scrambled in transmission is
reassembled before delivery to the application. Even with the extra
overhead, TCP is the most widely used protocol across the Internet
because of its high reliability.


Figure 23-5
USING UDP
To demonstrate UDP, you create two Console Application (Package)
projects that show various features of UDP: directly sending data to a
host, broadcasting data to all hosts on the local network, and
multicasting data to a group of nodes that belong to the same group.
The UdpSender and UdpReceiver projects use the following namespaces:
System
System.Linq
System.Net
System.Net.Sockets
System.Text
System.Threading.Tasks
Building a UDP Receiver
Start with the receiving application. This application makes use of


command-line arguments where you can control the different features
of the application. A command-line argument that is required is -p ,
which specifies the port number where the receiver is available to
receive data. An optional argument is -g with a group address for
multicasting. The ParseCommandLine method parses the command-line
arguments and puts the results into the variables port and
groupAddress (code file UdpReceiver/Program.cs ):
static async Task Main(string[] args)
{
if (!ParseCommandLine(args, out int port, out string
groupAddress))
{
ShowUsage();
return;
}
await ReaderAsync(port, groupAddress);
Console.ReadLine();
}
private static void ShowUsage()
{
Console.WriteLine("Usage: UdpReceiver -p port [-g
groupaddress]");
}
The Reader method creates a UdpClient object with the port number
that’s passed in the program arguments. The ReceiveAsync method
waits until some data arrives. This data can be found with the
UdpReceiveResult with the Buffer property. After the data is encoded
to a string, it’s written to the console to continue the loop and wait for
the next data to receive:
private static async Task ReaderAsync(int port, string
groupAddress)
{
using (var client = new UdpClient(port))
{
if (groupAddress != null)
{
client.JoinMulticastGroup(IPAddress.Parse(groupAddress));
Console.WriteLine(
$"joining the multicast group


{IPAddress.Parse(groupAddress)}");
}
bool completed = false;
do
{
Console.WriteLine("starting the receiver");
UdpReceiveResult result = await client.ReceiveAsync();
byte[] datagram = result.Buffer;
string received = Encoding.UTF8.GetString(datagram);
Console.WriteLine($"received {received}");
if (received == "bye")
{
completed = true;
}
} while (!completed);
Console.WriteLine("receiver closing");
if (groupAddress != null)
{
client.DropMulticastGroup(IPAddress.Parse(groupAddress));
}
}
}
When you start the application, it waits for a sender to send data. For
the time being, ignore the multicast group and just use the argument
with the port number because multicasting is discussed after you
create the sender.
Creating a UDP Sender
The UDP sender application also enables you to configure it by passing
command-line options. It has more options than the receiving
application. Besides the command-line argument -p to specify the port
number, the sender allows -b for a broadcast to all nodes in the local
network, -h to identify a specific host, -g to specify a group, and -ipv6
to indicate that IPv6 should be used instead of IPv4 (code file
UdpSender/Program.cs ):
static async Task Main(string[] args)
{
if (!ParseCommandLine(args, out int port, out string
hostname, out bool broadcast,


out string groupAddress, out bool ipv6))
{
ShowUsage();
Console.ReadLine();
return;
}
IPEndpoint endpoint = await GetIPEndPointAsync(port,
hostname, broadcast,
groupAddress, ipv6);
await SenderAsync(endpoint, broadcast, groupAddress);
Console.WriteLine("Press return to exit...");
Console.ReadLine();
}
private static void ShowUsage()
{
Console.WriteLine("Usage: UdpSender -p port [-g
groupaddress | -b | -h hostname] " +
"[-ipv6]");
Console.WriteLine("\t-p port number\tEnter a port number
for the sender");
Console.WriteLine("\t-g group address\tGroup address in the
range 224.0.0.0 " +
"to 239.255.255.255");
Console.WriteLine("\t-b\tFor a broadcast");
Console.WriteLine("\t-h hostname\tUse the hostname option
if the message should " +
"be sent to a single host");
}
To send data, you need an IPEndPoint . Depending on the program
arguments, you create this in different ways. With a broadcast, IPv4
defines the address 255.255.255.255 that is returned from
IPAddress.Broadcast . There’s no IPv6 address for broadcast because
IPv6 doesn’t support broadcasts. IPv6’s replacement for broadcasts
are multicasts. Multicasts have been added to IPv4 as well. When
you’re passing a hostname, the hostname is resolved using DNS
lookup using the Dns class. The method GetHostEntryAsync returns an
IPHostEntry where the IPAddress can be retrieved from the
AddressList property. Depending on whether IPv4 or IPv6 is used, a
different IPAddress is taken from this list. Depending on your network
environment, only one of these address types might work. If a group
address is passed to the method, the address is parsed using


IPAddress.Parse :
public static async Task<IPEndPoint> GetIPEndPoint(int port,
string hostName,
bool broadcast, string groupAddress, bool ipv6)
{
IPEndPoint endpoint = null;
try
{
if (broadcast)
{
endpoint = new IPEndPoint(IPAddress.Broadcast, port);
}
else if (hostName != null)
{
IPHostEntry hostEntry = await
Dns.GetHostEntryAsync(hostName);
IPAddress address = null;
if (ipv6)
{
address = hostEntry.AddressList.Where(
a => a.AddressFamily ==
AddressFamily.InterNetworkV6)
.FirstOrDefault();
}
else
{
address = hostEntry.AddressList.Where(
a => a.AddressFamily ==
AddressFamily.InterNetwork)
.FirstOrDefault();
}
if (address == null)
{
Func<string> ipversion = () => ipv6 ? "IPv6" :
"IPv4";
Console.WriteLine($"no {ipversion()} address for
{hostName}");
return null;
}
endpoint = new IPEndPoint(address, port);
}
else if (groupAddress != null)
{
endpoint = new
IPEndPoint(IPAddress.Parse(groupAddress), port);
}


else
{
throw new InvalidOperationException($"
{nameof(hostName)}, "
+ "{nameof(broadcast)}, or {nameof(groupAddress)}
must be set");
}
}
catch (SocketException ex)
{
Console.WriteLine(ex.Message);
}
return endpoint;
}
Now, regarding the UDP protocol, the most important part of the
sender follows. After creating a UdpClient instance and converting a
string to a byte array, data is sent using the SendAsync method. **NOTE**
that neither the receiver needs to listen, nor the sender needs to
connect. UDP is really simple. However, in a case in which the sender
sends the data to nowhere——nobody receives the data——you also don’t
get any error messages:
private async Task Sender(IPEndpoint endpoint, bool
broadcast,
string groupAddress)
{
try
{
string localhost = Dns.GetHostName();
using (var client = new UdpClient())
{
client.EnableBroadcast = broadcast;
if (groupAddress != null)
{
client.JoinMulticastGroup(IPAddress.Parse(groupAddress));
}
bool completed = false;
do
{
Console.WriteLine("Enter a message or bye to exit");
string input = Console.ReadLine();
Console.WriteLine();
completed = input == "bye";
byte[] datagram = Encoding.UTF8.GetBytes($"{input}


from {localhost}");
int sent = await client.SendAsync(datagram,
datagram.Length, endpoint);
} while (!completed);
if (groupAddress != null)
{
client.DropMulticastGroup(IPAddress.Parse(groupAddress));
}
}
}
catch (SocketException ex)
{
Console.WriteLine(ex.Message);
}
}
Now you can start the receiver with this option:
-p 9400
and the sender with this option:
-p 9400 -h localhost
You can enter data in the sender that will arrive in the receiver. If you
stop the receiver, you can go on sending without detecting any error.
You can also try to use a hostname instead of localhost and run the
receiver on a different system.
With the sender, you can add the -b option and remove the hostname
to send a broadcast to all nodes listening to port 9400 on the same
network:
-p 9400 -b
Be aware that broadcasts don’t cross most routers, and of course you
can’t use broadcasts on the Internet. This situation is different with
multicasts, discussed next.
Using Multicasts
Broadcasts don’t cross routers, but multicasts can. Multicasts have


been invented to send messages to a group of systems——all nodes that
belong to the same group. With IPv4, specific IP addresses are
reserved for multicast use. The addresses start with 224.0.0.0 to
239.255.255.253. Many of these addresses are reserved for specific
protocols——for example, for routers——but 239.0.0.0/8 can be used
privately within an organization. This is very similar to IPv6, which
has well-known IPv6 multicast addresses for different routing
protocols. Addresses f::/16 are local within an organization; addresses
ffxe::/16 have global scope and can be routed over public Internet.
For a sender or receiver to use multicasts, it must join a multicast
group by invoking the JoinMulticastGroup method of the UdpClient :
client.JoinMulticastGroup(IPAddress.Parse(groupAddress));
To leave the group again, you can invoke the method
DropMulticastGroup :
client.DropMulticastGroup(IPAddress.Parse(groupAddress));
When you start both the receiver and sender with these options,
-p 9400 -g 230.0.0.1
they both belong to the same group, and multicasting is in action. As
with broadcasting, you can start multiple receivers and multiple
senders. The receivers will receive nearly all messages from each
receiver.
USING SOCKETS
The HTTP protocol is based on TCP, and thus the HttpXX classes
offered an abstraction layer over the TcpXX classes. The TcpXX classes,
however, give you more control. You can even get more control than
offered by the TcpXX or UdpXX classes with sockets. With sockets, you
can use different protocols, not only protocols based on TCP or UDP,
and also create your own protocol. What might be even more
important is that you can have more control over TCP- or UDP-based
protocols.
The SocketServerSender and SocketClient projects are implemented as


Console Application (Package) and use these namespaces:
System
System.Linq
System.IO
System.Net
System.Net.Sockets
System.Text
System.Threading
System.Threading.Tasks
Creating a Listener Using Sockets
Let’s start with a server that listens to incoming requests. The server
requires a port number that is expected with the program arguments.
With this, it invokes the Listener method (code file
SocketServer/Program.cs ):
static void Main(string[] args)
{
if (args.Length != 1)
{
ShowUsage();
return;
}
if (!int.TryParse(args[0], out int port))
{
ShowUsage();
return;
}
Listener(port);
Console.ReadLine();
}
private void ShowUsage()
{
Console.WriteLine("SocketServer port");


}
The most important code with regard to sockets is in the following
code snippet. The listener creates a new Socket object. With the
constructor, the AddressFamily , SocketType , and ProtocolType are
supplied. The AddressFamily is a large enumeration that offers many
different networks. Examples are DECnet, which was released 1975 by
Digital Equipment and used as main network communication between
PDP-11 systems; Banyan VINES, which was used to connect client
machines; and, of course, InetnetWork for IPv4 and InternetWorkV6 for
IPv6. As mentioned previously, you can use sockets for a large number
of networking protocols. The second parameter SocketType specifies
the kind of socket. Examples are Stream for TCP , Dgram for UDP , or Raw
for raw sockets. The third parameter is an enumeration for the
ProtocolType . Examples are IP , Ucmp , Udp , IPv6 , and Raw . The settings
you choose need to match. For example, using TCP with IPv4, the
address family must be InterNetwork , the socket type Stream , and the
protocol type Tcp . To create a UDP communication with IPv4, the
address family needs to be set to InterNetwork , the socket type Dgram ,
and the protocol type Udp .
public static void Listener(int port)
{
var listener = new Socket(AddressFamily.InterNetwork,
SocketType.Stream,
ProtocolType.Tcp);
listener.ReceiveTimeout = 5000; // receive timout 5 seconds
listener.SendTimeout = 5000; // send timeout 5 seconds
//...
The listener socket returned from the constructor is bound to an IP
address and port numbers. With the sample code, the listener is bound
to all local IPv4 addresses and the port number is specified with the
argument. Calling the Listen method starts the listening mode of the
socket. The socket can now accept incoming connection requests.
Specifying the parameter with the Listen method defines the size of
the backlog queue——how many clients can connect concurrently before
their connection is dealt with:
public static void Listener(int port)
{


//...
listener.Bind(new IPEndPoint(IPAddress.Any, port));
listener.Listen(backlog: 15);
Console.WriteLine($"listener started on port {port}");
//...
Waiting for the client to connect happens in the Accept method of the
Socket class. This method blocks the thread until a client connects.
After a client connects, this method needs to be invoked again to fulfill
requests of other clients; this is why this method is called within a
while loop. For the listening, a separate task, which can be canceled
from the calling thread, is started. The task to read and write using the
socket happens within the method
CommunicateWithClientUsingSocketAsync . This method receives the
Socket instance that is bound to the client to read and write:
public static void Listener(int port)
{
//...
var cts = new CancellationTokenSource();
var tf = new TaskFactory(TaskCreationOptions.LongRunning,
TaskContinuationOptions.None);
tf.StartNew(() => // listener task
{
Console.WriteLine("listener task started");
while (true)
{
if (cts.Token.IsCancellationRequested)
{
cts.Token.ThrowIfCancellationRequested();
break;
}
Console.WriteLine("waiting for accept");
Socket client = listener.Accept();
if (!client.Connected)
{
Console.WriteLine("not connected");
continue;
}
Console.WriteLine($"client connected local address " +
$"{((IPEndPoint)client.LocalEndPoint).Address} and
port " +
$"{((IPEndPoint)client.LocalEndPoint).Port}, remote
address " +


$"{((IPEndPoint)client.RemoteEndPoint).Address} and
port " +
$"{((IPEndPoint)client.RemoteEndPoint).Port}");
Task t = CommunicateWithClientUsingSocketAsync(client);
}
listener.Dispose();
Console.WriteLine("Listener task closing");
}, cts.Token);
Console.WriteLine("Press return to exit");
Console.ReadLine();
cts.Cancel();
}
For the communication with the client, a new task is created. This
frees the listener task to immediately make the next iteration to wait
for the next client connection. The Receive method of the Socket class
accepts a buffer where data can be read to as well as flags for the
socket. This byte array is converted to a string and sent back to the
client with a small change using the Send method:
private static Task
CommunicateWithClientUsingSocketAsync(Socket socket)
{
return Task.Run(() =>
{
try
{
using (socket)
{
bool completed = false;
do
{
byte[] readBuffer = new byte[1024];
int read = socket.Receive(readBuffer, 0, 1024,
SocketFlags.None);
string fromClient =
Encoding.UTF8.GetString(readBuffer, 0, read);
Console.WriteLine($"read {read} bytes:
{fromClient}");
if (string.Compare(fromClient, "shutdown",
ignoreCase: true) == 0)
{
completed = true;
}
byte[] writeBuffer = Encoding.UTF8.GetBytes($"echo
{fromClient}");


int send = socket.Send(writeBuffer);
Console.WriteLine($"sent {send} bytes");
} while (!completed);
}
Console.WriteLine("closed stream and client socket");
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
});
}
The server is ready as it is. However, let’s look at different ways to
make the read and write communication by extending the abstraction
level.
Using NetworkStream with Sockets
You’ve already used the NetworkStream class with the TcpClient and
TcpListener classes. The NetworkStream constructor allows passing a
Socket , so you can use the Stream methods Read and Write instead of
socket’s Send and Receive methods. With the constructor of the
NetworkStream you can define whether the stream should own the
socket. If——as in this code snippet——the stream owns the socket, the
socket will be closed when the stream is closed (code file
SocketServer/Program.cs ):
private static async Task
CommunicateWithClientUsingNetworkStreamAsync(
Socket socket)
{
try
{
using (var stream = new NetworkStream(socket, ownsSocket:
true))
{
bool completed = false;
do
{
byte[] readBuffer = new byte[1024];
int read = await stream.ReadAsync(readBuffer, 0,
1024);
string fromClient =


Encoding.UTF8.GetString(readBuffer, 0, read);
Console.WriteLine($"read {read} bytes:
{fromClient}");
if (string.Compare(fromClient, "shutdown",
ignoreCase: true) == 0)
{
completed = true;
}
byte[] writeBuffer = Encoding.UTF8.GetBytes($"echo
{fromClient}");
await stream.WriteAsync(writeBuffer, 0,
writeBuffer.Length);
} while (!completed);
}
Console.WriteLine("closed stream and client socket");
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
}
To use this method in the code sample, you need to change the
Listener method to invoke the method
CommunicateWithClientUsingNetworkStreamAsync instead of the method
CommunicateWithClientUsingSocketAsync .
Using Readers and Writers with Sockets
Let’s add one more abstraction layer. Because the NetworkStream
derives from the Stream class, you can also use readers and writers to
access the socket. What you need to pay attention to is the lifetime of
the readers and writers. Calling the Dispose method of a reader or
writer also disposes the underlying stream. That’s why a constructor of
the StreamReader and StreamWriter was selected where the leaveOption
argument can be set to true. With this in place, the underlying stream
is not disposed on disposing the readers and writers. The
NetworkStream is disposed on the end of the outer using statement, and
this in turn closes the socket because here the socket is owned. There’s
another aspect that you need to be aware of when using writers with
sockets: By default, the writer doesn’t flush the data, so they are kept
in the cache until the cache is full. Using network streams, you might


need to get an answer faster. Here you can set the AutoFlush property
to true (an alternative would be to invoke the FlushAsync method):
public static async Task
CommunicateWithClientUsingReadersAndWritersAsync(
Socket socket)
{
try
{
using (var stream = new NetworkStream(socket, ownsSocket:
true))
using (var reader = new StreamReader(stream,
Encoding.UTF8, false,
8192, leaveOpen: true))
using (var writer = new StreamWriter(stream,
Encoding.UTF8,
8192, leaveOpen: true))
{
writer.AutoFlush = true;
bool completed = false;
do
{
string fromClient = await reader.ReadLineAsync();
Console.WriteLine($"read {fromClient}");
if (string.Compare(fromClient, "shutdown",
ignoreCase: true) == 0)
{
completed = true;
}
await writer.WriteLineAsync($"echo {fromClient}");
} while (!completed);
}
Console.WriteLine("closed stream and client socket");
}
catch (Exception ex)
{
Console.WriteLine(ex.Message);
}
}
To use this method in the code sample, you need to change the
Listener method to invoke the method
CommunicateWithClientUsingReadersAndWritersAsync instead of the
method CommunicateWithClientUsingSocketAsync .


**NOTE**
Streams, readers, and writers are explained in detail in Chapter
22.
Implementing a Receiver Using Sockets
The receiver application SocketClient is implemented as a Console
Application (Package) as well. With the command-line arguments, the
hostname and the port number of the server need to be passed. With a
successful command-line parsing, the method SendAndReceive is
invoked to communicate with the server (code file
SocketClient/Program.cs ):
static async Task Main(string[] args)
{
if (args.Length != 2)
{
ShowUsage();
return;
}
string hostName = args[0];
if (!int.TryParse(args[1], out int port))
{
ShowUsage();
return;
}
Console.WriteLine("press return when the server is
started");
Console.ReadLine();
await SendAndReceiveAsync(hostName, port);
Console.ReadLine();
}
private static void ShowUsage()
{
Console.WriteLine("Usage: SocketClient server port");
}
The SendAndReceive method uses DNS name resolution to get the


from the hostname. This IPHostEntry is used to get an
IPv4 address of the host. After the Socket instance is created (in the
same way it was created for the server code), the address is used with
the Connect method to make a connection to the server. After the
connection was done, the methods Sender and Receiver are invoked
that create different tasks, which enables you to run these methods
concurrently. The receiver client can simultaneously read and write
from and to the server:
IPHostEntry
public static async Task SendAndReceiveAsync(string hostName,
int port)
{
try
{
IPHostEntry ipHost = await
Dns.GetHostEntryAsync(hostName);
IPAddress ipAddress = ipHost.AddressList.Where(
address => address.AddressFamily ==
AddressFamily.InterNetwork).First();
if (ipAddress == null)
{
Console.WriteLine("no IPv4 address");
return;
}
using (var client = new
Socket(AddressFamily.InterNetwork,
SocketType.Stream, ProtocolType.Tcp))
{
client.Connect(ipAddress, port);
Console.WriteLine("client successfully connected");
var stream = new NetworkStream(client);
var cts = new CancellationTokenSource();
Task tSender = SenderAsync(stream, cts);
Task tReceiver = ReceiverAsync(stream, cts.Token);
await Task.WhenAll(tSender, tReceiver);
}
}
catch (SocketException ex)
{
Console.WriteLine(ex.Message);
}
}


**NOTE**
If you change the filtering of the address list to get an IPv6
address instead of an IPv4 address, you also need to change the
Socket invocation to create a socket for the IPv6 address family.
The Sender method asks the user for input and sends this data to the
network stream with the WriteAsync method. The Receiver method
receives data from the stream with the ReadAsync method. After the
user enters the termination string, cancellation is sent from the Sender
task via a CancellationToken :
public static async Task SenderAsync(NetworkStream stream,
CancellationTokenSource cts)
{
Console.WriteLine("Sender task");
while (true)
{
Console.WriteLine("enter a string to send, shutdown to
exit");
string line = Console.ReadLine();
byte[] buffer = Encoding.UTF8.GetBytes($"{line}\r\n");
await stream.WriteAsync(buffer, 0, buffer.Length);
await stream.FlushAsync();
if (string.Compare(line, "shutdown", ignoreCase: true) ==
0)
{
cts.Cancel();
Console.WriteLine("sender task closes");
break;
}
}
}
private const int ReadBufferSize = 1024;
public static async Task ReceiverAsync(NetworkStream stream,
CancellationToken token)
{
try
{
stream.ReadTimeout = 5000;


Console.WriteLine("Receiver task");
byte[] readBuffer = new byte[ReadBufferSize];
while (true)
{
Array.Clear(readBuffer, 0, ReadBufferSize);
int read = await stream.ReadAsync(readBuffer, 0,
ReadBufferSize, token);
string receivedLine =
Encoding.UTF8.GetString(readBuffer, 0, read);
Console.WriteLine($"received {receivedLine}");
}
}
catch (OperationCanceledException ex)
{
Console.WriteLine(ex.Message);
}
}
When you run both the client and server, you can see communication
across TCP.
**NOTE**
The sample code implements a TCP client and server. TCP
requires a connection before sending and receiving data; this is
done by calling the Connect method. For UDP, the Connect method
could be invoked as well, but it doesn’t do a connection. With
UDP, instead of calling the Connect method, you can use the SendTo
and ReceiveFrom methods instead. These methods require an
EndPoint parameter where the endpoint is defined just when
sending and receiving.
**NOTE**
Cancellation tokens are explained in Chapter 21.


SUMMARY
This chapter described the .NET classes available in the System.Net
namespace for communication across networks. You have seen some
of the .NET base classes that deal with opening client connections on
the network and Internet, and how to send requests to and receive
responses from servers.
As a rule of thumb, when programming with classes in the System.Net
namespace, you should always try to use the most generic class
possible. For instance, using the TcpClient class instead of the Socket
class isolates your code from many of the lower-level socket details.
Moving one step higher, the HttpClient class is an easy way to make
use of the HTTP protocol.
This book covers much more networking than the core networking
features you’ve seen in this chapter. Chapter 32 covers ASP.NET Web
API to offer services using the HTTP protocol. In Bonus Chapter 3,
which you can find online, you read about WebHooks and SignalR——
two technologies that offers event-driven communication.
In the next chapter, you read about security. You can see the
CryptoStream in action for encrypting streams, no matter whether they
are used with files or networking.