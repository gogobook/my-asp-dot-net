

Localization
WHAT’S IN THIS CHAPTER?
Formatting of numbers and dates
Using resources for localized content
Localizing ASP.NET Core Web Applications
Localizing Universal Windows apps
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available in the GitHub repository
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the folder Localization .
The code for this chapter is divided into the following major
examples:
NumberAndDateFormatting
SortingDemo
CreateResource
UWPCultureDemo
ResourcesDemo


WebApplicationSample
ASPNETCoreMVCSample
UWPLocalization
GLOBAL MARKETS
NASA’s Mars Climate Orbiter was lost on September 23, 1999, at a
cost of $125 million, because one engineering team used metric units
while another one used inches for a key spacecraft operation. When
writing applications for international distribution, different cultures
and regions must be kept in mind.
Different cultures have diverging calendars and use different number
and date formats; and sorting strings may lead to various results
because the order of A–Z is defined differently based on the culture.
To make usable applications for global markets, you must globalize
and localize them.
This chapter covers the globalization and localization of .NET
applications. Globalization is about internationalizing applications:
preparing applications for international markets. With globalization,
the application supports number and date formats that vary according
to culture, calendars, and so on. Localization is about translating
applications for specific cultures. For translations of strings, you can
use resources such as .NET resources or WPF resource dictionaries.
.NET supports the globalization and localization of Windows and web
applications. To globalize an application, you can use classes from the
namespace System.Globalization ; to localize an application, you can
use resources supported by the namespace System.Resources .
NAMESPACE SYSTEM.GLOBALIZATION
The System.Globalization namespace holds all the culture and region
classes necessary to support different date formats, different number
formats, and even different calendars that are represented in classes
such as GregorianCalendar , HebrewCalendar , JapaneseCalendar , and so
on. By using these classes, you can display different representations


according to the user’s locale.
This section looks at the following issues and considerations when
using the System.Globalization namespace:
Unicode issues
Cultures and regions
An example showing all cultures and their characteristics
Sorting
Unicode Issues
A Unicode character has 16 bits, so there is room for 65,536
characters. Is this enough for all languages currently used in
information technology? In the case of the Chinese language, for
example, more than 80,000 characters are needed. Fortunately,
Unicode has been designed to deal with this issue. With Unicode you
must differentiate between base characters and combining characters.
You can add multiple combining characters to a base character to
build a single display character or a text element.
Take, for example, the Icelandic character Ogonek. Ogonek can be
combined by using the base character 0x006F (Latin small letter o),
and the combining characters 0x0328 (combining Ogonek), and
0x0304 (combining Macron), as shown in Figure 27-1. Combining
characters are defined within ranges from 0x0300 to 0x0345. For
American and European markets, predefined characters exist to
facilitate dealing with special characters. The character Ogonek is also
defined by the predefined character 0x01ED.
FIGURE 27-1
For Asian markets, where more than 80,000 characters are necessary
for Chinese alone, such predefined characters do not exist. In Asian
languages, you always have to deal with combining characters. The


problem is getting the right number of display characters or text
elements and getting to the base characters instead of the combined
characters. The namespace System.Globalization offers the class
StringInfo , which you can use to deal with this issue.
The following table lists the static methods of the class StringInfo that
help in dealing with combined characters.
METHOD
DESCRIPTION
GetNextTextElement
Returns the first text element (base
character and all combining characters) of
a specified string
GetTextElementEnumerator Returns a TextElementEnumerator object
that allows iterating all text elements of a
string
ParseCombiningCharacters Returns an integer array referencing all
base characters of a string
**NOTE**
A single display character can contain multiple Unicode
characters. To address this issue, when you write applications
that support international markets, don’t use the data type char ;
use string instead. A string can hold a text element that contains
both base characters and combining characters, whereas a char
cannot.
Cultures and Regions
The world is divided into multiple cultures and regions, and
applications must be aware of these cultural and regional differences.
A culture is a set of preferences based on a user’s language and
cultural habits. RFC 4646 ( http://www.ietf.org/rfc/rfc4646.txt )
defines culture names that are used worldwide, depending on a
language and a country or region. Some examples are en-AU, en-CA,


en-GB, and en-US for the English language in Australia, Canada, the
United Kingdom, and the United States, respectively.
Possibly the most important class in the System.Globalization
namespace is CultureInfo . CultureInfo represents a culture and
defines calendars, formatting of numbers and dates, and sorting
strings used with the culture.
The class RegionInfo represents regional settings (such as the
currency) and indicates whether the region uses the metric system.
Some regions can use multiple languages. One example is the region of
Spain, which has Basque (eu-ES), Catalan (ca-ES), Spanish (es-ES),
and Galician (gl-ES) cultures. Like one region can have multiple
languages, one language can be spoken in different regions; for
example, Spanish is spoken in Mexico, Spain, Guatemala, Argentina,
and Peru, to name only a few countries.
Later in this chapter is a sample application that demonstrates these
characteristics of cultures and regions.
Specific, Neutral, and Invariant Cultures
When using cultures in the .NET Framework, you must differentiate
between three types: specific, neutral, and invariant cultures. A
specific culture is associated with a real, existing culture defined with
RFC 4646, as described in the preceding section. A specific culture can
be mapped to a neutral culture. For example, de is the neutral culture
of the specific cultures de-AT, de-DE, de-CH, and others. de is
shorthand for the German language (Deutsch); AT, DE, and CH are
shorthand for the countries Austria, Germany, and Switzerland,
respectively.
When translating applications, it is typically not necessary to do
translations for every region; not much difference exists between the
German language in the countries Austria and Germany. Instead of
using specific cultures, you can use a neutral culture to localize
applications.
The invariant culture is independent of a real culture. When storing
formatted numbers or dates in files, or sending them across a network
to a server, using a culture that is independent of any user settings is


the best option.
Figure 27-2 shows how the culture types relate to each other.
FIGURE 27-2
Current Culture and CurrentUICulture
When you set cultures, you need to differentiate between a culture for
the user interface and a culture for the number and date formats.
Cultures are associated with a thread, and with these two culture
types, two culture settings can be applied to a thread. The CultureInfo
class has the static properties CurrentCulture and CurrentUICulture .
The property CurrentCulture is for setting the culture that is used with
formatting and sort options, whereas the property CurrentUICulture is
used for the language of the user interface.
Users can install additional languages to Windows 10 by selecting
Time & Language in the Windows settings, and from there Region &
Language (see Figure 27-3). The language configured as default is the
current UI culture.


FIGURE 27-3
To change the current culture, you use the Additional Date, Time, &
Regional Settings link in the dialog shown in Figure 27-3. From there,
you click the Change Date, Time, or Number Formats option to see the
dialog shown in Figure 27-4. The language setting for the format
influences the current culture. It is also possible to change the defaults
for the number format, the time format, and the date format
independent of the culture.


FIGURE 27-4
These settings provide a very good default, and in many cases, you
won’t need to change the default behavior. If the culture should be
changed, you can easily do this programmatically by changing both
cultures to, say, the Spanish culture, as shown in this code snippet
(using the namespace System.Globalization ):
var ci = new CultureInfo("es-ES");


CultureInfo.CurrentCulture = ci;
CultureInfo.CurrentUICulture = ci;
Now that you know how to set the culture, the following sections
discuss number and date formatting, which are influenced by the
CurrentCulture setting.
Number Formatting
The number structures Int16 , Int32 , Int64 , and so on in the System
namespace have an overloaded ToString method. You can use this
method to create a different representation of the number, depending
on the locale. For the Int32 structure, ToString is overloaded with the
following four versions:
public
public
public
public
string
string
string
string
ToString();
ToString(IFormatProvider);
ToString(string);
ToString(string, IFormatProvider);
without arguments returns a string without format options.
You can also pass a string and a class that implements
IFormatProvider .
ToString
The string specifies the format of the representation. The format can
be a standard numeric formatting string or a picture numeric
formatting string. For standard numeric formatting, strings are
predefined where C specifies the currency notation, D creates a decimal
output, E creates scientific output, F creates fixed-point output, G
creates general output, N creates number output, and X creates
hexadecimal output. With a picture numeric formatting string, it is
possible to specify the number of digits, section and group separators,
percent notation, and so on. The picture numeric format string
###,### means two three-digit blocks separated by a group separator.
The IFormatProvider interface is implemented by the
NumberFormatInfo , DateTimeFormatInfo , and CultureInfo classes. This
interface defines a single method, GetFormat , that returns a format
object.
You can use NumberFormatInfo to define custom formats for numbers.
With the default constructor of NumberFormatInfo , a culture-


independent or invariant object is created. Using the properties of
NumberFormatInfo , it is possible to change all the formatting options,
such as a positive sign, a percent symbol, a number group separator, a
currency symbol, and a lot more. A read-only, culture-independent
NumberFormatInfo object is returned from the static property
InvariantInfo . A NumberFormatInfo object in which the format values
are based on the CultureInfo of the current thread is returned from
the static property CurrentInfo .
The sample code NumberAndDateFormatting makes use of the following
namespaces:
System
System.Globalization
To create the next example, you can start with a Console App (.NET
Core) project. In this code, the first example shows a number
displayed in the format of the current culture (here: English-US, the
setting of the operating system). The second example uses the
ToString method with the IFormatProvider argument. CultureInfo
implements IFormatProvider , so create a CultureInfo object using the
French culture. The third example changes the current culture. The
culture is changed to German by using the property CurrentCulture of
the CultureInfo instance (code file
NumberAndDateFormatting\Program.cs ):
public static void NumberFormatDemo()
{
int val = 1234567890;
// culture of the current thread
Console.WriteLine(val.ToString("N"));
// use IFormatProvider
Console.WriteLine(val.ToString("N", new CultureInfo("fr-
FR")));
// change the current culture
CultureInfo.CurrentCulture = new CultureInfo("de-DE");
Console.WriteLine(val.ToString("N"));
}
You can compare the following different output for U.S. English,
French, and German, respectively, shown here:


1,234,567,890.00
1 234 567 890,00
1.234.567.890,00
Date Formatting
The same support for numbers is available for dates. The DateTime
structure has some overloads of the ToString method for date-to-
string conversions. You can pass a string format and assign a different
culture:
public
public
public
public
string
string
string
string
ToString();
ToString(IFormatProvider);
ToString(string);
ToString(string, IFormatProvider);
With the string argument of the ToString method, you can specify a
predefined format character or a custom format string for converting
the date to a string. The class DateTimeFormatInfo specifies the possible
values. With DateTimeFormatInfo , the case of the format strings has a
different meaning. D defines a long date format; d defines a short date
format. Other examples of possible formats are ddd for the abbreviated
day of the week, dddd for the full day of the week, yyyy for the year, T
for a long time, and t for a short time. With the IFormatProvider
argument, you can specify the culture. Using an overloaded method
without the IFormatProvider argument implies that the current culture
is used (code file NumberAndDateFormatting/Program.cs ):
public static void DateFormatDemo()
{
var d = new DateTime(2017, 09, 17);
// current culture
Console.WriteLine(d.ToLongDateString());
// use IFormatProvider
Console.WriteLine(d.ToString("D", new CultureInfo("fr-
FR")));
// use current culture
Console.WriteLine($"{CultureInfo.CurrentCulture}: {d:D}");
CultureInfo.CurrentCulture = new CultureInfo("es-ES");
Console.WriteLine($"{CultureInfo.CurrentCulture}: {d:D}");
}
The output of this example program shows ToLongDateString with the


current culture of the thread, a French version where a CultureInfo
instance is passed to the ToString method, and a Spanish version
where the CurrentCulture property of the thread is changed to es-ES:
Sunday, September 17, 2017
dimanche 17 septembre 2017
en-US: Sunday, September 17, 2017
es-ES: domingo, 17 de septiembre de 2017
Cultures in Action
To see all cultures in action, you can use a sample UWP app that lists
all cultures and demonstrates different characteristics of culture
properties. On the left side of the UI, a tree view is used to display all
the cultures. On the right side is a user control that displays relevant
information about the selected culture and region. Figure 27-5 shows
the user interface of the user control in the Visual Studio 2017
Designer.
FIGURE 27-5
**NOTE**


The sample code makes use of a tree control. The Windows 10
Runtime does not include a tree view control with the Fall
Creators Update 2017, but one is expected later. Several third-
party tree controls are available for UWP that you could use.
Microsoft’s Windows Universal Samples at
https://github.com/Microsoft/Windows-universal-samples also
include a tree view control. This control is used with this UWP
sample. Because this control is written with C++ code, you need to
install the C++ component with the Universal Windows Platform
development workload.
During initialization of the application, all available cultures are added
to the TreeView control that is placed on the left side of the application.
This initialization happens in a view-model in the method
SetupCultures , which is called in the constructor of the
CulturesViewModel class (code file
UWPCultureDemo/CulturesViewModel.cs ):
public CulturesViewModel()
{
SetupCultures();
}
For the data that is shown in the user interface, the custom class
CultureData is created. This class can be bound to a TreeView control,
as it has a property SubCultures that contains a list of CultureData .
Therefore, the TreeView control enables walking through this tree.
Other than the subcultures, CultureData contains the CultureInfo type
and sample values for a number, a date, and a time. The number
returns a string in the number format for the specific culture, and the
date and time return strings in the specific culture formats as well.
CultureData contains a RegionInfo class to display regions. With some
neutral cultures (for example, English), creating a RegionInfo throws
an exception, as there are regions only with specific cultures. However,
with other neutral cultures (for example, German), creating a
RegionInfo succeeds and is mapped to a default region. The exception
thrown here is handled (code file UWPCultureDemo/CultureData.cs ):
public class CultureData


{
public CultureInfo CultureInfo { get; set; }
public List<CultureData> SubCultures { get; set; }
double numberSample = 9876543.21;
public string NumberSample => numberSample.ToString("N",
CultureInfo);
public string DateSample => DateTime.Today.ToString("D",
CultureInfo);
public string TimeSample => DateTime.Now.ToString("T",
CultureInfo);
public RegionInfo RegionInfo
{
get
{
RegionInfo ri;
try
{
ri = new RegionInfo(CultureInfo.Name);
}
catch (ArgumentException)
{
// with some neutral cultures regions are not
available
return null;
}
return ri;
}
}
}
In the method SetupCultures , you get all cultures from the static
method CultureInfo.GetCultures . Passing CultureTypes.AllCultures
to this method returns an unsorted array of all available cultures. The
result is sorted by the name of the culture. With the result of the sorted
cultures, a collection of CultureData objects is created and the
CultureInfo and SubCultures properties are assigned. With the result
of this, a dictionary is created to enable fast access to the culture name.
For the data that should be shown in the UI, a list of CultureData
objects is created that contains all the root cultures for the tree view
after the foreach statement is completed. Root cultures can be verified
to determine whether they have the invariant culture as their parent.
The invariant culture has the Locale Identifier (LCID) 127 . Every


culture has its own unique identifier that can be used for a fast
verification. In the code snippet, root cultures are added to the
rootCultures collection within the block of the if statement. If a
culture has the invariant culture as its parent, it is a root culture.
If the culture does not have a parent culture, it is added to the root
nodes of the tree. To find parent cultures, all cultures are remembered
inside a dictionary. (See Chapter 10, “Collections,” for more
information about dictionaries, and Chapter 8, “Delegates, Lambdas,
and Events,” for details about lambda expressions.) If the culture
iterated is not a root culture, it is added to the SubCultures collection
of the parent culture. The parent culture can be quickly found by using
the dictionary. In the last step, the root cultures are made available to
the UI by assigning them to the RootCultures property (code file
UWPCultureDemo/CulturesViewModel.cs ):
private void SetupCultures()
{
var cultureDataDict =
CultureInfo.GetCultures(CultureTypes.AllCultures)
.OrderBy(c => c.Name)
.Select(c => new CultureData
{
CultureInfo = c,
SubCultures = new List<CultureData>()
})
.ToDictionary(c => c.CultureInfo.Name);
var rootCultures = new List<CultureData>();
foreach (var cd in cultureDataDict.Values)
{
if (cd.CultureInfo.Parent.LCID == 127)
{
rootCultures.Add(cd);
}
else
{
if
(cultureDataDict.TryGetValue(cd.CultureInfo.Parent.Name,
out CultureData parentCultureData))
{
parentCultureData.SubCultures.Add(cd);
}
else


{
throw new InvalidOperationException(
"parent culture not found");
}
}
}
foreach (var rootCulture in rootCultures.OrderBy(
cd => cd.CultureInfo.EnglishName))
{
RootCultures.Add(rootCulture);
}
}
public IList<CultureData> RootCultures { get; } = new
List<CultureData>();
Now let’s get into the XAML code for the display. A TreeView is used to
display all the cultures. For the display of items inside the TreeView , an
item template is used. This template uses a TextBlock that is bound to
the EnglishName property of the CultureInfo class (code file
UWPCultureDemo/MainPage.xaml ):
<tvc:TreeView x:Name="treeView1"
IsMultiSelectCheckBoxEnabled="False"
IsItemClickEnabled="True"
SelectionChanged="{x:Bind OnSelectionChanged,
Mode=OneTime}">
<tvc:TreeView.ItemTemplate>
<DataTemplate>
<StackPanel Orientation="Horizontal" Height="40"
Margin="{Binding Depth,
Converter={StaticResource IntegerToIndConverter}}">
<FontIcon x:Name="expandCollapseChevron"
Glyph="{Binding IsExpanded,
Converter={StaticResource
ExpandCollapseGlyphConverter}}"
Visibility="{Binding Data.SubCultures,
Converter={StaticResource EmptyConverter}}"
FontSize="12"
Margin="12,8,12,8"
FontFamily="Segoe MDL2 Assets" />
<TextBlock Text="{Binding
Data.CultureInfo.EnglishName}" />
</StackPanel>
</DataTemplate>


</tvc:TreeView.ItemTemplate>
<tvc:TreeView.ItemContainerTransitions>
<TransitionCollection>
<ContentThemeTransition />
<ReorderThemeTransition />
<EntranceThemeTransition IsStaggeringEnabled="False" />
</TransitionCollection>
</tvc:TreeView.ItemContainerTransitions>
</tvc:TreeView>
In the code-behind file, the TreeView is initialized by accessing the
CultureData objects from the view-model. Using the CultureData
objects, TreeNode objects are created for the TreeView . The TreeNode
class defines a Data property where the CultureData object is assigned.
The Add method of the TreeNode allows adding child objects. Child
objects are added by recursively invoking the local function
AddSubNodes (code file UWPCultureDemo/MainPage.xaml.cs ):
protected override void OnNavigatedTo(NavigationEventArgs e)
{
void AddSubNodes(TreeNode parent)
{
if (parent.Data is CultureData cd && cd.SubCultures !=
null)
{
foreach (var culture in cd.SubCultures)
{
var node = new TreeNode
{
Data = culture,
ParentNode = parent
};
parent.Add(node);
foreach (var subCulture in culture.SubCultures)
{
AddSubNodes(node);
}
}
}
}
base.OnNavigatedTo(e);
var rootNodes = ViewModel.RootCultures.Select(cd => new
TreeNode
{
Data = cd


});
foreach (var node in rootNodes)
{
treeView1.RootNode.Add(node);
AddSubNodes(node);
}
}
When the user selects a node inside the tree, the handler of the
SelectedItemChanged event of the TreeView is called. In the following
code snippet, the handler is implemented in the method
OnSelectionChanged . With the implementation, the SelectedCulture
property of the associated ViewModel is set to the selected CultureData
object (code file UWPCultureDemo/MainPage.xaml.cs ):
private void OnSelectionChanged(object sender,
SelectionChangedEventArgs e)
{
ViewModel.SelectedCulture =
(treeView1.SelectedItems?.FirstOrDefault() as
TreeNode)?.Data
as CultureData;
}
To display the values of the selected item, you use several TextBlock
controls. These bind to the CultureInfo property of the CultureData
class and in turn to properties of the CultureInfo type that is returned
from CultureInfo , such as Name , IsNeutralCulture , EnglishName ,
NativeName , and so on. To convert a Boolean value, as returned from
the IsNeutralCulture property, to a Visibility enumeration value,
and to display calendar names, you use converters (XAML file
UWPCultureDemo/CultureDetailUC.xaml ):
<TextBlock Grid.Row="0" Grid.Column="0" Text="Culture Name:"
/>
<TextBlock Grid.Row="0" Grid.Column="1"
Text="{x:Bind CultureData.CultureInfo.Name, Mode=OneWay}"
Width="100" />
<TextBlock Grid.Row="0" Grid.Column="2" Text="Neutral
Culture"
Visibility="{x:Bind
CultureData.CultureInfo.IsNeutralCulture, Mode=OneWay}" />


<TextBlock Grid.Row="1" Grid.Column="0" Text="English Name:"
/>
<TextBlock Grid.Row="1" Grid.Column="1" Grid.ColumnSpan="2"
Text="{x:Bind CultureData.CultureInfo.EnglishName,
Mode=OneWay}" />
<TextBlock Grid.Row="2" Grid.Column="0" Text="Native Name:"
/>
<TextBlock Grid.Row="2" Grid.Column="1" Grid.ColumnSpan="2"
Text="{x:Bind CultureData.CultureInfo.NativeName}" />
<TextBlock Grid.Row="3" Grid.Column="0" Text="Default
Calendar:" />
<TextBlock Grid.Row="3" Grid.Column="1" Grid.ColumnSpan="2"
Text="{x:Bind CultureData.CultureInfo.Calendar, Mode=OneWay
Converter={StaticResource calendarConverter}}" />
<TextBlock Grid.Row="4" Grid.Column="0" Text="Optional
Calendars:" />
<ListBox Grid.Row="4" Grid.Column="1" Grid.ColumnSpan="2"
ItemsSource="{x:Bind
CultureData.CultureInfo.OptionalCalendars}">
<ListBox.ItemTemplate>
<DataTemplate>
<TextBlock Text="{Binding
Converter={StaticResource calendarConverter}}" />
</DataTemplate>
</ListBox.ItemTemplate>
</ListBox>
To display the calendar text, you use an object that implements
IValueConverter . Here is the implementation of the Convert method in
the class CalendarTypeToCalendarInformationConverter . The
implementation uses the class name and calendar type name to return
a useful value for the calendar (code file
UWPCultureDemo/Converters/CalendarTypeToCalendarInformationConverter.cs
public object Convert(object value, Type targetType, object
parameter,
string language)
{
if (value is Calendar cal)
{
var calText = new StringBuilder(50);
calText.Append(cal.ToString());
calText.Remove(0, 21); // remove the namespace


calText.Replace("Calendar", "");
if (cal is GregorianCalendar gregCal)
{
calText.Append($" {gregCal.CalendarType}");
}
return calText.ToString();
}
else
{
return null;
}
}
The CultureData class contains properties to display sample
information for number, date, and time formats. These properties are
bound with the following TextBlock elements (XAML file
UWPCultureDemo/CultureDetailUC.xaml ):
<TextBlock Grid.Row="0" Grid.Column="0" Text="Number" />
<TextBlock Grid.Row="0" Grid.Column="1"
Text="{x:Bind CultureData.NumberSample, Mode=OneWay}" />
<TextBlock Grid.Row="1" Grid.Column="0" Text="Full Date" />
<TextBlock Grid.Row="1" Grid.Column="1"
Text="{x:Bind CultureData.DateSample, Mode=OneWay}" />
<TextBlock Grid.Row="2" Grid.Column="0" Text="Time" />
<TextBlock Grid.Row="2" Grid.Column="1"
Text="{x:Bind CultureData.TimeSample, Mode=OneWay}" />
The information about the region is shown with the last part of the
XAML code. The complete area hidden if the RegionInfo is not
available. The TextBlock elements bind the DisplayName ,
CurrencySymbol , ISOCurrencySymbol , and IsMetric properties of the
RegionInfo type:
<Grid Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="3"
Visibility="{x:Bind CultureData.RegionInfo, Mode=OneWay,
Converter={StaticResource NullConverter}}">
<!-- ... -->
<TextBlock Grid.Row="0" Grid.Column="0" Text="Region
Information"
Style="{StaticResource SubheaderTextBlockStyle" />
<TextBlock Grid.Row="0" Grid.Column="1" Grid.ColumnSpan="2"
Text="{x:Bind CultureData.RegionInfo.DisplayName,


Mode=OneWay}" />
<TextBlock Grid.Row="1" Grid.Column="0" Text="Currency" />
<TextBlock Grid.Row="1" Grid.Column="1"
Text="{x:Bind CultureData.RegionInfo.CurrencySymbol,
Mode=OneWay}" />
<TextBlock Grid.Row="1" Grid.Column="2"
Text="{x:Bind CultureData.RegionInfo.ISOCurrencySymbol,
Mode=OneWay}" />
<TextBlock Grid.Row="2" Grid.Column="1" Text="Is Metric"
Visibility="{x:Bind CultureData.RegionInfo.IsMetric,
Mode=OneWay}" />
</Grid>
When you start the application, you can see all available cultures in the
tree view, and selecting a culture lists its characteristics, as shown in
Figure 27-6.
FIGURE 27-6


Sorting
The sample SortingDemo makes use of the following namespaces:
System
System.Collections
System.Collections.Generic
System.Globalization
Sorting strings varies according to the culture. The algorithms that
compare strings for sorting by default are culture-specific. For
example, in Finnish the characters V and W are treated the same. To
demonstrate this behavior with a Finnish sort, the following code
creates a small sample console application in which some U.S. states
are stored unsorted inside an array.
The method DisplayNames shown here is used to display all elements of
an array or a collection on the console (code file
SortingDemo/Program.cs ):
public static void DisplayNames(string title,
IEnumerable<string> names)
{
Console.WriteLine(title);
Console.WriteLine(string.Join("-", names));
Console.WriteLine();
}
In the Main method, after creating the array with some of the U.S.
states, the thread property CurrentCulture is set to the Finnish culture
so that the following Array.Sort uses the Finnish sort order. Calling
the method DisplayNames displays all the states on the console:
public static void Main()
{
string[] names = {"Alabama", "Texas", "Washington",
"Virginia",
"Wisconsin", "Wyoming", "Kentucky", "Missouri", "Utah",
"Hawaii","Kansas", "Louisiana", "Alaska", "Arizona"};
CultureInfo.CurrentCulture = new CultureInfo("fi-FI");
Array.Sort(names);
DisplayNames("Sorted using the Finnish culture", names);
//...
}


After the first display of some U.S. states in the Finnish sort order, the
array is sorted once again. If you want a sort that is independent of the
users’ culture, which would be useful when the sorted array is sent to a
server or stored somewhere, you can use the invariant culture.
You can do this by passing a second argument to Array.Sort . The Sort
method expects an object implementing IComparer with the second
argument. The Comparer class from the System.Collections namespace
implements IComparer . Comparer.DefaultInvariant returns a Comparer
object that uses the invariant culture for comparing the array values
for a culture-independent sort:
public static void Main()
{
//...
// sort using the invariant culture
Array.Sort(names,
System.Collections.Comparer.DefaultInvariant);
DisplayNames("Sorted using the invariant culture", names);
}
The program output shows different sort results with the Finnish and
culture-independent cultures——Virginia is before Washington when
using the invariant sort order, and vice versa when using Finnish:
Sorted using the Finnish culture
Alabama-Alaska-Arizona-Hawaii-Kansas-Kentucky-Louisiana-
Missouri-Texas-Utah-
Washington-Virginia-Wisconsin-Wyoming
Sorted using the invariant culture
Alabama-Alaska-Arizona-Hawaii-Kansas-Kentucky-Louisiana-
Missouri-Texas-Utah-
Virginia-Washington-Wisconsin-Wyoming
**NOTE**
If sorting a collection should be independent of a culture, the
collection must be sorted with the invariant culture. This can be
particularly useful when sending the sort result to a server or
storing it inside a file. To display a sorted collection to the user,


it’s best to sort it with the user’s culture.
In addition to a locale-dependent formatting and measurement
system, text and pictures may differ depending on the culture. This is
where resources come into play.
RESOURCES
You can put resources such as pictures or string tables into resource
files or satellite assemblies. Such resources can be very helpful when
localizing applications, and .NET has built-in support to search for
localized resources. Before you see how to use resources to localize
applications, the following sections explain how you can create and
read resources without looking at language aspects.
Resource Readers and Writers
With .NET Core, the resource readers and writers are limited
compared to the full .NET version (at the time of this writing).
However, for many scenarios——including multiplatform support——what
is needed is available.
The CreateResource sample application creates a resource file
dynamically and reads resources from the file. This sample makes use
of the following namespaces:
System
System.Collections
System.IO
System.Resources
enables you to create binary resource files. The
constructor of the writer requires a Stream that is created using the
File class. You add resources by using the AddResource method (code
file CreateResource/Program.cs ):
ResourceWriter
private const string ResourceFile = "Demo.resources";
public static void CreateResource()
{
FileStream stream = File.OpenWrite(ResourceFile);
using (var writer = new ResourceWriter(stream))


{
writer.AddResource("Title", "Professional C#");
writer.AddResource("Author", "Christian Nagel");
writer.AddResource("Publisher", "Wrox Press");
}
}
To read the resources of a binary resource file, you can use
ResourceReader . The GetEnumerator method of the reader returns an
IDictionaryEnumerator that is used within the following foreach
statement to access the key and value of the resource:
public static void ReadResource()
{
FileStream stream = File.OpenRead(ResourceFile);
using (var reader = new ResourceReader(stream))
{
foreach (DictionaryEntry resource in reader)
{
Console.WriteLine($"{resource.Key} {resource.Value}");
}
}
}
Running the application returns the keys and values that have been
written to the binary resource file. As shown in the next section, you
can also use a command-line tool——the Resource File Generator
(resgen)——to create and convert resource files.
Using the Resource File Generator
Resource files can contain items such as pictures and string tables. A
resource file is created by using either a normal text file or a .resX file
that uses XML. This section starts with a simple text file.
You can create a resource that embeds a string table by using a normal
text file. The text file assigns strings to keys. The key is the name that
can be used from a program to get the value. Spaces are allowed in
both keys and values.
This example shows a simple string table in the file
Wrox.ProCSharp.Localization.MyResources.txt :
Title = Professional C#


Chapter = Localization
Author = Christian Nagel
Publisher = Wrox Press
**NOTE**
When saving text files with Unicode characters, you must save the
file with the proper encoding. To select the UTF8 encoding, use
the Save As dialog.
You can use the Resource File Generator ( Resgen.exe ) utility to create
a resource file out of Wrox .ProCSharp.Localization.MyResources.txt .
Typing the line
resgen Wrox.ProCSharp.Localization.MyResources.txt
creates the file Wrox.ProCSharp.Localization.MyResources.resources .
The resulting resource file can be either added to an assembly as an
external file or embedded into the DLL or EXE. Resgen also supports
the creation of XML-based .resX resource files. One easy way to build
an XML file is by using Resgen itself:
resgen Wrox.ProCSharp.Localization.MyResources.txt
Wrox.ProCSharp.Localization.MyResources.resX
This command creates the XML resource file
Wrox.ProCSharp.LocalizationMyResources.resX . Resgen
supports
strongly typed resources. A strongly typed resource is represented by a
class that accesses the resource. You can create the class with the /str
option of the Resgen utility:
resgen
/str:C#,Wrox.ProCSharp.Localization,MyResources,MyResources.cs
Wrox.ProCSharp.Localization.MyResources.resX
With the /str option, the language, namespace, class name, and
filename for the source code are defined, in that order.


Using Resource Files with ResourceManager
By default, resource files are embedded in the assembly. You can
customize this——for example, by removing resources from the
assembly by adding an EmbeddedResource element with the Remove
attribute to an ItemGroup in the project file as shown:
<ItemGroup>
<EmbeddedResource Remove="Resources\Messages.de.resx" />
</ItemGroup>
To see how resource files can be loaded with the ResourceManager class,
create a Console App (.NET Core) and name it ResourcesDemo . This
sample makes use of the following namespaces:
System
System.Globalization
System.Reflection
System.Resources
Create a Resources folder and add a Messages.resx file to this folder.
The Messages.resx file is filled with a key and value for English-US
content——for example, the key GoodMorning and the value Good
Morning! This will be the default language. You can add other language
resource files with the naming convention to add the culture to the
resource file, for example, Messages.de.resx for German languages
and Messages.de-AT.resx for Austrian differences.
To access the embedded resource, use the ResourceManager class from
the System.Resources namespace and the
System.Resources.ResourceManager NuGet package. When you’re
instantiating the ResourceManager , one overload of the constructor
needs the name of the resource and the assembly. The namespace of
the application is ResourcesDemo ; the resource file is in the folder
Resources , which defines the sub-namespace Resources, and it has the
name Messages.resx . This defines the name
ResourcesDemo.Resources.Messages . You can retrieve the assembly of
the resource using the GetTypeInfo method of the Program type, which
defines an Assembly property. Using the resources instance, the
GetString method returns the value of the key passed from the
resource file. Passing a culture such as de-AT for the second argument


looks for resources in the de-AT resource file. If it’s not found there,
the neutral language for de is taken, the de resource file. If it’s not
found there, the default resource file without culture naming succeeds
to return the value (code file ResourcesDemo/Program.cs ):
var resources = new
ResourceManager("ResourcesDemo.Resources.Messages",
typeof(Program).GetTypeInfo().Assembly);
string goodMorning = resources.GetString("GoodMorning",
new CultureInfo("de-AT"));
Console.WriteLine(goodMorning);
Another overload of the ResourceManager constructor just requires the
type of the class. This ResourceManager looks for a resource file named
Program.resx :
var programResources = new ResourceManager(typeof(Program));
Console.WriteLine(programResources.GetString("Resource1"));
The System.Resources Namespace
Before moving on to the next example, this section provides a review
of the classes contained in the System.Resources namespace that deal
with resources:
ResourceManager ——Can
be used to get resources for the current
culture from assemblies or resource files. Using the
ResourceManager , you can also get a ResourceSet for a culture.
ResourceSet ——Represents the resources for a culture. When a
ResourceSet instance is created, it enumerates over a class,
implementing the interface IResourceReader , and it stores all
resources in a Hashtable .
IResourceReader ——Used from the ResourceSet to enumerate
resources. The class ResourceReader implements this interface.
ResourceWriter ——Used
to create a resource file. ResourceWriter
implements the interface IResourceWriter .
LOCALIZATION WITH ASP.NET CORE


**NOTE**
For using localization with ASP.NET Core, you need to know
about both cultures and resources that are discussed in this
chapter as well as creating ASP.NET Core applications. In case
you didn’t create ASP.NET Core web applications with .NET Core
before, you should read Chapter 30, “ASP.NET Core,” before
continuing with this part of the chapter.
For localization of ASP.NET Core web applications, you can use the
CultureInfo class and resources like what you’ve seen earlier in this
chapter, but there are some additional issues that you need to resolve.
Setting the culture for the complete application doesn’t fulfill usual
needs because users are coming from different cultures. So, it’s
necessary to set the culture with every request to the server.
How do you know about the culture of the user? There are different
options. The browser sends preferred languages within the HTTP
header with every request. This information from the browser can
come from browser settings or when the browser itself checks the
installed languages. Another option is to define URL parameters or
use different domain names for different languages. You can use
different domain names in some scenarios, such as
www.cninnovation.com for an English version of the site and
www.cninnovation.de for a German version. But what about
www.cninnovation.ch ? This should be offered both in German and
French and probably Italian. URL parameters such as
www.cninnovation.com/culture=de could help here. Using
www.cninnovation.com/de works like the URL parameter by defining a
specific route. Another option is to allow the user to select the
language and define a cookie to remember this option.
All these scenarios are supported out of the box by ASP.NET Core.
Registering Localization Services
To start seeing this in action, create a new ASP.NET Core Web


Application using an Empty ASP.NET Core project template. This
sample project makes use of the following dependency and
namespaces:
Dependency
Microsoft.AspNetCore.All
Namespaces
Microsoft.AspNetCore
Microsoft.AspNetCore.Builder
Microsoft.AspNetCore.Hosting
Microsoft.AspNetCore.Http
Microsoft.AspNetCore.Localization
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Localization
System
System.Globalization
System.Text.Encodings.Web
Within the Startup class, you need to invoke the AddLocalization
extension method to register services for localization (code file
WebApplicationSample/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddLocalization(options => options.ResourcesPath =
"CustomResources");
}
The AddLocalization method registers services for the interfaces
IStringLocalizerFactory and IStringLocalizer . With the registration
code, the type ResourceManagerStringLocalizerFactory is registered as
a singleton, and StringLocalizer is registered with transient lifetime.
The class ResourceManagerStringLocalizerFactory is a factory for


ResourceManagerStringLocalizer . This class in turn makes use of
ResourceManager class shown earlier for retrieving strings from
the
resource files.
Injecting Localization Services
After localization is added to the service collection, you can request
localization in the Configure method of the Startup class. The
UseRequestLocalization method defines an overload where you can
pass RequestLocalizationOptions . The RequestLocalizationOptions
enables you to customize what cultures should be supported and to set
the default culture. Here, the DefaultRequestCulture is set to en-US .
The class RequestCulture is just a small wrapper around the culture for
formatting——which is accessible via the Culture property——and the
culture for using the resources ( UICulture property). The sample code
accepts en-US, en, de-AT, and de cultures for SupportedCultures and
SupportedUICultures (code file WebApplicationSample/Startup.cs ):
public void Configure(IApplicationBuilder app,
IHostingEnvironment env,
IStringLocalizer<Startup> sr)
{
//...
var supportedCultures = new[]
{
new CultureInfo("en-US"),
new CultureInfo("en"),
new CultureInfo("de-AT"),
new CultureInfo("de")
};
var options = new RequestLocalizationOptions
{
DefaultRequestCulture = new RequestCulture(new
CultureInfo("en-US")),
SupportedCultures = supportedCultures,
SupportedUICultures = supportedCultures
};
app.UseRequestLocalization(options);
//...
}
With the RequestLocalizationOptions settings, the property


RequestCultureProviders is also set. By default, three
configured: QueryStringRequestCultureProvider ,
CookieRequestCultureProvider , and
AcceptLanguageHeaderRequestCultureProvider .
providers are
Culture Providers
Let’s get into more details on these culture providers. The
QueryStringRequestCultureProvider uses the query string to retrieve
the culture. By default, the query parameters culture and ui-culture
are used with this provider, as shown with this URL:
http://localhost:5000/?culture=de&ui-culture=en-US
http://localhost:5000/?culture=de&ui-culture=en-US
You can also change the query parameters by setting the
QueryStringKey and UIQueryStringKey properties of the
QueryStringRequestCultureProvider .
The CookieRequestCultureProvider defines the cookie named
ASPNET_CULTURE (which can be set using the CookieName property). The
values from this cookie are retrieved to set the culture. To create a
cookie and send it to the client, you can use the static method
MakeCookieValue to create a cookie from a RequestCulture and send it
to the client. The CookieRequestCultureProvider uses the static method
ParseCookieValue to get a RequestCulture .
With the third option for culture settings, you can use the HTTP
header information that is sent by the browser. The HTTP header that
is sent looks like this:
Accept-Language: en-us, de-at;q=0.8, it;q=0.7
The AcceptLanguageHeaderRequestCultureProvider uses this
information to set the culture. You use up to three language values in
the order as defined by the quality value to find a first match with the
supported cultures.
The following code snippet now uses the request culture to generate
HTML output. First, you access the requested culture using the
IRequestCultureFeature contract. The RequestCultureFeature that


implements the interface IRequestCultureFeature uses the first culture
provider that matches the culture setting. If a URL defines a query
string that matches the culture parameter, the
QueryStringRequestCultureProvider is used to return the requested
culture. If the URL does not match, but a cookie with the name
ASPNET_CULTURE is received, the CookieRequestCultureProvider is used,
and otherwise the AcceptLanguageRequestCultureProvider . The
resulting culture that is used by the user is written to the response
stream using properties of the returned RequestCulture . Then, today’s
date is written to the stream using the current culture. The variable of
type IStringLocalizer used here needs some more examination that is
discussed next (code file WebApplicationSample/Startup.cs ):
public void Configure(IApplicationBuilder app,
IHostingEnvironment env,
IStringLocalizer<Startup> sr)
{
//...
app.Run(async context =>
{
IRequestCultureFeature requestCultureFeature =
context.Features.Get<IRequestCultureFeature>();
RequestCulture requestCulture =
requestCultureFeature.RequestCulture;
var today = DateTime.Today;
await context.Response.WriteAsync("<h1>Sample
Localization</h1>");
await context.Response.WriteAsync(
$"<div>{requestCulture.Culture}
{requestCulture.UICulture}</div>");
await context.Response.WriteAsync($"<div>{today:D}
</div>");
//...
});
}
Using Resources from ASP.NET Core
Resource files, as you’ve seen in the Resources section in this chapter,
can be used with ASP.NET Core. The sample project adds the
CustomResources folder and the file Startup.resx within. Localized
versions for the resources are offered with Startup.de.resx and


Startup.de-AT.resx .
The folder name where the resources are found is defined with the
options when injecting the localization service (code file
WebApplicationSample/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddLocalization(
options => options.ResourcesPath = "CustomResources");
}
With dependency injection, IStringLocalizer<Startup> is injected as a
parameter of the Configure method. The generic type Startup
parameter is used to find a resource file with the same name in the
resources directory; this matches with Startup.resx .
public void Configure(IApplicationBuilder app,
IHostingEnvironment env,
IStringLocalizer<Startup> sr)
{
//...
}
**NOTE**
Read more about dependency injection in Chapter 20,
“Dependency Injection.”
The following code snippet makes use of the sr variable of type
IStringLocalizer<Startup> to access a resource named message1 using
an indexer and with the GetString method. The resource message2 uses
string format placeholders, which are injected with an overload of the
GetString method where any number of parameters can be passed to:
public void Configure(IApplicationBuilder app,
IHostingEnvironment env,
IStringLocalizer<Startup> sr</b>)
{
//...
app.Run(async context =>


{
//...
await context.Response.WriteAsync(
$"<div>{HtmlEncoder.Default.Encode(sr["message1"])}
</div>");
await context.Response.WriteAsync(
$"<div>
{HtmlEncoder.Default.Encode(sr.GetString("message1")})
</div>");
await context.Response.WriteAsync(
$"<div>
{HtmlEncoder.Default.Encode(sr.GetString("message2",
requestCulture.Culture, requestCulture.UICulture))}
</div>");
});
}
**NOTE**
With the sample code, the HtmlEncoder is used to change the output
from the resources before passing it to the WriteAsync method of
the HttpResponse . With this encoder, the resource values are
converted to the HTML format to correctly display special
characters such as the German ü and ß . With HTML encoding,
these characters are translated to the HTML format &#xFC; and
&#xDF; .
The resource for message1 is a simple string; the resource for message2
is defined with string format placeholders:
Using culture {0} and UI culture {1}
**NOTE**
Using formatted strings in resources, the new syntax with
interpolated strings cannot be used in this case. The variables or
expressions used with interpolated strings in the placeholders are
not available from resources.


Running the web application results in the view shown in Figure 27-7.
FIGURE 27-7
Adding ?culture=de-AT to the URL request (which uses the
QueryStringRequestCultureProvider ), you can see output as shown in
Figure 27-8. When you pass cultures that aren’t supported with the
URL request, you can see an output of the default culture.
FIGURE 27-8


Localizing with Controllers and Views
Using ASP.NET Core MVC, there’s special support for localization.
You can create specific resource files for controllers and views, you can
add annotations to model data that are used to retrieve values from
resources.
**NOTE**
ASP.NET Core MVC is discussed in detail in Chapter 31, “ASP.NET
Core MVC.” Annotations are discussed in Chapter 16, “Reflection,
Metadata, and Dynamic Programming.”
The ASP.NET Core Web Application named ASPNETCoreMVCSample used
in this section is based on the Web Application (Model View
Controller) template, and it uses the following dependency and
namespaces:
Dependency
Microsoft.AspNetCore.All
Namespaces
Microsoft.AspNetCore
Microsoft.AspNetCore.Builder
Microsoft.AspNetCore.Hosting
Microsoft.AspNetCore.Localization
Microsoft.AspNetCore.Mvc.Localization
Microsoft.AspNetCore.Mvc.Razor
Microsoft.Extensions.Configuration
Microsoft.Extensions.DependencyInjection
Microsoft.Extensions.Localization


System
System.ComponentModel
System.Diagnostics
System.Globalization
Let’s start with creating resources. The resources are now stored in the
folder Resources . The folder name is specified with the options of the
AddLocalization helper method (code file
ASPNETCoreMVCSample/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddLocalization(options => options.ResourcesPath =
"Resources");
//...
}
You can put resources for controllers, views, and models into
subfolders, or you can use a dot notation with the filename. For
example, you can put resources for the HomeController into the
subdirectory Resources\Controllers ——for example, the resource file
named HomeController.resx with the default language, as well as
language specific resource files—— such as HomeController.de.resx .
Instead of using the directory structure, you can use the dot notation
for the filename. Here you store the resource file directly within the
Resources folder. With this convention, the resource file for the
HomeController needs to be named Controllers.HomeController.resx .
For the view named Hello that is activated from the HomeController ,
you can use directory notation for the resource file Hello.resx to put it
into the directory structure Resources/Views/Home . Using dot notation,
the resource file Views.Home.Hello.resx needs to be saved in the folder
Resources .
The version of resource files that is used is specified with the
AddViewLocalization method, an extension method for the IMvcBuilder
interface. An object implementing this interface is returned from the
AddMvc method, thus AddViewLocalization can be invoked using fluent


API syntax. When you pass the option
LanguageViewLocationExpanderFormat.SubFolder ,
it defines that the
subfolder resources are used. The other option would be
LanguageViewLocationExpanderFormat.Suffix . In the following code
snippet, the extension method AddDataAnnotationsLocalization also is
invoked to enable localization with data annotations (code file
ASPNETCoreMVCSample/Startup.cs ):
public void ConfigureServices(IServiceCollection services)
{
services.AddLocalization(options => options.ResourcesPath =
"Resources");
services.AddMvc()
.AddViewLocalization(LanguageViewLocationExpanderFormat.SubFolder)
.AddDataAnnotationsLocalization();
}
With the HomeController , the IStringLocalizer can be injected and
used like what you’ve seen with the Configure method of the
WebSampleApp sample where an IStringLocalizer was injected as well.
In the following code snippet, the IStringLocalizer<HomeController>
is injected in the constructor of the HomeController , and used with the
Hello action method (code file
ASPNETCoreMVCSample/Controllers/HomeController.cs ):
private readonly IStringLocalizer<HomeController> _localizer;
public HomeController(IStringLocalizer<HomeController>
localizer)
{
_localizer = localizer;
}
public IActionResult Hello()
{
ViewBag.Message1 = _localizer.GetString("Message1");
return View();
}
In the view, the Message1 passed from the controller is directly
accessed (code file ASPNETCoreMVCSample/Views/Home/Hello.cshtml ):
<h3>@ViewBag.Message1</h3>


To access a resource directly from the resource in the view, the
IViewLocalizer can be injected using the @inject declaration. Here, a
local variable Localizer is defined that is then used to access the
resource named Message2 ; the resource just needs to be saved in the
resource file Resources/Views/Home/Hello.resx (code file
ASPNETCoreMVCSample/Views/Home/Hello.cshtml ):
@using Microsoft.AspNetCore.Mvc.Localization
@inject IViewLocalizer Localizer
@{
ViewData["Title"] = "Hello";
}
<h2>Hello</h2>
<h3>@ViewBag.Message1</h3>
<h3>@Localizer["Message2"]</h3>
Running the application and accessing the link /Home/Hello , resources
are retrieved both from the controller and the view as shown in Figure
27-9.


FIGURE 27-9
Another way to retrieve resource values with ASP.NET Core MVC is
via applying annotations. To see the annotations in action, the Book
type is defined in the Models directory. This type has DisplayName
attributes added to the properties Booktitle and Publisher (code file
ASPNETCoreMVCSample/Models/Book.cs ):
public class Book
{
[DisplayName("Booktitle")]
public string Booktitle { get; set; }
[DisplayName("Publisher")]
public string Publisher { get; set; }
}
**NOTE**
Don’t forget to enable annotations for localization by invoking the
method AddDataAnnotationsLocalization in the Startup class.
The resource file Book.resx is now added to the directory
Resources/Models (resource file
ASPNETCoreMVCSample/Resources/Models/Book.resx ):
<!-- ... -->
<data name="Publisher" xml:space="preserve">
<value>Publisher</value>
</data>
<data name="Booktitle" xml:space="preserve">
<value>Title</value>
</data>
<!-- ... -->
A German language representation is added as well (resource file
ASPNETCoreMVCSample/Resources/Models/Book.de.resx ):
<!-- ... -->
<data name="Publisher" xml:space="preserve">
<value>Verlag</value>
</data>


<data name="Booktitle" xml:space="preserve">
<value>Titel</value>
</data>
<!-- ... -->
The Book action method from the HomeController passes a Book model
to the view (code file
ASPNETCoreMVCSample/Controllers/HomeController.cs ):
public IActionResult Book()
{
var b = new Book
{
Booktitle = "Professional C# 7 and .NET Core 2",
Publisher = "Wrox Press"
};
return View(b);
}
To display the book, the HTML Helper method EditorForModel is used
to display all the properties of the model with input fields (code file
ASPNETCoreMVCSample/Views/Home/Book.cshtml ):
@{
ViewData["Title"] = "Book";
}
<h2>Book</h2>
@Html.EditorForModel()
Figure 27-10 shows the running application accessing Home/Book
with the German culture.


FIGURE 27-10
**NOTE**
For more information about controllers, views, and HTML
Helper, read Chapter 31.
LOCALIZATION WITH THE UNIVERSAL WINDOWS
PLATFORM
Localization with the Universal Windows Platform (UWP) is based on
the concepts you’ve learned so far, but it brings some fresh ideas, as
described in this section. For the best experience, you need to install
the Multilingual App Toolkit that is available via Visual Studio
Extensions and Updates.
The concepts of cultures, regions, and resources are the same, but
because Windows apps can be written with C# and XAML, C++ and
XAML, and JavaScript and HTML, these concepts need to be available
with all languages. Only Windows Runtime is available with all these
programming languages and UWP apps. Therefore, new namespaces


for globalization and resources are available with Windows Runtime:
Windows.Globalization and Windows.ApplicationModel.Resources .
With the globalization namespaces you can find Calendar ,
GeographicRegion (this can be compared to the .NET RegionInfo ), and
Language classes. With sub-namespaces, there are also classes for
number and date formatting that vary according to the language. With
C# and Windows apps, you can still use the .NET classes for cultures
and regions.
Let’s get into an example so you can see localization with a Universal
Windows app in action. Create a small application using the Blank
App (Universal Windows) Visual Studio project template. Add two
TextBlock controls and one TextBox control to the page.
Within the OnNavigatedTo method of the code file you can assign a date
with the current format to the Text property of the text1 control. You
can use the DateTime structure in the same way you’ve done it with the
console application earlier in this chapter (code file
UWPLocalization/MainPage.xaml.cs ):
protected override void OnNavigatedTo(NavigationEventArgs e)
{
base.OnNavigatedTo(e);
text1.Text = DateTime.Today.ToString("D");
//...
}
Using Resources with UWP
With UWP, you can create resource files with the file extension resw
instead of resx . Behind the scenes, the same XML format is used with
resw files, and you can use the same Visual Studio resource editor to
create and modify these files. The following example uses the structure
shown in Figure 27-11. The subfolder Messages contains a subdirectory,
en-us , in which two resource files Errors.resw and Messages.resw are
created. In the folder Strings\en-us , the resource file Resources.resw
is created.


FIGURE 27-11
The Messages.resw file contains some English text resources, Hello
with a value of Hello World , and resources named GoodDay ,
GoodEvening , and GoodMorning . The file Resources.resw contains the
resources Text3.Text and Text3.Width , with the values "This is a
sample message for Text 4" and a value of "300" .
With the code, you can access resources with the help of the
ResourceLoader class from the namespace
Windows.ApplicationModel.Resources . Here you use the string
"Messages" with the method GetForCurrentView . Thus, you’re using the
resource file Messages.resw . Invoking the method GetString retrieves
the resource with the key "Hello" (code file
UWPLocalization/MainPage.xaml.cs ):
protected override void OnNavigatedTo(NavigationEventArgs e)
{
//...
var resourceLoader =
ResourceLoader.GetForCurrentView("Messages");


text2.Text = resourceLoader.GetString("Hello");
}
With UWP Windows apps it is also easy to use the resources directly
from XAML code. With the following TextBox , the x:Uid attribute is
assigned the value Text3 . This way, a resource named Text3 with
extensions is searched for in the resource file Resources.resw . This
resource file contains value for the keys Text3.Text and Text3.Width .
The values are retrieved, and both the Text and Width properties are
set (code file UWPLocalization/MainPage.xaml ):
<TextBox x:Uid="FileName_Text3" HorizontalAlignment="Left"
Margin="40"
TextWrapping="Wrap" Text="TextBox"
VerticalAlignment="Top"/>
When you run the application at this stage, you can see the English
text accessed from the resource files as shown in Figure 27-12.


FIGURE 27-12
Localization with the Multilingual App Toolkit
To localize UWP apps you can download the previously mentioned
Multilingual App Toolkit. This toolkit integrates with Visual Studio
2017. After installing the toolkit, you can enable it within Visual Studio
using the menu Tools ➪ Multilingual App Toolkit ➪ Enable Selection.
This adds a build command to the project file and adds one more
option to the context menu in Solution Explorer. Open the context
menu in Solution Explorer and select Multilingual App Toolkit ➪ Add
Translation Languages to invoke the dialog shown in Figure 27-13,
where you can choose which languages should be translated. The
sample uses Pseudo Language, French, German, and Spanish. For
these languages, a Microsoft Translator is available. This tool now
creates a MultilingualResources subdirectory that contains .xlf files
for the selected languages. The .xlf files are defined with the XLIFF
(XML Localisation Interchange File Format) standard. This is a
standard of the Open Architecture for XML Authoring and
Localization (OAXAL) reference architecture.


FIGURE 27-13
**NOTE**
The Multilingual App Toolkit can also be installed from
http://aka.ms/matinstallv4 without using Visual Studio.
Download the Multilingual App Toolkit.
The next time you start the build process for the project, the XLIFF
files are filled with content from all the resources. When you select the
XLIFF files in Solution Explorer, you can send it to translation. To do
so, open the context menu in Solution Explorer while selecting the
.xlf files, and select Multilingual App Toolkit ➪ Export Translations,
which opens the dialog shown in Figure 27-14. With this dialog you


can configure the information that should be sent, and you can send
an email with the XLIFF files attached.
FIGURE 27-14
For translation, you can also use Microsoft’s translation service. Select
the .xlf files in Visual Studio Solution Explorer, and after opening the
context menu, select Multilingual App Toolkit ➪ Generate Machine
Translations. To make this work with the version used while writing
this book, you need to create an Microsoft Azure account and add the
Translator Speech API of Microsoft Cognitive Services. This service is
used by the translation services of the Multilingual App Toolkit. A free
pricing tier exists that allows up to 2,000,000 characters to be


translated each month.
When you open the .xlf files, the Multilingual Editor (see Figure 27-
15) is opened. With this tool you can verify the automatic translations
and make necessary changes.
FIGURE 27-15
**WARNING**
Don’t use the machine translation without a manual review. The
tool shows a status for every resource that is translated. After the
automatic translation, the status is set to Needs Review. You have
probably seen applications with machine translations that are
incorrect——and sometimes really funny.
SUMMARY
This chapter demonstrated how to globalize and localize .NET


applications. For the globalization of applications, you learned about
using the namespace System.Globalization to format culture-
dependent numbers and dates. Furthermore, you learned that sorting
strings by default varies according to the culture, and you looked at
using the invariant culture for a culture-independent sort.
Localizing an application is accomplished by using resources, which
you can pack into files or satellite assemblies. The classes used with
localization are in the namespace System.Resources .
You also learned how to localize ASP.NET Core, used special features
for ASP.NET Core MVC, and localized apps using the Universal
Windows Platform.
The next chapter provides information about testing. You learn how to
create unit tests, as well as UI tests for Windows and web applications.