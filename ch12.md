

Language Integrated Query
WHAT’S IN THIS CHAPTER?
Traditional queries across objects using List
Extension methods
LINQ query operators
Parallel LINQ
Expression trees
WROX.COM CODE DOWNLOADS
FOR THIS CHAPTER
The Wrox.com code downloads for this chapter are found at
www.wrox.com on the Download Code tab. The source code is also
available at
https://github.com/ProfessionalCSharp/ProfessionalCSharp7 in
the directory LINQ .
The code for this chapter is divided into the following major
examples:
LINQ Intro
Enumerable Sample
Parallel LINQ
Expression Trees


LINQ OVERVIEW
LINQ (Language Integrated Query) integrates query syntax inside the
C# programming language, making it possible to access different data
sources with the same syntax. LINQ accomplishes this by offering an
abstraction layer.
This chapter describes the core principles of LINQ and the language
extensions for C# that make the C# LINQ Query possible.
NOTE
For details about using LINQ across the database, you should
read Chapter 26, “Entity Framework Core.” For information
about querying XML data, read Bonus Chapter 2, “XML and
JSON,” (which you can find online) after reading this chapter.
This chapter starts with a simple LINQ query before diving into the
full potential of LINQ. The C# language offers integrated query
language that is converted to method calls. This section shows you
how the conversion looks so you can use all the possibilities of LINQ.
Lists and Entities
The LINQ queries in this chapter are performed on a collection
containing Formula-1 champions from 1950 to 2016. This data needs
to be prepared with classes and lists within a .NET Standard library.
This library makes use of these namespaces:
System
System.Collections.Generic
For the entities, the type Racer is defined. Racer defines several
properties and an overloaded ToString method to display a racer in a
string format. This class implements the interface IFormattable to
support different variants of format strings, and the interface
IComparable<Racer> , which can be used to sort a list of racers based on


the LastName . For more advanced queries, the class Racer contains not
only single-value properties such as FirstName , LastName , Wins Country ,
and Starts , but also properties that contain a collection, such as Cars
and Years . The Years property lists all the years of the championship
title. Some racers have won more than one title. The Cars property is
used to list all the cars used by the driver during the title years (code
file DataLib/Racer.cs ):
public class Racer: IComparable<Racer>, IFormattable
{
public Racer(string firstName, string lastName, string
country,
int starts, int wins)
: this(firstName, lastName, country, starts, wins, null,
null) { }
public Racer(string firstName, string lastName, string
country,
int starts, int wins, IEnumerable<int> years,
IEnumerable<string> cars)
{
FirstName = firstName;
LastName = lastName;
Country = country;
Starts = starts;
Wins = wins;
Years = years != null ? new List<int>(years) : new
List<int>();
Cars = cars != null ? new List<string>(cars) : new
List<string>();
}
public
public
public
public
public
public
public
string FirstName { get; }
string LastName { get; }
int Wins { get; }
string Country { get; }
int Starts { get; }
IEnumerable<string> Cars { get; }
IEnumerable<int> Years { get; }
public override string ToString() => $"{FirstName}
{LastName}";
public int CompareTo(Racer other) =>
LastName.Compare(other?.LastName);


public string ToString(string format) => ToString(format,
null);
public string ToString(string format, IFormatProvider
formatProvider)
{
switch (format)
{
case null:
case "N":
return ToString();
case "F":
return FirstName;
case "L":
return LastName;
case "C":
return Country;
case "S":
return Starts.ToString();
case "W":
return Wins.ToString();
case "A":
return $"{FirstName} {LastName}, {Country}; starts:
{Starts}, wins: {Wins}";
default:
throw new FormatException($"Format {format} not
supported");
}
}
}
A second entity class is Team . This class just contains the name and an
array of years for constructor championships. Like a driver
championship, there’s a constructor championship for the best team of
a year (code file DataLib/Team.cs ):
public class Team
{
public Team(string name, params int[] years)
{
Name = name;
Years = years != null ? new List<int>(years) : new
List<int>();
}
public string Name { get; }
public IEnumerable<int> Years { get; }
}


The class Formula1 returns a list of racers in the method GetChampions .
The list is filled with all Formula-1 champions from the years 1950 to
2016 (code file DataLib/Formula1.cs ):
public static class Formula1
{
private static List<Racer> s_racers;
public static IList<Racer> GetChampions() => s_racers ??
(s_racers = InitalizeRacers());
private static List<Racer> InitializeRacers =>
new List<Racer>
{
new Racer("Nino", "Farina", "Italy", 33, 5, new int[] {
1950 },
new string[] { "Alfa Romeo" }),
new Racer("Alberto", "Ascari", "Italy", 32, 10, new
int[] { 1952, 1953 },
new string[] { "Ferrari" }),
new Racer("Juan Manuel", "Fangio", "Argentina", 51, 24,
new int[] { 1951, 1954, 1955, 1956, 1957 },
new string[] { "Alfa Romeo", "Maserati", "Mercedes",
"Ferrari" }),
new Racer("Mike", "Hawthorn", "UK", 45, 3, new int[] {
1958 },
new string[] { "Ferrari" }),
new Racer("Phil", "Hill", "USA", 48, 3, new int[] {
1961 },
new string[] { "Ferrari" }),
new Racer("John", "Surtees", "UK", 111, 6, new int[] {
1964 },
new string[] { "Ferrari" }),
new Racer("Jim", "Clark", "UK", 72, 25, new int[] {
1963, 1965 },
new string[] { "Lotus" }),
new Racer("Jack", "Brabham", "Australia", 125, 14,
new int[] { 1959, 1960, 1966 }, new string[] {
"Cooper", "Brabham" }),
new Racer("Denny", "Hulme", "New Zealand", 112, 8, new
int[] { 1967 },
new string[] { "Brabham" }),
new Racer("Graham", "Hill", "UK", 176, 14, new int[] {
1962, 1968 },
new string[] { "BRM", "Lotus" }),
new Racer("Jochen", "Rindt", "Austria", 60, 6, new
int[] { 1970 },
new string[] { "Lotus" }),


new Racer("Jackie", "Stewart", "UK", 99, 27,
new int[] { 1969, 1971, 1973 }, new string[] {
"Matra", "Tyrrell" }),
//...
}
//...
}
Where queries are done across multiple lists, the
GetConstructorChampions method that follows returns the list of all
constructor championships (these championships have been around
since 1958):
private static List<Team> s_teams;
public static IList<Team> GetContructorChampions()
{
if (s_teams == null)
{
s_teams = new List<Team>()
{
new Team("Vanwall", 1958),
new Team("Cooper", 1959, 1960),
new Team("Ferrari", 1961, 1964, 1975, 1976, 1977, 1979,
1982, 1983, 1999,
2000, 2001, 2002, 2003, 2004, 2007, 2008),
new Team("BRM", 1962),
new Team("Lotus", 1963, 1965, 1968, 1970, 1972, 1973,
1978),
new Team("Brabham", 1966, 1967),
new Team("Matra", 1969),
new Team("Tyrrell", 1971),
new Team("McLaren", 1974, 1984, 1985, 1988, 1989, 1990,
1991, 1998),
new Team("Williams", 1980, 1981, 1986, 1987, 1992,
1993, 1994, 1996,
1997),
new Team("Benetton", 1995),
new Team("Renault", 2005, 2006),
new Team("Brawn GP", 2009),
new Team("Red Bull Racing", 2010, 2011, 2012, 1013),
new Team("Mercedes", 2014, 2015, 2016, 2017)
};
}
return s_teams;
}


LINQ Query
The sample application demonstrating LINQ is a console application
using these namespaces:
System
System.Collections.Generic
System.Linq
Using these prepared lists and objects from the previously created
library, you can do a LINQ query—for example, a query to get all world
champions from Brazil sorted by the highest number of wins. To
accomplish this, you could use methods of the List<T> class—for
example, the FindAll and Sort methods. However, using LINQ there’s
a simpler syntax (code file LINQIntro/Program.cs ):
static void LINQQuery()
{
var query = from r in Formula1.GetChampions()
where r.Country == "Brazil"
orderby r.Wins descending
select r;
foreach (Racer r in query)
{
Console.WriteLine($"{r:A}");
}
}
The result of this query shows world champions from Brazil ordered
by number of wins:
Ayrton Senna, Brazil; starts: 161, wins: 41
Nelson Piquet, Brazil; starts: 204, wins: 23
Emerson Fittipaldi, Brazil; starts: 143, wins: 14
The expression
from r in Formula1.GetChampions()
where r.Country == "Brazil"
orderby r.Wins descending
select r;
is a LINQ query. The clauses from , where , orderby , descending , and


select
are predefined keywords in this query.
The query expression must begin with a from clause and end with a
select or group clause. In between you can optionally use where ,
orderby , join , let , and additional from clauses.
NOTE
The variable query just has the LINQ query assigned to it. The
query is not performed by this assignment, but rather as soon as
the query is accessed using the foreach loop. This is discussed in
more detail later in the section “Deferred Query Execution.”
Extension Methods
The compiler converts the LINQ query to invoke method calls instead
of the LINQ query. LINQ offers various extension methods for the
IEnumerable<T> interface, so you can use the LINQ query across any
collection that implements this interface. An extension method is
defined as a static method whose first parameter defines the type it
extends, and it is declared in a static class.
Extension methods make it possible to write a method to a class that
doesn’t already offer the method at first. You can also add a method to
any class that implements a specific interface, so multiple classes can
make use of the same implementation.
For example, wouldn't you like to have a Foo method with the String
class? The String class is sealed, so it is not possible to inherit from
this class; but you can create an extension method, as shown in the
following code:
public static class StringExtension
{
public static void Foo(this string s)
{
Console.WriteLine($"Foo invoked for {s}");
}
}


The Foo method extends the string class, as is defined with the first
parameter. For differentiating extension methods from normal static
methods, the extension method also requires the this keyword with
the first parameter.
Indeed, it is now possible to use the Foo method with the string type:
string s = "Hello";
s.Foo();
The result shows Foo invoked for Hello in the console, because Hello is
the string passed to the Foo method.
This might appear to be breaking object-oriented rules because a new
method is defined for a type without changing the type or deriving
from it. However, this is not the case. The extension method cannot
access private members of the type it extends. Calling an extension
method is just a new syntax for invoking a static method. With the
string you can get the same result by calling the method Foo this way:
string s = "Hello";
StringExtension.Foo(s);
To invoke the static method, write the class name followed by the
method name. Extension methods are a different way to invoke static
methods. You don’t have to supply the name of the class where the
static method is defined. Instead, because of the parameter type the
static method is selected by the compiler. You just import the
namespace that contains the class to get the Foo extension method in
the scope of the String class.
One of the classes that define LINQ extension methods is Enumerable
in the namespace System.Linq . You just import the namespace to open
the scope of the extension methods of this class. A sample
implementation of the Where extension method is shown in the
following code. The first parameter of the Where method that includes
the this keyword is of type IEnumerable<T> . This enables the Where
method to be used with every type that implements IEnumerable<T> . A
few examples of types that implement this interface are arrays and
List<T> . The second parameter is a Func<T, bool> delegate that
references a method that returns a Boolean value and requires a


parameter of type T . This predicate is invoked within the
implementation to examine whether the item from the IEnumerable<T>
source should be added into the destination collection. If the method
is referenced by the delegate, the yield return statement returns the
item from the source to the destination:
public static IEnumerable<TSource> Where<TSource>(
this IEnumerable<TSource> source,
Func<TSource, bool> predicate)
{
foreach (TSource item in source)
{
if (predicate(item))
yield return item;
}
}
Because Where is implemented as a generic method, it works with any
type that is contained in a collection. Any collection implementing
IEnumerable<T> is supported.
NOTE
The extension methods here are defined in the namespace
System.Linq in the assembly System.Core .
Now it’s possible to use the extension methods Where ,
OrderByDescending , and Select from the class Enumerable . Because
each of these methods returns IEnumerable<TSource> , it is possible to
invoke one method after the other by using the previous result. With
the arguments of the extension methods, anonymous methods that
define the implementation for the delegate parameters are used (code
file LINQIntro/Program.cs ):
static void ExtensionMethods()
{
var champions = new List<Racer>(Formula1.GetChampions());
IEnumerable<Racer> brazilChampions =
champions.Where(r =< r.Country == "Brazil")
.OrderByDescending(r =< r.Wins)


.Select(r =< r);
foreach (Racer r in brazilChampions)
{
Console.WriteLine($"{r:A}");
}
}
Deferred Query Execution
During runtime, the query expression does not run immediately as it is
defined. The query runs only when the items are iterated.
Let’s have a look once more at the extension method Where . This
extension method makes use of the yield return statement to return
the elements where the predicate is true. Because the yield return
statement is used, the compiler creates an enumerator and returns the
items as soon as they are accessed from the enumeration:
public static IEnumerable<T> Where<T>(this IEnumerable<T>
source,
Func<T, bool> predicate)
{
foreach (T item in source)
{
if (predicate(item))
{
yield return item;
}
}
}
}
This has a very interesting and important effect. In the following
example a collection of string elements is created and filled with first
names. Next, a query is defined to get all names from the collection
whose first letter is J . The collection should also be sorted. The
iteration does not happen when the query is defined. Instead, the
iteration happens with the foreach statement, where all items are
iterated. Only one element of the collection fulfills the requirements of
the where expression by starting with the letter J: Juan . After the
iteration is done and Juan is written to the console, four new names are
added to the collection. Then the iteration is done again (code file


LINQIntro/Program.cs ):
static void DeferredQuery()
{
var names = new List<string> { "Nino", "Alberto", "Juan",
"Mike", "Phil" };
var namesWithJ = from n in names
where n.StartsWith("J")
orderby n
select n;
Console.WriteLine("First iteration");
foreach (string name in namesWithJ)
{
Console.WriteLine(name);
}
Console.WriteLine();
names.Add("John");
names.Add("Jim");
names.Add("Jack");
names.Add("Denny");
Console.WriteLine("Second iteration");
foreach (string name in namesWithJ)
{
Console.WriteLine(name);
}
Because the iteration does not happen when the query is defined, but
does happen with every foreach , changes can be seen, as the output
from the application demonstrates:
First iteration
Juan
Second iteration
Jack
Jim
John
Juan
Of course, you also must be aware that the extension methods are
invoked every time the query is used within an iteration. Most of the
time this is very practical, because you can detect changes in the
source data. However, sometimes this is impractical. You can change


this behavior by invoking the extension methods ToArray , ToList , and
the like. In the following example, you can see that ToList iterates
through the collection immediately and returns a collection
implementing IList<string> . The returned list is then iterated
through twice; in between iterations, the data source gets new names:
var names = new List<string> { "Nino", "Alberto", "Juan",
"Mike", "Phil" };
var namesWithJ = (from n in names
where n.StartsWith("J")
orderby n
select n).ToList();
Console.WriteLine("First iteration");
foreach (string name in namesWithJ)
{
Console.WriteLine(name);
}
Console.WriteLine();
names.Add("John");
names.Add("Jim");
names.Add("Jack");
names.Add("Denny");
Console.WriteLine("Second iteration");
foreach (string name in namesWithJ)
{
Console.WriteLine(name);
}
The result indicates that in between the iterations the output stays the
same although the collection values have changed:
First iteration
Juan
Second iteration
Juan
STANDARD QUERY OPERATORS
Where , OrderByDescending ,
and Select are only a few of the query
operators defined by LINQ. The LINQ query defines a declarative
syntax for the most common operators. There are many more query
operators available with the Enumerable class.


The following table lists the standard query operators defined by the
Enumerable class.
STANDARD
QUERY
OPERATORS
DESCRIPTION
Filtering operators define a restriction to the
elements returned. With the Where query
operator you can use a predicate; for example, a
Lambda expression that returns a bool.
OfType<TResult> filters the elements based on the
type and returns only the elements of the type
TResult .
Select
Projection operators are used to transform an
SelectMany
object into a new object of a different type.
Select and SelectMany define a projection to
select values of the result based on a selector
function.
OrderBy
Sorting operators change the order of elements
ThenBy
returned. OrderBy sorts values in ascending
OrderByDescending
order; OrderByDescending sorts values in
ThenByDescending
descending order. ThenBy and ThenByDescending
Reverse
operators are used for a secondary sort if the first
sort gives similar results. Reverse reverses the
elements in the collection.
Join
Join operators are used to combine collections
GroupJoin
that might not be directly related to each other.
With the Join operator a join of two collections
based on key selector functions can be done. This
is like the JOIN you know from SQL. The
GroupJoin operator joins two collections and
groups the results.
GroupBy
Grouping operators put the data into groups.
ToLookup
The GroupBy operator groups elements with a
common key. ToLookup groups the elements by
creating a one-to-many dictionary.
Where
OfType<TResult>


Quantifier operators return a Boolean value if
elements of the sequence satisfy a specific
condition. Any , All , and Contains are quantifier
operators. Any determines whether any element
in the collection satisfies a predicate function;
All determines whether all elements in the
collection satisfy a predicate. Contains checks
whether a specific element is in the collection.
Take
Partitioning operators return a subset of the
Skip
collection. Take , Skip , TakeWhile , and SkipWhile
TakeWhile
are partitioning operators. With these, you get a
SkipWhile
partial result. With Take , you have to specify the
number of elements to take from the collection;
Skip ignores the specified number of elements
and takes the rest. TakeWhile takes the elements
as long as a condition is true. SkipWhile skips the
elements if the condition is true.
Distinct
Set operators return a collection set. Distinct
Union
removes duplicates from a collection. With the
Intersect
exception of Distinct , the other set operators
Except
require two collections. Union returns unique
Zip
elements that appear in either of the two
collections. Intersect returns elements that
appear in both collections. Except returns
elements that appear in just one collection. Zip
combines two collections into one.
First
Element operators return just one element.
FirstOrDefault
First returns the first element that satisfies a
Last
condition. FirstOrDefault is like First , but it
LastOrDefault
returns a default value of the type if the element
ElementAt
ElementAtOrDefault is not found. Last returns the last element that
Single
satisfies a condition. With ElementAt , you specify
SingleOrDefault
the position of the element to return. Single
returns only the one element that satisfies a
condition. If more than one element satisfies the
condition, an exception is thrown. All the
Any
All
Contains


methods are like the methods that
start with the same prefix, but they return the
default value of the type if the element is not
found.
Aggregate operators compute a single value
from a collection. With aggregate operators, you
can get the sum of all values, the number of all
elements, the element with the lowest or highest
value, an average number, and so on.
Conversion operators convert the collection to
an array: IEnumerable , IList , IDictionary , and so
on. The Cast method casts every item of the
collection to the generic argument type.
XXOrDefault
Count
Sum
Min
Max
Average
Aggregate
ToArray
AsEnumerable
ToList
ToDictionary
Cast<TResult>
Empty
Range
Repeat
Generation operators return a new sequence.
The collection is empty using the Empty operator;
Range returns a sequence of numbers, and Repeat
returns a collection with one repeated value.
The following sections provide examples demonstrating how to use
these operators.
Filtering
This section looks at some examples for a query. The sample
application is a console application making use of these namespaces:
System
System.Collections.Generic
System.Linq
This sample application available with the code download offers
passing command-line arguments for every different feature shown. In
the Debug section in the Properties page, you can configure the
command-line arguments as needed to run the different sections of
the application. Using the command line, you can invoke the
commands using the .NET Core command-line utility in this way:
dotnet run -- -f


which passes the argument -f to the application.
With the where clause, you can combine multiple expressions—for
example, get only the racers from Brazil and Austria who won more
than 15 races. The result type of the expression passed to the where
clause just needs to be of type bool (code file
EnumerableSample/FilteringSamples.cs ):
static void Filtering()
{
var racers = from r in Formula1.GetChampions()
where r.Wins > 15 &&
(r.Country == "Brazil" || r.Country ==
"Austria")
select r;
foreach (var r in racers)
{
Console.WriteLine($"{r:A}");
}
}
Starting the program with this LINQ query returns Niki Lauda, Nelson
Piquet, and Ayrton Senna, as shown here:
Niki Lauda, Austria, Starts: 173, Wins: 25
Nelson Piquet, Brazil, Starts: 204, Wins: 23
Ayrton Senna, Brazil, Starts: 161, Wins: 41
Not all queries can be done with the LINQ query syntax, and not all
extension methods are mapped to LINQ query clauses. Advanced
queries require using extension methods. To better understand
complex queries with extension methods, it’s good to see how simple
queries are mapped. Using the extension methods Where and Select
produces a query very similar to the LINQ query done before (code file
EnumerableSample/FilteringSamples.cs ):
static void FilteringWithMethods()
{
var racers = Formula1.GetChampions()
.Where(r => r.Wins > 15 &&
(r.Country == "Brazil" || r.Country == "Austria"))
.Select(r => r);
//...


}
Filtering with Index
One scenario in which you can’t use the LINQ query is an overload of
the Where method. With an overload of the 3 Where method, you can
pass a second parameter that is the index. The index is a counter for
every result returned from the filter. You can use the index within the
expression to do some calculation based on the index. In the following
example, the index is used within the code that is called by the Where
extension method to return only racers whose last name starts with A
if the index is even (code file EnumerableSample/FilteringSamples.cs ):
static void FilteringWithIndex()
{
var racers = Formula1.GetChampions()
.Where((r, index) => r.LastName.StartsWith("A") && index
% 2 != 0);
foreach (var r in racers)
{
Console.WriteLine($"{r:A}");
}
}
The racers with last names beginning with the letter A are Alberto
Ascari, Mario Andretti, and Fernando Alonso. Because Mario Andretti
is positioned within an index that is odd, he is not in the result:
Alberto Ascari, Italy; starts: 32, wins: 10
Fernando Alonso, Spain; starts: 279, wins: 33
Type Filtering
For filtering based on a type you can use the OfType extension method.
Here the array data contains both string and int objects. Using the
extension method OfType , passing the string class to the generic
parameter returns only the strings from the collection (code file
EnumerableSample/FilteringSamples.cs ):
static void TypeFiltering()
{
object[] data = { "one", 2, 3, "four", "five", 6 };


var query = data.OfType<string>();
foreach (var s in query)
{
Console.WriteLine(s);
}
}
Running this code, the strings one, four, and five are displayed:
one
four
five
Compound from
If you need to do a filter based on a member of the object that itself is a
sequence, you can use a compound from . The Racer class defines a
property Cars , where Cars is a string array. For a filter of all racers who
were champions with a Ferrari, you can use the LINQ query shown
next. The first from clause accesses the Racer objects returned from
Formula1.GetChampions . The second from clause accesses the Cars
property of the Racer class to return all cars of type string . Next the
cars are used with the where clause to filter only the racers who were
champions with a Ferrari (code file
EnumerableSample/CompoundFromSamples.cs ):
static void CompoundFrom()
{
var ferrariDrivers = from r in Formula1.GetChampions()
from c in r.Cars
where c == "Ferrari"
orderby r.LastName
select r.FirstName + " " + r.LastName;
//...
}
If you are curious about the result of this query, following are all
Formula-1 champions driving a Ferrari:
Alberto Ascari
Juan Manuel Fangio
Mike Hawthorn
Phil Hill


Niki Lauda
Kimi Räikkönen
Jody Scheckter
Michael Schumacher
John Surtees
The C# compiler converts a compound from clause with a LINQ query
to the SelectMany extension method. SelectMany can be used to iterate
a sequence of a sequence. The overload of the SelectMany method that
is used with the example is shown here:
public static IEnumerable<TResult> SelectMany<TSource,
TCollection, TResult> (
this IEnumerable<TSource> source,
Func<TSource,
IEnumerable<TCollection>> collectionSelector,
Func<TSource, TCollection, TResult> resultSelector);
The first parameter is the implicit parameter that receives the
sequence of Racer objects from the GetChampions method. The second
parameter is the collectionSelector delegate where the inner
sequence is defined. With the lambda expression r => r.Cars , the
collection of cars should be returned. The third parameter is a delegate
that is now invoked for every car and receives the Racer and Car
objects. The lambda expression creates an anonymous type with a
Racer and a Car property. Because of this SelectMany method, the
hierarchy of racers and cars is flattened and a collection of new objects
of an anonymous type for every car is returned.
This new collection is passed to the Where method so that only the
racers driving a Ferrari are filtered. Finally, the OrderBy and Select
methods are invoked (code file
EnumerableSample/CompoundFromSamples.cs ):
static void CompoundFromWithMethods()
{
var ferrariDrivers = Formula1.GetChampions()
.SelectMany(r => r.Cars, (r, c) => new { Racer = r, Car =
c })
.Where(r => r.Car == "Ferrari")
.OrderBy(r => r.Racer.LastName)
.Select(r => r.Racer.FirstName + " " + r.Racer.LastName);
//...


}
Resolving the generic SelectMany method to the types that are used
here, the types are resolved as follows. In this case the source is of type
Racer , the filtered collection is a string array, and of course the name
of the anonymous type that is returned is not known and is shown
here as TResult :
public static IEnumerable<TResult> SelectMany<Racer, string,
TResult> (
this IEnumerable<Racer> source,
Func<Racer, IEnumerable<string>> collectionSelector,
Func<Racer, string, TResult> resultSelector);
Because the query was just converted from a LINQ query to extension
methods, the result is the same as before.
Sorting
To sort a sequence, the orderby clause was used already. This section
reviews the earlier example, now with the orderby descending clause.
Here the racers are sorted based on the number of wins as specified by
the key selector in descending order (code file
EnumerableSample/SortingSamples.cs ):
static void SortDescending()
{
var racers = from r in Formula1.GetChampions()
where r.Country == "Brazil"
orderby r.Wins descending
select r;
//...
}
The orderby clause is resolved to the OrderBy method, and the orderby
descending clause is resolved to the OrderByDescending method (code
file EnumerableSample/SortingSamples.cs ):
static void SortDescendingWithMethods()
{
var racers = Formula1.GetChampions()
.Where(r => r.Country == "Brazil")
.OrderByDescending(r => r.Wins)
.Select(r => r);


//...
}
The OrderBy and OrderByDescending methods return
IOrderedEnumerable<TSource> . This interface derives from the interface
IEnumerable<TSource> but contains an additional method,
CreateOrdered-Enumerable<TSource> . This method is used for further
ordering of the sequence. If two items are the same based on the key
selector, ordering can continue with the ThenBy and ThenByDescending
methods. These methods require an IOrderedEnumerable<TSource> to
work on but return this interface as well. Therefore, you can add any
number of ThenBy and ThenByDescending methods to sort the collection.
Using the LINQ query, you just add all the different keys (with
commas) for sorting to the orderby clause. In the next example, the
sort of all racers is done first based on country, next on last name, and
finally on first name. The Take extension method that is added to the
result of the LINQ query is used to return the first 10 results (code file
EnumerableSample/SortingSamples.cs ):
static void SortMultiple()
{
var racers = (from r in Formula1.GetChampions()
orderby r.Country, r.LastName, r.FirstName
select r).Take(10);
//...
}
The sorted result is shown here:
Argentina: Fangio, Juan Manuel
Australia: Brabham, Jack
Australia: Jones, Alan
Austria: Lauda, Niki
Austria: Rindt, Jochen
Brazil: Fittipaldi, Emerson
Brazil: Piquet, Nelson
Brazil: Senna, Ayrton
Canada: Villeneuve, Jacques
Finland: Hakkinen, Mika
Doing the same with extension methods makes use of the OrderBy and
ThenBy methods (code file EnumerableSample/SortingSamples.cs ):


static void SortMultipleWithMethods()
{
var racers = Formula1.GetChampions()
.OrderBy(r => r.Country)
.ThenBy(r => r.LastName)
.ThenBy(r => r.FirstName)
.Take(10);
//...
}
Grouping
To group query results based on a key value, the group clause can be
used. Now the Formula-1 champions should be grouped by country,
and the number of champions within a country should be listed. The
clause group r by r.Country into g groups all the racers based on the
Country property and defines a new identifier g that can be used later
to access the group result information. The result from the group
clause is ordered based on the extension method Count that is applied
on the group result; and if the count is the same, the ordering is done
based on the key. This is the country because this was the key used for
grouping. The where clause filters the results based on groups that
have at least two items, and the select clause creates an anonymous
type with the Country and Count properties (code file
EnumerableSample/GroupingSamples.cs ):
static void Grouping()
{
var countries = from r in Formula1.GetChampions()
group r by r.Country into g
orderby g.Count() descending, g.Key
where g.Count() >= 2
select new
{
Country = g.Key,
Count = g.Count()
};
foreach (var item in countries)
{
Console.WriteLine($"{item.Country, -10} {item.Count}");
}
}


The result displays the collection of objects with the Country and Count
properties:
UK
Brazil
Finland
Germany
Australia
Austria
Italy
USA
















Doing the same with extension methods, the groupby clause is resolved
to the GroupBy method. What’s interesting with the declaration of the
GroupBy method is that it returns an enumeration of objects
implementing the IGrouping interface. The IGrouping interface defines
the Key property, so you can access the key of the group after defining
the call to this method:
public static IEnumerable<IGrouping<TKey, TSource>>
GroupBy<TSource, TKey>(
this IEnumerable<TSource> source, Func<TSource, TKey>
keySelector);
The group r by r.Country into g clause is resolved to GroupBy(r =>
r.Country) and returns the group sequence. The group sequence is
first ordered by the OrderByDescending method, then by the ThenBy
method. Next, the Where and Select methods that you already know
are invoked (code file EnumerableSample/GroupingSamples.cs ):
static void GroupingWithMethods()
{
var countries = Formula1.GetChampions()
.GroupBy(r => r.Country)
.OrderByDescending(g => g.Count())
.ThenBy(g => g.Key)
.Where(g => g.Count() >= 2)
.Select(g => new
{
Country = g.Key,
Count = g.Count()
});
Variables Within the LINQ Query


With the LINQ query as it is written for grouping, the Count method is
called multiple times. You can change this by using the let clause. let
allows defining variables within the LINQ query (code file
EnumerableSample/GroupingSamples.cs ):
static void GroupingWithVariables()
{
var countries = from r in Formula1.GetChampions()
group r by r.Country into g
let count = g.Count()
orderby count descending, g.Key
where count >= 2
select new
{
Country = g.Key,
Count = count
};
//...
}
Using the method syntax, the Count method was invoked multiple
times as well. To define extra data to pass to the next method (what is
really done by the let clause), you can use the Select method to create
anonymous types. Here an anonymous type with Group and Count
properties is created. A collection of items with these properties is
passed to the OrderByDescending method where the sort is based on the
Count property of this anonymous type:
static void GroupingWithAnonymousTypes()
{
var countries = Formula1.GetChampions()
.GroupBy(r => r.Country)
.Select(g => new { Group = g, Count = g.Count() })
.OrderByDescending(g => g.Count)
.ThenBy(g => g.Group.Key)
.Where(g => g.Count >= 2)
.Select(g => new
{
Country = g.Group.Key,
Count = g.Count
});
//...
}
Take care with the number of interim objects created based on the let


clause or Select method. When you query through large lists, the
number of objects created that need to be garbage collected later can
have a huge impact on performance.
Grouping with Nested Objects
If the grouped objects should contain nested sequences, you can do
that by changing the anonymous type created by the select clause.
With this example, the returned countries should contain not only the
properties for the name of the country and the number of racers, but
also a sequence of the names of the racers. This sequence is assigned
by using an inner from / in clause assigned to the Racers property. The
inner from clause is using the g group to get all racers from the group,
order them by last name, and create a new string based on the first
and last name (code file EnumerableSample/GroupingSamples.cs ):
static void GroupingAndNestedObjects()
{
var countries = from r in Formula1.GetChampions()
group r by r.Country into g
let count = g.Count()
orderby count descending, g.Key
where count >= 2
select new
{
Country = g.Key,
Count = count,
Racers = from r1 in g
orderby r1.LastName
select r1.FirstName + " " +
r1.LastName
};
foreach (var item in countries)
{
Console.WriteLine($"{item.Country, -10} {item.Count}");
foreach (var name in item.Racers)
{
Console.Write($"{name}; ");
}
Console.WriteLine();
}
}


Using extension methods, the inner Racer objects are created using the
group variable g of type IGrouping where the Key property is the key for
the grouping—the country in this case—and the items of a group can
be accessed using the Group property:
static void GroupingAndNestedObjectsWithMethods()
{
var countries = Formula1.GetChampions()
.GroupBy(r => r.Country)
.Select(g => new
{
Group = g,
Key = g.Key,
Count = g.Count()
})
.OrderByDescending(g => g.Count)
.ThenBy(g => g.Key)
.Where(g => g.Count >= 2)
.Select(g => new
{
Country = g.Key,
Count = g.Count,
Racers = g.Group.OrderBy(r => r.LastName)
.Select(r => r.FirstName + " " + r.LastName)
});
//...
}
The output now lists all champions from the specified countries:
UK


Jenson Button; Jim Clark; Lewis Hamilton; Mike Hawthorn;
Graham Hill;
Damon Hill; James Hunt; Nigel Mansell; Jackie Stewart; John
Surtees;
Brazil


Emerson Fittipaldi; Nelson Piquet; Ayrton Senna;
Finland


Mika Hakkinen; Kimi Raikkonen; Keke Rosberg;
Germany


Nico Rosberg; Michael Schumacher; Sebastian Vettel;
Australia 2
Jack Brabham; Alan Jones;
Austria


Niki Lauda; Jochen Rindt;
Italy




Alberto Ascari; Nino Farina;
USA


Mario Andretti; Phil Hill;
Inner Join
You can use the join clause to combine two sources based on specific
criteria. First, however, let’s get two lists that should be joined. With
Formula-1, there are drivers and a constructor champions. The drivers
are returned from the method GetChampions , and the constructors are
returned from the method GetConstructorChampions . It would be
interesting to get a list by year in which every year lists the driver and
the constructor champions.
To do this, the first two queries for the racers and the teams are
defined (code file EnumerableSample/JoinSamples.cs ):
static void InnerJoin()
{
var racers = from r in Formula1.GetChampions()
from y in r.Years
select new
{
Year = y,
Name = r.FirstName + " " + r.LastName
};
var teams = from t
from y
select
{
Year
Name
};
//...
in Formula1.GetContructorChampions()
in t.Years
new
= y,
= t.Name
}
Using these two queries, a join is done based on the year of the driver
champion and the year of the team champion with the join clause. The
select clause defines a new anonymous type containing Year , Racer ,
and Team properties:
var racersAndTeams = (from r in racers
join t in teams on r.Year equals t.Year


select new
{
r.Year,
Champion = r.Name,
Constructor = t.Name
}).Take(10);
Console.WriteLine("Year World Champion\t Constructor Title");
foreach (var item in racersAndTeams)
{
Console.WriteLine($"{item.Year}: {item.Champion,-20}
{item.Constructor}");
}
Of course, you can also combine this into just one LINQ query, but
that’s a matter of taste:
var racersAndTeams =
(from r in
from r1 in Formula1.GetChampions()
from yr in r1.Years
select new
{
Year = yr,
Name = r1.FirstName + " " + r1.LastName
}
join t in
from t1 in Formula1.GetContructorChampions()
from yt in t1.Years
select new
{
Year = yt,
Name = t1.Name
}
on r.Year equals t.Year
orderby t.Year
select new
{
Year = r.Year,
Racer = r.Name,
Team = t.Name
}).Take(10);
Using extension methods, the racers and teams can be joined by
invoking the Join method, passing the teams with the first argument
to join them with the racers, specifying the key selectors for the outer


and the inner collection, and defining the result selector with the last
argument (code file EnumerableSample/JoinSamples.cs ):
static void InnerJoinWithMethods()
{
var racers = Formula1.GetChampions()
.SelectMany(r => r.Years, (r1, year) =>
new
{
Year = year,
Name = $"{r1.FirstName} {r1.LastName}"
});
var teams = Formula1.GetConstructorChampions()
.SelectMany(t => t.Years, (t, year) =>
new
{
Year = year,
Name = t.Name
});
var racersAndTeams = racers.Join(
teams,
r => r.Year,
t => t.Year,
(r, t) =>
new
{
Year = r.Year,
Champion = r.Name,
Constructor = t.Name
}).OrderBy(item => item.Year).Take(10);
//...
}
The output displays data from the anonymous type for the first 10
years in which both a drivers’ and constructor championship took
place:
Year World Champion Constructor Title
1958: Mike Hawthorn Vanwall
1959: Jack Brabham Cooper
1960: Jack Brabham Cooper
1961: Phil Hill Ferrari
1962: Graham Hill BRM
1963: Jim Clark Lotus


1964:
1965:
1966:
1967:
John Surtees Ferrari
Jim Clark Lotus
Jack Brabham Brabham
Denny Hulme Brabham
Figure 12-1 shows a graphical presentation of two collections
combined with an inner join. Using an inner join, the results are
matches with both collections.
FIGURE 12-1
Left Outer Join
The output from the previous join sample started with the year 1958—
the first year when both the drivers’ and constructor championship
started. The drivers’ championship started earlier, in the year 1950.
With an inner join, results are returned only when matching records
are found. To get a result with all the years included, you can use a left
outer join. A left outer join returns all the elements in the left sequence
even when no match is found in the right sequence.
The earlier LINQ query is changed to a left outer join. A left outer join
is defined with the join clause together with the DefaultIfEmpty
method. If the left side of the query (the racers) does not have a
matching constructor champion, the default value for the right side is
defined by the DefaultIfEmpty method (code file
EnumerableSample/JoinSamples.cs ):
static void LeftOuterJoin()
{
//...
var racersAndTeams =
(from r in racers
join t in teams on r.Year equals t.Year into rt


from t in rt.DefaultIfEmpty()
orderby r.Year
select new
{
Year = r.Year,
Champion = r.Name,
Constructor = t == null ? "no constructor
championship" : t.Name
}).Take(10);
//...
}
Doing the same query with the extension methods, the GroupJoin
method is used. The first three parameters are similar with Join and
GroupJoin . The result of GroupJoin is different. Instead of a flat list that
is returned from the Join method, GroupJoin returns a list where every
matching item of the first list contains a list of matches from the
second list. Using the following SelectMany method, the list is flattened
again. In case no teams are available for a match, the Constructors
property is assigned to the default value of the type, which is null with
classes. When you create the anonymous type, the Constructor
property gets the string “no constructor championship” assigned if the
team is null (code file EnumerableSample/JoinSamples.cs ):
static void LeftOuterJoinWithMethods()
{
//...
var racersAndTeams =
racers.GroupJoin(
teams,
r => r.Year,
t => t.Year,
(r, ts) => new
{
Year = r.Year,
Champion = r.Name,
Constructors = ts
})
.SelectMany(
rt => rt.Constructors.DefaultIfEmpty(),
(r, t) => new
{
Year = r.Year,
Champion = r.Champion,
Constructor = t?.Name ?? "no constructor


championship"
});
//...
}
NOTE
Other usages of the GroupJoin method are shown in the next
section.
Running the application with this query, the output starts with the
year 1950 as shown here:
Year Champion Constructor Title
1950: Nino Farina no constructor championship
1951: Juan Manuel Fangio no constructor championship
1952: Alberto Ascari no constructor championship
1953: Alberto Ascari no constructor championship
1954: Juan Manuel Fangio no constructor championship
1955: Juan Manuel Fangio no constructor championship
1956: Juan Manuel Fangio no constructor championship
1957: Juan Manuel Fangio no constructor championship
1958: Mike Hawthorn Vanwall
1959: Jack Brabham Cooper
Figure 12-2 shows a graphical presentation of two collections
combined with a left outer join. Using a left outer join, the results are
not just matches with both collections A and B but also include the
right collection B.
FIGURE 12-2


Group Join
A left outer join makes use of a group join together with the into
clause. It uses partly the same syntax as the group join. The group join
just doesn’t need the DefaultIfEmpty method.
With a group join, two independent sequences can be joined, whereby
one sequence contains a list of items for one element of the other
sequence.
The following example uses two independent sequences. One is the list
of champions that you already know from previous examples. The
second sequence is a collection of Championship types. The
Championship type is shown in the next code snippet. This class
contains the year of the championship and the racers with the first,
second, and third positions of the year with the properties Year , First ,
Second , and Third (code file DataLib/Championship.cs ):
public class Championship
{
public Championship(int year, string first, string second,
string third)
{
Year = year;
First = first;
Second = second:
Third = third;
}
public
public
public
public
int Year { get; }
string First { get; }
string Second { get; }
string Third { get; }
}
The collection of championships is returned from the method
GetChampionships as shown in the following code snippet (code file
DataLib/Formula1.cs ):
private static List<Championship> s_championships;
public static IEnumerable<Championship> GetChampionships()
{
if (s_championships == null)
{


s_championships = new List<Championship>
{
new Championship(1950, "Nino Farina", "Juan Manuel
Fangio",
"Luigi Fagioli"),
new Championship(1951, "Juan Manuel Fangio", "Alberto
Ascari",
"Froilan Gonzalez"),
//...
}
}
return s_championships;
}
The list of champions should be combined with the list of racers that
are found within the first three positions in every year of
championships, and for every world champion the results for every
year should be displayed.
Because in the list of championships every item contains three racers,
this list needs to be flattened first. One way to do this is by using a
compound from. As there’s no collection available with a property of a
single item, but instead the three properties First , Second , and Third
need to be combined and flattened, a new List<T> is created that is
filled with information from these properties. For a newly created
object, custom classes and anonymous types can be used as you’ve
already seen several times. This time, we use a new feature of C# 7 and
create a tuple. Tuples contain members of different types and can be
created using tuple literals with parentheses as shown in the following
code snippet. Here, a flat list of tuples contains the year, position in
the championship, first name, and last name information from racers
(code file EnumerableSample/JoinSamples.cs ):
static void GroupJoin()
{
var racers = from cs in Formula1.GetChampionships()
from r in new List<
(int Year, int Position, string FirstName,
string LastName)>()
{
(cs.Year, Position: 1, FirstName:
cs.First.FirstName(),
LastName: cs.First.LastName()),


(cs.Year, Position: 2, FirstName:
cs.Second.FirstName(),
LastName: cs.Second.LastName()),
(cs.Year, Position: 3, FirstName:
cs.Third.FirstName(),
LastName: cs.Third.LastName())
}
select r;
//...
}
NOTE
Chapter 13, “Functional Programming with C#,” gives detailed
information about tuples. The sample code here makes use of a
tuple enhancement available with C# 7.1, thus the compiler
setting must be configured to use at least version 7.1.
The extension methods FirstName and LastName use the last blank
character to split up the string (code file
EnumerableSample/StringExtensions.cs ):
public static class StringExtensions
{
public static string FirstName(this string name) =>
name.Substring(0, name.LastIndexOf(' '));
public static string LastName(this string name) =>
name.Substring(name.LastIndexOf(' ') + 1);
}
With a join clause the racers from both lists can be combined.
Formula1.GetChampions returns a list of Racers , and the racers variable
returns the list of tuples that contains the year, the result, and the
names of racers. It’s not enough to compare the items from these two
collections by using the last name. Sometimes a racer and his father
can be found in the list (for example, Damon Hill and Graham Hill), so
it’s necessary to compare the items by both FirstName and LastName .
You do this by creating a new tuple type for both lists. Using the into
clause, the result from the second collection is put into the variable


yearResults . yearResults
is created for every racer in the first
collection and contains the results of the matching first name and last
name from the second collection. Finally, with the LINQ query a new
tuple type is created that contains the needed information (code file
EnumerableSample/JoinSamples.cs ):
static void GroupJoin()
{
//...
var q = (from r in Formula1.GetChampions()
join r2 in racers on
(
r.FirstName,
r.LastName
)
equals
(
r2.FirstName,
r2.LastName
)
into yearResults
select
(
r.FirstName,
r.LastName,
r.Wins,
r.Starts,
Results: yearResults
));
foreach (var r in q)
{
Console.WriteLine($"{r.FirstName} {r.LastName}");
foreach (var results in r.Results)
{
Console.WriteLine($"\t{results.Year}
{results.Position}");
}
}
}
The last results from the foreach loop are shown next. Jenson Button
has been among the top three for three years—2004 as third, 2009 as
first, and 2011 as second; Sebastian Vettel was world champion four
times and had the second position in 2009 and the third in 2015; and


Nico Rosberg was world champion in 2016, and was in the second
position two times in 2014 and 2015:
Jenson Button
2004 3
2009 1
2011 2
Sebastian Vettel
2009 2
2010 1
2011 1
2012 1
2013 1
2015 3
Nico Rosberg
2014 2
2015 2
2016 1
Using GroupJoin with extension methods, the syntax probably looks
easier to catch. First, the compound from is done with the SelectMany
method. This part is not very different, and tuples are used again. The
GroupJoin method is invoked by passing the racers with the first
parameter to join the champions with the flattened racers, and the
match for both collections with the second and third parameters. The
fourth parameter receives the racer from the first collection and a
collection of the second. This is the results containing the position and
the year, which are written to the Results tuple member (code file
EnumerableSample/JoinSamples.cs ):
static void GroupJoinWithMethods()
{
var racers = Formula1.GetChampionships()
.SelectMany(cs => new List<(int Year, int Position,
string FirstName,
string LastName)>
{
(cs.Year, Position: 1, FirstName: cs.First.FirstName(),
LastName: cs.First.LastName()),
(cs.Year, Position: 2, FirstName:
cs.Second.FirstName(),
LastName: cs.Second.LastName()),
(cs.Year, Position: 3, FirstName: cs.Third.FirstName(),
LastName: cs.Third.LastName())
});


var q = Formula1.GetChampions()
.GroupJoin(racers,
r1 => (r1.FirstName, r1.LastName),
r2 => (r2.FirstName, r2.LastName),
(r1, r2s) => (r1.FirstName, r1.LastName, r1.Wins,
r1.Starts,
Results: r2s));
//...
}
Set Operations
The extension methods Distinct , Union , Intersect , and Except are set
operations. The following example creates a sequence of Formula-1
champions driving a Ferrari and another sequence of Formula-1
champions driving a McLaren, and then determines whether any
driver has been a champion driving both cars. Of course, that’s where
the Intersect extension method can help.
First, you need to get all champions driving a Ferrari. This uses a
simple LINQ query with a compound from to access the property Cars
that’s returning a sequence of string objects:
var ferrariDrivers = from r in Formula1.GetChampions()
from c in r.Cars
where c == "Ferrari"
orderby r.LastName
select r;
Now the same query with a different parameter of the where clause is
needed to get all McLaren racers. It’s not a good idea to write the same
query again. Another option is to create a method in which you can
pass the parameter car . In case the method wouldn’t be needed in
other places, you can create a local function. racersByCar is the name
of a local function that is implemented as a lambda expression
containing a LINQ query. The local function racersByCar is defined
within the scope of the method SetOperations , and thus it can be
invoked only within this method. The LINQ Intersect extension
method is used to get all racers who won the championship with a
Ferrari and a McLaren (code file EnumerableSample/LinqSamples.cs ):


static void SetOperations()
{
IEnumerable<Racer> racersByCar(string car) =>
from r in Formula1.GetChampions()
from c in r.Cars
where c == car
orderby r.LastName
select r;
Console.WriteLine("World champion with Ferrari and
McLaren");
foreach (var racer in
racersByCar("Ferrari").Intersect(racersByCar("McLaren")))
{
Console.WriteLine(racer);
}
}
NOTE
Local functions are a new feature of C# 7 and are discussed in
detail in Chapter 13.
The result is just one racer, Niki Lauda:
World champion with Ferrari and McLaren
Niki Lauda
NOTE
The set operations compare the objects by invoking the
GetHashCode and Equals methods of the entity class. For custom
comparisons, you can also pass an object that implements the
interface IEqualityComparer<T> . In the preceding example, the
GetChampions method always returns the same objects, so the
default comparison works. If that’s not the case, the set methods
offer overloads in which a comparison can be defined.


Zip
The Zip method enables you to merge two related sequences into one
with a predicate function.
First, two related sequences are created, both with the same filtering
(country Italy) and ordering. For merging this is important, as item 1
from the first collection is merged with item 1 from the second
collection, item 2 with item 2, and so on. In case the count of the two
sequences is different, Zip stops when the end of the smaller collection
is reached.
The items in the first collection have a Name property, and the items in
the second collection have LastName and Starts properties.
Using the Zip method on the collection racerNames requires the second
collection racerNamesAndStarts as the first parameter. The second
parameter is of type Func<TFirst, TSecond, TResult> . This parameter
is implemented as a lambda expression and receives the elements of
the first collection with the parameter first, and the elements of the
second collection with the parameter second . The implementation
creates and returns a string containing the Name property of the first
element and the Starts property of the second element (code file
EnumerableSample/LinqSamples.cs ):
static void ZipOperation()
{
var racerNames = from r in Formula1.GetChampions()
where r.Country == "Italy"
orderby r.Wins descending
select new
{
Name = r.FirstName + " " + r.LastName
};
var racerNamesAndStarts = from r in Formula1.GetChampions()
where r.Country == "Italy"
orderby r.Wins descending
select new
{
r.LastName,
r.Starts
};


var racers = racerNames.Zip(racerNamesAndStarts,
(first, second) => first.Name + ", starts:
second.Starts);
foreach (var r in racers)
{
Console.WriteLine(r);
}
}
The result of this merge is shown here:
Alberto Ascari, starts: 32
Nino Farina, starts: 33
Partitioning
Partitioning operations such as the extension methods Take and Skip
can be used for easy paging—for example, to display just five racers on
the first page, and continue with the next five on the following pages.
With the LINQ query shown here, the extension methods Skip and
Take are added to the end of the query. The Skip method first ignores a
number of items calculated based on the page size and the actual page
number; the Take method then takes a number of items based on the
page size (code file EnumerableSample/LinqSamples.cs ):
static void Partitioning()
{
int pageSize = 5;
int numberPages =
(int)Math.Ceiling(Formula1.GetChampions().Count() /
(double)pageSize);
for (int page = 0; page < numberPages; page++)
{
Console.WriteLine($"Page {page}");
var racers = (from r in Formula1.GetChampions()
orderby r.LastName, r.FirstName
select r.FirstName + " " + r.LastName).
Skip(page * pageSize).Take(pageSize);
foreach (var name in racers)


{
Console.WriteLine(name);
}
Console.WriteLine();
}
}
Here is the output of the first three pages:
Page 0
Fernando Alonso
Mario Andretti
Alberto Ascari
Jack Brabham
Jenson Button
Page 1
Jim Clark
Juan Manuel Fangio
Nino Farina
Emerson Fittipaldi
Mika Hakkinen
Page 2
Lewis Hamilton
Mike Hawthorn
Damon Hill
Graham Hill
Phil Hill
Paging can be extremely useful with Windows or web applications,
showing the user only a part of the data.
NOTE
Note an important behavior of this paging mechanism: Because
the query is done with every page, changing the underlying data
affects the results. New objects are shown as paging continues.
Depending on your scenario, this can be advantageous to your
application. If this behavior is not what you need, you can do the
paging not over the original data source but by using a cache that
maps to the original data.


With the TakeWhile and SkipWhile extension methods you can also
pass a predicate to retrieve or skip items based on the result of the
predicate.
Aggregate Operators
The aggregate operators such as Count , Sum , Min , Max , Average , and
Aggregate do not return a sequence; instead they return a single value.
The Count extension method returns the number of items in the
collection. In the following example, the Count method is applied to the
Years property of a Racer to filter the racers and return only those who
won more than three championships. Because the same count is
needed more than once in the same query, a variable numberYears is
defined by using the let clause (code file
EnumerableSample/LinqSamples.cs ):
static void AggregateCount()
{
var query = from r in Formula1.GetChampions()
let numberYears = r.Years.Count()
where numberYears >= 3
orderby numberYears descending, r.LastName
select new
{
Name = r.FirstName + " " + r.LastName,
TimesChampion = numberYears
};
foreach (var r in query)
{
Console.WriteLine($"{r.Name} {r.TimesChampion}");
}
}
The result is shown here:
Michael Schumacher 7
Juan Manuel Fangio 5
Lewis Hamilton 4
Alain Prost 4
Sebastian Vettel 4
Jack Brabham 3
Niki Lauda 3


Nelson Piquet 3
Ayrton Senna 3
Jackie Stewart 3
The Sum method summarizes all numbers of a sequence and returns
the result. In the next example, Sum is used to calculate the sum of all
race wins for a country. First the racers are grouped based on country;
then, with the new anonymous type created, the Wins property is
assigned to the sum of all wins from a single country (code file
EnumerableSample/LinqSamples.cs ):
static void AggregateSum()
{
var countries = (from c in
from r in Formula1.GetChampions()
group r by r.Country into c
select new
{
Country = c.Key,
Wins = (from r1 in c
select r1.Wins).Sum()
}
orderby c.Wins descending, c.Country
select c).Take(5);
foreach (var country in countries)
{
Console.WriteLine("{country.Country} {country.Wins}");
}
}
The most successful countries based on the Formula-1 race champions
are as follows:
UK 216
Germany 162
Brazil 78
France 51
Finland 45
The methods Min , Max , Average , and Aggregate are used in the same
way as Count and Sum . Min returns the minimum number of the values
in the collection, and Max returns the maximum number. Average
calculates the average number. With the Aggregate method you can


pass a lambda expression that performs an aggregation of all the
values.
Conversion Operators
In this chapter you’ve already seen that query execution is deferred
until the items are accessed. Using the query within an iteration, the
query is executed. With a conversion operator, the query is executed
immediately, and the result is returned in an array, a list, or a
dictionary.
In the next example, the ToList extension method is invoked to
immediately execute the query and put the result into a List<T> (code
file EnumerableSample/LinqSamples.cs ):
static void ToList()
{
List<Racer> racers = (from r in Formula1.GetChampions()
where r.Starts > 200
orderby r.Starts descending
select r).ToList();
foreach (var racer in racers)
{
Console.WriteLine($"{racer} {racer:S}");
}
}
The result of this query shows Jenson Button first:
Jenson Button 306
Fernando Alonso 291
Michael Schumacher 287
Kimi Räikkönen 271
Nico Rosberg 207
Nelson Piquet 204
It’s not always that simple to get the returned objects into the list. For
example, for fast access from a car to a racer within a collection class,
you can use the new class Lookup<TKey, TElement> .
NOTE


The Dictionary<TKey , TValue> class supports only a single value
for a key. With the class Lookup<TKey, TElement> from the
namespace System.Linq , you can have multiple values for a single
key. These classes are covered in detail in Chapter 10,
“Collections.”
Using the compound from query, the sequence of racers and cars is
flattened, and an anonymous type with the properties Car and Racer is
created. With the lookup that is returned, the key should be of type
string referencing the car, and the value should be of type Racer . To
make this selection, you can pass a key and an element selector to one
overload of the ToLookup method. The key selector references the Car
property, and the element selector references the Racer property (code
file EnumerableSample/LinqSamples.cs ):
static void ToLookup()
{
var racers = (from r in Formula1.GetChampions()
from c in r.Cars
select new
{
Car = c,
Racer = r
}).ToLookup(cr => cr.Car, cr => cr.Racer);
if (racers.Contains("Williams"))
{
foreach (var williamsRacer in racers["Williams"])
{
Console.WriteLine(williamsRacer);
}
}
}
The result of all “Williams” champions accessed using the indexer of
the Lookup class is shown here:
Alan Jones
Keke Rosberg
Nigel Mansell
Alain Prost
Damon Hill


Jacques Villeneuve
In case you need to use a LINQ query over an untyped collection, such
as the ArrayList , you can use the Cast method. In the following
example, an ArrayList collection that is based on the Object type is
filled with Racer objects. To make it possible to define a strongly typed
query, you can use the Cast method (code file
EnumerableSample/LinqSamples.cs ):
static void ConvertWithCast
{
var list = new
System.Collections.ArrayList(Formula1.GetChampions()
as System.Collections.ICollection);
var query = from r in list.Cast<Racer>()
where r.Country == "USA"
orderby r.Wins descending
select r;
foreach (var racer in query)
{
Console.WriteLine("{racer:A}", racer);
}
}
The results include the only Formula 1 champions from the U.S.:
Mario Andretti, country: USA, starts: 128, wins: 12
Phil Hill, country: USA, starts: 48, wins: 3
Generation Operators
The generation operators Range , Empty , and Repeat are not extension
methods, but normal static methods that return sequences. With
LINQ to Objects, these methods are available with the Enumerable
class.
Have you ever needed a range of numbers filled? Nothing is easier
than using the Range method. This method receives the start value with
the first parameter and the number of items with the second
parameter (code file EnumerableSample/LinqSamples.cs ):
static void GenerateRange()


{
var values = Enumerable.Range(1, 20);
foreach (var item in values)
{
Console.Write($"{item} ", item);
}
Console.WriteLine();
}
NOTE
The Range method does not return a collection filled with the
values as defined. This method does a deferred query execution
like the other methods. It returns a RangeEnumerator that simply
does a yield return with the values incremented.
Of course, the result now looks like this:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
You can combine the result with other extension methods to get a
different result—for example, using the Select extension method:
var values = Enumerable.Range(1, 20).Select(n => n * 3);
The Empty method returns an iterator that does not return values. This
can be used for parameters that require a collection for which you can
pass an empty collection.
The Repeat method returns an iterator that returns the same value a
specific number of times.
PARALLEL LINQ
The class ParallelEnumerable in the System.Linq namespace splits the
work of queries across multiple threads that run simultaneously.
Although the Enumerable class defines extension methods to the
IEnumerable<T> interface, most extension methods of the
ParallelEnumerable class are extensions for the class


ParallelQuery<TSource> . One important exception is the AsParallel
method, which extends IEnumerable<TSource> and returns
ParallelQuery<TSource> , so a normal collection class can be queried
in
a parallel manner.
Parallel Queries
To demonstrate Parallel LINQ (PLINQ), a large collection is needed.
With small collections you don’t see any effect when the collection fits
inside the CPU’s cache. In the following code, a large int collection is
filled with random values (code file ParallelLinqSample/Program.cs ):
static IEnumerable<int> SampleData()
{
const int arraySize = 50000000;
var r = new Random();
return Enumerable.Range(0, arraySize).Select(x =>
r.Next(140)).ToList();
}
Now you can use a LINQ query to filter the data, do some calculations,
and get an average of the filtered data. The query defines a filter with
the where clause to summarize only the items with values < 20 , and
then the aggregation function sum is invoked. The only difference to
the LINQ queries you’ve seen so far is the call to the AsParallel
method:
static void LinqQuery(IEnumerable<int> data)
{
var res = (from x in data.AsParallel()
where Math.Log(x) < 4
select x).Average();
//...
}
Like the LINQ queries shown already, the compiler changes the syntax
to invoke the methods AsParallel , Where , Select , and Average .
AsParallel is defined with the ParallelEnumerable class to extend the
IEnumerable<T> interface, so it can be called with a simple array.
AsParallel returns ParallelQuery<TSource> . Because of the returned
type, the Where method chosen by the compiler is
ParallelEnumerable.Where instead of Enumerable.Where . In the


following code, the Select and Average methods are from
ParallelEnumerable as well. In contrast to the implementation of the
Enumerable class, with the ParallelEnumerable class the query is
partitioned so that multiple threads can work on the query. The
collection can be split into multiple parts whereby different threads
work on each part to filter the remaining items. After the partitioned
work is completed, merging must occur to get the summary result of
all parts:
static void ExtensionMethods(IEnumerable<int> data)
{
var res = data.AsParallel()
.Where(x => Math.Log(x) < 4)
.Select(x => x).Average();
//...
}
When you run this code, you can also start the task manager, so you
can confirm that all CPUs of your system are busy. If you remove the
AsParallel method, multiple CPUs might not be used. Of course, if you
don’t have multiple CPUs on your system, then don’t expect to see an
improvement with the parallel version.
Partitioners
The AsParallel method is an extension not only to the IEnumerable<T>
interface, but also to the Partitioner class. With this you can influence
the partitions to be created.
The Partitioner class is defined within the namespace
System.Collections.Concurrent and has different variants. The Create
method accepts arrays or objects implementing IList<T> . Depending
on that, as well as on the parameter loadBalance , which is of type
Boolean and available with some overloads of the method, a different
partitioner type is returned. For arrays, the classes
DynamicPartitionerForArray<TSource> and
StaticPartitionerForArray<TSource> , are used. Both of which derive
from the abstract base class OrderablePartitioner<TSource> .
In the following example, the code from the “Parallel Queries” section
is changed to manually create a partitioner instead of relying on the


default one (code file ParallelLinqSample/Program.cs ):
static void UseAPartitioner(IList<int> data)
{
var result = (from x in Partitioner.Create(data,
true).AsParallel()
where Math.Log(x) < 4
select x).Average();
//...
}
You can also influence the parallelism by invoking the methods
WithExecutionMode and WithDegreeOfParallelism . With
WithExecutionMode you can pass a value of ParallelExecutionMode ,
which can be Default or ForceParallelism . By default, Parallel LINQ
avoids parallelism with high overhead. With the method
WithDegreeOfParallelism you can pass an integer value to specify the
maximum number of tasks that should run in parallel. This is useful if
not all CPU cores should be used by the query.
NOTE
You can read more about tasks and threads in Chapter 21, “Tasks
and Parallel Programming.”
Cancellation
.NET offers a standard way to cancel long-running tasks, and this is
also true for Parallel LINQ.
To cancel a long-running query, you can add the method
WithCancellation to the query and pass a CancellationToken to the
parameter. The CancellationToken is created from the
CancellationTokenSource . The query is run in a separate thread where
the exception of type OperationCanceledException is caught. This
exception is fired if the query is cancelled. From the main thread the
task can be cancelled by invoking the Cancel method of the
CancellationTokenSource (code file ParallelLinqSample/Program.cs ):


static void UseCancellation(IEnumerable<int> data)
{
var cts = new CancellationTokenSource();
Task.Run(() =>
{
try
{
var res = (from x in
data.AsParallel().WithCancellation(cts.Token)
where Math.Log(x) < 4
select x).Average();
Console.WriteLine($"query finished, sum: {res}");
}
catch (OperationCanceledException ex)
{
Console.WriteLine(ex.Message);
}
});
Console.WriteLine("query started");
Console.Write("cancel? ");
string input = ReadLine();
if (input.ToLower().Equals("y"))
{
// cancel!
cts.Cancel();
}
}
NOTE
You can read more about cancellation and the CancellationToken
in Chapter 21.
EXPRESSION TREES
With LINQ to Objects, the extension methods require a delegate type
as parameter; this way, a lambda expression can be assigned to the
parameter. Lambda expressions can also be assigned to parameters of
type Expression<T> . The C# compiler defines different behavior for


lambda expressions depending on the type. If the type is
Expression<T> , the compiler creates an expression tree from the
lambda expression and stores it in the assembly. The expression tree
can be analyzed during runtime and optimized for querying against
the data source.
Let's turn to a query expression that was used previously:
var brazilRacers = from r in racers
where r.Country == "Brazil"
orderby r.Wins
select r;
The preceding query expression uses the extension methods Where ,
OrderBy , and Select . The Enumerable class defines the Where extension
method with the delegate type Func<T, bool> as parameter predicate:
public static IEnumerable<TSource> Where<TSource>(
this IEnumerable<TSource> source, Func<TSource, bool>
predicate);
This way, the lambda expression is assigned to the predicate. Here, the
lambda expression is like an anonymous method, as explained earlier:
Func<Racer, bool> predicate = r => r.Country == "Brazil";
The Enumerable class is not the only class for defining the Where
extension method. The Where extension method is also defined by the
class Queryable<T> . This class has a different definition of the Where
extension method:
public static IQueryable<TSource> Where<TSource>(
this IQueryable<TSource> source,
Expression<Func<TSource, bool>> predicate);
Here, the lambda expression is assigned to the type Expression<T> ,
which behaves differently:
Expression<Func<Racer, bool>> predicate = r => r.Country ==
"Brazil";
Instead of using delegates, the compiler emits an expression tree to the
assembly. The expression tree can be read during runtime. Expression
trees are built from classes derived from the abstract base class


Expression . The Expression
class is not the same as Expression<T> .
Some of the expression classes that inherit from Expression include
BinaryExpression , ConstantExpression , InvocationExpression ,
LambdaExpression , NewExpression , NewArrayExpression ,
TernaryExpression , UnaryExpression , and more. The compiler creates
an expression tree resulting from the lambda expression.
For example, the lambda expression r.Country == "Brazil" makes use
of ParameterExpression , MemberExpression , ConstantExpression , and
MethodCallExpression to create a tree and store the tree in the
assembly. This tree is then used during runtime to create an optimized
query to the underlying data source.
With the sample application, the method DisplayTree is implemented
to display an expression tree graphically on the console. In the
following example, an Expression object can be passed, and depending
on the expression type some information about the expression is
written to the console. Depending on the type of the expression,
DisplayTree is called recursively (code file
ExpressionTreeSample/Program.cs ):
static void DisplayTree(int indent, string message,
Expression expression)
{
string output = $"{string.Empty.PadLeft(indent, '>')}
{message} " +
$"! NodeType: {expression.NodeType}; Expr: {expression}";
indent++;
switch (expression.NodeType)
{
case ExpressionType.Lambda:
Console.WriteLine(output);
LambdaExpression lambdaExpr =
(LambdaExpression)expression;
foreach (var parameter in lambdaExpr.Parameters)
{
DisplayTree(indent, "Parameter", parameter);
}
DisplayTree(indent, "Body", lambdaExpr.Body);
break;
case ExpressionType.Constant:
ConstantExpression constExpr =


(ConstantExpression)expression;
Console.WriteLine($"{output} Const Value:
{constExpr.Value}");
break;
case ExpressionType.Parameter:
ParameterExpression paramExpr =
(ParameterExpression)expression;
Console.WriteLine($"{output} Param Type:
{paramExpr.Type.Name}");
break;
case ExpressionType.Equal:
case ExpressionType.AndAlso:
case ExpressionType.GreaterThan:
BinaryExpression binExpr =
(BinaryExpression)expression;
if (binExpr.Method != null)
{
Console.WriteLine($"{output} Method:
{binExpr.Method.Name}");
}
else
{
Console.WriteLine(output);
}
DisplayTree(indent, "Left", binExpr.Left);
DisplayTree(indent, "Right", binExpr.Right);
break;
case ExpressionType.MemberAccess:
MemberExpression memberExpr =
(MemberExpression)expression;
Console.WriteLine($"{output} Member Name:
{memberExpr.Member.Name}, " +
" Type: {memberExpr.Expression}");
DisplayTree(indent, "Member Expr",
memberExpr.Expression);
break;
default:
Console.WriteLine();
Console.WriteLine($"{expression.NodeType}
{expression.Type.Name}");
break;
}
}
NOTE


The method DisplayTree does not deal with all expression types—
only the types that are used with the following example
expression.
The expression that is used for showing the tree is already well known.
It’s a lambda expression with a Racer parameter, and the body of the
expression takes racers from Brazil only if they have won more than
six races:
Expression<Func<Racer, bool>> expression =
r => r.Country == "Brazil" && r.Wins > 6;
Looking at the tree result, you can see from the output that the lambda
expression consists of a Parameter and an AndAlso node type. The
AndAlso node type has an Equal node type to the left and a GreaterThan
node type to the right. The Equal node type to the left of the AndAlso
node type has a MemberAccess node type to the left and a Constant node
type to the right, and so on:
Lambda! NodeType: Lambda; Expr: r => ((r.Country == "Brazil")
AndAlso (r.Wins > 6))
> Parameter! NodeType: Parameter; Expr: r Param Type: Racer
> Body! NodeType: AndAlso; Expr: ((r.Country == "Brazil")
AndAlso (r.Wins > 6))
>> Left! NodeType: Equal; Expr: (r.Country == "Brazil")
Method: op_Equality
>>> Left! NodeType: MemberAccess; Expr: r.Country Member
Name: Country, Type: String
>>>> Member Expr! NodeType: Parameter; Expr: r Param Type:
Racer
>>> Right! NodeType: Constant; Expr: "Brazil" Const Value:
Brazil
>> Right! NodeType: GreaterThan; Expr: (r.Wins > 6)
>>> Left! NodeType: MemberAccess; Expr: r.Wins Member Name:
Wins, Type: Int32
>>>> Member Expr! NodeType: Parameter; Expr: r Param Type:
Racer
>>> Right! NodeType: Constant; Expr: 6 Const Value: 6
Examples where the Expression<T> type is used are with the Entity
Framework Core and the client provider for WCF Data Services. These
technologies define methods with Expression<T> parameters. This way


the LINQ provider accessing the database can create a runtime-
optimized query by reading the expressions to get the data from the
database.
LINQ PROVIDERS
.NET includes several LINQ providers. A LINQ provider implements
the standard query operators for a specific data source. LINQ
providers might implement more extension methods than are defined
by LINQ, but the standard operators must at least be implemented.
LINQ to XML implements additional methods that are particularly
useful with XML, such as the methods Elements , Descendants , and
Ancestors defined by the class Extensions in the System.Xml.Linq
namespace.
Implementation of the LINQ provider is selected based on the
namespace and the type of the first parameter. The namespace of the
class that implements the extension methods must be opened;
otherwise, the extension class is not in scope. The parameter of the
Where method defined by LINQ to Objects and the Where method
defined by LINQ to Entities is different.
The Where method of LINQ to Objects is defined with the Enumerable
class:
public static IEnumerable<TSource> Where<TSource>(
this IEnumerable<TSource> source, Func<TSource, bool>
predicate);
Inside the System.Linq namespace is another class that implements
the operator Where . This implementation is used by LINQ to Entities.
You can find the implementation in the class Queryable :
public static IQueryable<TSource> Where<TSource>(
this IQueryable<TSource> source,
Expression<Func<TSource, bool>> predicate);
Both classes are implemented in the System.Core assembly in the
System.Linq namespace. How does the compiler select what method to
use, and what’s the magic with the Expression type? The lambda
expression is the same regardless of whether it is passed with a


Func<TSource, bool> parameter or an Expression<Func<TSource,
bool>> parameter—only the compiler behaves differently. The
selection is done based on the source parameter. The method that
matches best based on its parameters is chosen by the compiler.
Properties of Entity Framework Core contexts are of type
DbSet<TEntity> . DbSet<TEntity> implements IQueryable<TEntity> , and
thus Entity Framework Core uses the Where method of the Queryable
class.
SUMMARY
This chapter described and demonstrated the LINQ query and the
language constructs on which the query is based, such as extension
methods and lambda expressions. You’ve looked at the various LINQ
query operators—not only for filtering and ordering of data sources,
but also for partitioning, grouping, doing conversions, joins, and so
on.
With Parallel LINQ, you’ve seen how longer queries can easily be
parallelized.
Another important concept of this chapter is the expression tree.
Expression trees enable building the query to the data source at
runtime because the tree is stored in the assembly. You can read about
its great advantages in Chapter 26. LINQ is a very in-depth topic, and
you can see Bonus Chapter 2 for information on using LINQ with XML
data. Other third-party providers are also available for download, such
as LINQ to MySQL, LINQ to Amazon, LINQ to Flickr, LINQ to LDAP,
and LINQ to SharePoint. No matter what data source you have, with
LINQ you can use the same query syntax.
The next chapter covers functional programming. Many of the newer
C# features are based on this programming paradigm.